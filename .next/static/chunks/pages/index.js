/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@reach/auto-id/dist/reach-auto-id.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@reach/auto-id/dist/reach-auto-id.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useId\": function() { return /* binding */ useId; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils/use-isomorphic-layout-effect */ \"./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\");\n\n\n\n/*\n * Welcome to @reach/auto-id!\n\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibility APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */\nvar serverHandoffComplete = false;\nvar id = 0;\n\nvar genId = function genId() {\n  return ++id;\n};\n/**\n * useId\n *\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\n *\n * Note: The returned ID will initially be `null` and will update after a\n * component mounts. Users may need to supply their own ID if they need\n * consistent values for SSR.\n *\n * @see Docs https://reach.tech/auto-id\n */\n\n\nfunction useId(idFromProps) {\n  /*\n   * If this instance isn't part of the initial render, we don't have to do the\n   * double render/patch-up dance. We can just generate the ID and return it.\n   */\n  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  var _React$useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialId),\n      id = _React$useState[0],\n      setId = _React$useState[1];\n\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__.useIsomorphicLayoutEffect)(function () {\n    if (id === null) {\n      /*\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n       * rendering flicker, though it'll make the first render slower (unlikely\n       * to matter, but you're welcome to measure your app and let us know if\n       * it's a problem).\n       */\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (serverHandoffComplete === false) {\n      /*\n       * Flag all future uses of `useId` to skip the update dance. This is in\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n       * accidentally bail out of the patch-up dance prematurely.\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL2F1dG8taWQvZGlzdC9yZWFjaC1hdXRvLWlkLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQzBDOztBQUV0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsK0NBQVE7QUFDaEM7QUFDQTs7QUFFQSxFQUFFLG9HQUF5QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC9hdXRvLWlkL2Rpc3QvcmVhY2gtYXV0by1pZC5lc20uanM/NGMyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJ0ByZWFjaC91dGlscy91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0JztcblxuLypcbiAqIFdlbGNvbWUgdG8gQHJlYWNoL2F1dG8taWQhXG5cbiAqIExldCdzIHNlZSBpZiB3ZSBjYW4gbWFrZSBzZW5zZSBvZiB3aHkgdGhpcyBob29rIGV4aXN0cyBhbmQgaXRzXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTb21lIGJhY2tncm91bmQ6XG4gKiAgIDEuIEFjY2Vzc2liaWxpdHkgQVBJcyByZWx5IGhlYXZpbHkgb24gZWxlbWVudCBJRHNcbiAqICAgMi4gUmVxdWlyaW5nIGRldmVsb3BlcnMgdG8gcHV0IElEcyBvbiBldmVyeSBlbGVtZW50IGluIFJlYWNoIFVJIGlzIGJvdGhcbiAqICAgICAgY3VtYmVyc29tZSBhbmQgZXJyb3ItcHJvbmVcbiAqICAgMy4gV2l0aCBhIGNvbXBvbmVudCBtb2RlbCwgd2UgY2FuIGdlbmVyYXRlIElEcyBmb3IgdGhlbSFcbiAqXG4gKiBTb2x1dGlvbiAxOiBHZW5lcmF0ZSByYW5kb20gSURzLlxuICpcbiAqIFRoaXMgd29ya3MgZ3JlYXQgYXMgbG9uZyBhcyB5b3UgZG9uJ3Qgc2VydmVyIHJlbmRlciB5b3VyIGFwcC4gV2hlbiBSZWFjdCAoaW5cbiAqIHRoZSBjbGllbnQpIHRyaWVzIHRvIHJldXNlIHRoZSBtYXJrdXAgZnJvbSB0aGUgc2VydmVyLCB0aGUgSURzIHdvbid0IG1hdGNoXG4gKiBhbmQgUmVhY3Qgd2lsbCB0aGVuIHJlY3JlYXRlIHRoZSBlbnRpcmUgRE9NIHRyZWUuXG4gKlxuICogU29sdXRpb24gMjogSW5jcmVtZW50IGFuIGludGVnZXJcbiAqXG4gKiBUaGlzIHNvdW5kcyBncmVhdC4gU2luY2Ugd2UncmUgcmVuZGVyaW5nIHRoZSBleGFjdCBzYW1lIHRyZWUgb24gdGhlIHNlcnZlclxuICogYW5kIGNsaWVudCwgd2UgY2FuIGluY3JlbWVudCBhIGNvdW50ZXIgYW5kIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0IGJldHdlZW5cbiAqIGNsaWVudCBhbmQgc2VydmVyLiBBbHNvLCBKUyBpbnRlZ2VycyBjYW4gZ28gdXAgdG8gbmluZS1xdWFkcmlsbGlvbi4gSSdtXG4gKiBwcmV0dHkgc3VyZSB0aGUgdGFiIHdpbGwgYmUgY2xvc2VkIGJlZm9yZSBhbiBhcHAgbmV2ZXIgbmVlZHNcbiAqIDEwIHF1YWRyaWxsaW9uIElEcyFcbiAqXG4gKiBQcm9ibGVtIHNvbHZlZCwgcmlnaHQ/XG4gKlxuICogQWgsIGJ1dCB0aGVyZSdzIGEgY2F0Y2ghIFJlYWN0J3MgY29uY3VycmVudCByZW5kZXJpbmcgbWFrZXMgdGhpcyBhcHByb2FjaFxuICogbm9uLWRldGVybWluaXN0aWMuIFdoaWxlIHRoZSBjbGllbnQgYW5kIHNlcnZlciB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lXG4gKiBlbGVtZW50cyBpbiB0aGUgZW5kLCBkZXBlbmRpbmcgb24gc3VzcGVuc2UgYm91bmRhcmllcyAoYW5kIHBvc3NpYmx5IHNvbWUgdXNlclxuICogaW5wdXQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlcikgdGhlIGluY3JlbWVudGluZyBpbnRlZ2VycyB3b24ndCBhbHdheXMgbWF0Y2hcbiAqIHVwLlxuICpcbiAqIFNvbHV0aW9uIDM6IERvbid0IHVzZSBJRHMgYXQgYWxsIG9uIHRoZSBzZXJ2ZXI7IHBhdGNoIGFmdGVyIGZpcnN0IHJlbmRlci5cbiAqXG4gKiBXaGF0IHdlJ3ZlIGRvbmUgaGVyZSBpcyBzb2x1dGlvbiAyIHdpdGggc29tZSB0cmlja3MuIFdpdGggdGhpcyBhcHByb2FjaCwgdGhlXG4gKiBJRCByZXR1cm5lZCBpcyBhbiBlbXB0eSBzdHJpbmcgb24gdGhlIGZpcnN0IHJlbmRlci4gVGhpcyB3YXkgdGhlIHNlcnZlciBhbmRcbiAqIGNsaWVudCBoYXZlIHRoZSBzYW1lIG1hcmt1cCBubyBtYXR0ZXIgaG93IHdpbGQgdGhlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIG1heVxuICogaGF2ZSBnb3R0ZW4uXG4gKlxuICogQWZ0ZXIgdGhlIHJlbmRlciwgd2UgcGF0Y2ggdXAgdGhlIGNvbXBvbmVudHMgd2l0aCBhbiBpbmNyZW1lbnRlZCBJRC4gVGhpc1xuICogY2F1c2VzIGEgZG91YmxlIHJlbmRlciBvbiBhbnkgY29tcG9uZW50cyB3aXRoIGB1c2VJZGAuIFNob3VsZG4ndCBiZSBhIHByb2JsZW1cbiAqIHNpbmNlIHRoZSBjb21wb25lbnRzIHVzaW5nIHRoaXMgaG9vayBzaG91bGQgYmUgc21hbGwsIGFuZCB3ZSdyZSBvbmx5IHVwZGF0aW5nXG4gKiB0aGUgSUQgYXR0cmlidXRlIG9uIHRoZSBET00sIG5vdGhpbmcgYmlnIGlzIGhhcHBlbmluZy5cbiAqXG4gKiBJdCBkb2Vzbid0IGhhdmUgdG8gYmUgYW4gaW5jcmVtZW50ZWQgbnVtYmVyLCB0aG91Z2gtLXdlIGNvdWxkIGRvIGdlbmVyYXRlXG4gKiByYW5kb20gc3RyaW5ncyBpbnN0ZWFkLCBidXQgaW5jcmVtZW50aW5nIGEgbnVtYmVyIGlzIHByb2JhYmx5IHRoZSBjaGVhcGVzdFxuICogdGhpbmcgd2UgY2FuIGRvLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgd2Ugb25seSBkbyB0aGlzIHBhdGNodXAgb24gdGhlIHZlcnkgZmlyc3QgY2xpZW50IHJlbmRlciBldmVyLlxuICogQW55IGNhbGxzIHRvIGB1c2VJZGAgdGhhdCBoYXBwZW4gZHluYW1pY2FsbHkgaW4gdGhlIGNsaWVudCB3aWxsIGJlXG4gKiBwb3B1bGF0ZWQgaW1tZWRpYXRlbHkgd2l0aCBhIHZhbHVlLiBTbywgd2Ugb25seSBnZXQgdGhlIGRvdWJsZSByZW5kZXIgYWZ0ZXJcbiAqIHNlcnZlciBoeWRyYXRpb24gYW5kIG5ldmVyIGFnYWluLCBTTyBCQUNLIE9GRiBBTFJJR0hUP1xuICovXG52YXIgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG52YXIgaWQgPSAwO1xuXG52YXIgZ2VuSWQgPSBmdW5jdGlvbiBnZW5JZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59O1xuLyoqXG4gKiB1c2VJZFxuICpcbiAqIEF1dG9nZW5lcmF0ZSBJRHMgdG8gZmFjaWxpdGF0ZSBXQUktQVJJQSBhbmQgc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBOb3RlOiBUaGUgcmV0dXJuZWQgSUQgd2lsbCBpbml0aWFsbHkgYmUgYG51bGxgIGFuZCB3aWxsIHVwZGF0ZSBhZnRlciBhXG4gKiBjb21wb25lbnQgbW91bnRzLiBVc2VycyBtYXkgbmVlZCB0byBzdXBwbHkgdGhlaXIgb3duIElEIGlmIHRoZXkgbmVlZFxuICogY29uc2lzdGVudCB2YWx1ZXMgZm9yIFNTUi5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2F1dG8taWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUlkKGlkRnJvbVByb3BzKSB7XG4gIC8qXG4gICAqIElmIHRoaXMgaW5zdGFuY2UgaXNuJ3QgcGFydCBvZiB0aGUgaW5pdGlhbCByZW5kZXIsIHdlIGRvbid0IGhhdmUgdG8gZG8gdGhlXG4gICAqIGRvdWJsZSByZW5kZXIvcGF0Y2gtdXAgZGFuY2UuIFdlIGNhbiBqdXN0IGdlbmVyYXRlIHRoZSBJRCBhbmQgcmV0dXJuIGl0LlxuICAgKi9cbiAgdmFyIGluaXRpYWxJZCA9IGlkRnJvbVByb3BzIHx8IChzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPyBnZW5JZCgpIDogbnVsbCk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IHVzZVN0YXRlKGluaXRpYWxJZCksXG4gICAgICBpZCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldElkID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgLypcbiAgICAgICAqIFBhdGNoIHRoZSBJRCBhZnRlciByZW5kZXIuIFdlIGRvIHRoaXMgaW4gYHVzZUxheW91dEVmZmVjdGAgdG8gYXZvaWQgYW55XG4gICAgICAgKiByZW5kZXJpbmcgZmxpY2tlciwgdGhvdWdoIGl0J2xsIG1ha2UgdGhlIGZpcnN0IHJlbmRlciBzbG93ZXIgKHVubGlrZWx5XG4gICAgICAgKiB0byBtYXR0ZXIsIGJ1dCB5b3UncmUgd2VsY29tZSB0byBtZWFzdXJlIHlvdXIgYXBwIGFuZCBsZXQgdXMga25vdyBpZlxuICAgICAgICogaXQncyBhIHByb2JsZW0pLlxuICAgICAgICovXG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB9LCBbXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8qXG4gICAgICAgKiBGbGFnIGFsbCBmdXR1cmUgdXNlcyBvZiBgdXNlSWRgIHRvIHNraXAgdGhlIHVwZGF0ZSBkYW5jZS4gVGhpcyBpcyBpblxuICAgICAgICogYHVzZUVmZmVjdGAgYmVjYXVzZSBpdCBnb2VzIGFmdGVyIGB1c2VMYXlvdXRFZmZlY3RgLCBlbnN1cmluZyB3ZSBkb24ndFxuICAgICAgICogYWNjaWRlbnRhbGx5IGJhaWwgb3V0IG9mIHRoZSBwYXRjaC11cCBkYW5jZSBwcmVtYXR1cmVseS5cbiAgICAgICAqL1xuICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkICE9IG51bGwgPyBTdHJpbmcoaWQpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyB1c2VJZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/auto-id/dist/reach-auto-id.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/combobox/dist/reach-combobox.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reach/combobox/dist/reach-combobox.esm.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Combobox\": function() { return /* binding */ Combobox; },\n/* harmony export */   \"ComboboxButton\": function() { return /* binding */ ComboboxButton; },\n/* harmony export */   \"ComboboxInput\": function() { return /* binding */ ComboboxInput; },\n/* harmony export */   \"ComboboxList\": function() { return /* binding */ ComboboxList; },\n/* harmony export */   \"ComboboxOption\": function() { return /* binding */ ComboboxOption; },\n/* harmony export */   \"ComboboxOptionText\": function() { return /* binding */ ComboboxOptionText; },\n/* harmony export */   \"ComboboxPopover\": function() { return /* binding */ ComboboxPopover; },\n/* harmony export */   \"escapeRegexp\": function() { return /* binding */ escapeRegexp; },\n/* harmony export */   \"unstable_useKeyDown\": function() { return /* binding */ useKeyDown; },\n/* harmony export */   \"useComboboxContext\": function() { return /* binding */ useComboboxContext; },\n/* harmony export */   \"useComboboxOptionContext\": function() { return /* binding */ useComboboxOptionContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils/use-isomorphic-layout-effect */ \"./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\");\n/* harmony import */ var _reach_utils_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils/context */ \"./node_modules/@reach/utils/context/dist/reach-utils-context.esm.js\");\n/* harmony import */ var _reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/utils/type-check */ \"./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js\");\n/* harmony import */ var _reach_utils_make_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reach/utils/make-id */ \"./node_modules/@reach/utils/make-id/dist/reach-utils-make-id.esm.js\");\n/* harmony import */ var _reach_utils_noop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reach/utils/noop */ \"./node_modules/@reach/utils/noop/dist/reach-utils-noop.esm.js\");\n/* harmony import */ var _reach_utils_dev_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @reach/utils/dev-utils */ \"./node_modules/@reach/utils/dev-utils/dist/reach-utils-dev-utils.esm.js\");\n/* harmony import */ var _reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @reach/utils/compose-refs */ \"./node_modules/@reach/utils/compose-refs/dist/reach-utils-compose-refs.esm.js\");\n/* harmony import */ var _reach_utils_use_update_effect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @reach/utils/use-update-effect */ \"./node_modules/@reach/utils/use-update-effect/dist/reach-utils-use-update-effect.esm.js\");\n/* harmony import */ var _reach_utils_use_stateful_ref_value__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @reach/utils/use-stateful-ref-value */ \"./node_modules/@reach/utils/use-stateful-ref-value/dist/reach-utils-use-stateful-ref-value.esm.js\");\n/* harmony import */ var _reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @reach/utils/compose-event-handlers */ \"./node_modules/@reach/utils/compose-event-handlers/dist/reach-utils-compose-event-handlers.esm.js\");\n/* harmony import */ var _reach_descendants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @reach/descendants */ \"./node_modules/@reach/descendants/dist/reach-descendants.esm.js\");\n/* harmony import */ var _reach_auto_id__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @reach/auto-id */ \"./node_modules/@reach/auto-id/dist/reach-auto-id.esm.js\");\n/* harmony import */ var _reach_popover__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @reach/popover */ \"./node_modules/@reach/popover/dist/reach-popover.esm.js\");\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// Forked from https://github.com/bvaughn/highlight-words-core\n\n/**\n * Creates an array of chunk objects representing both higlightable and non\n * highlightable pieces of text that match each search word.\n *\n * @return Array of \"chunk\" objects\n */\nfunction findAll(_ref) {\n  var autoEscape = _ref.autoEscape,\n      _ref$caseSensitive = _ref.caseSensitive,\n      caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive,\n      _ref$findChunks = _ref.findChunks,\n      findChunks = _ref$findChunks === void 0 ? defaultFindChunks : _ref$findChunks,\n      sanitize = _ref.sanitize,\n      searchWords = _ref.searchWords,\n      textToHighlight = _ref.textToHighlight;\n  return fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape: autoEscape,\n        caseSensitive: caseSensitive,\n        sanitize: sanitize,\n        searchWords: searchWords,\n        textToHighlight: textToHighlight\n      })\n    }),\n    totalLength: textToHighlight ? textToHighlight.length : 0\n  });\n}\n/**\n * Takes an array of \"chunk\" objects and combines chunks that overlap into\n * single chunks.\n *\n * @return Array of \"chunk\" objects\n */\n\n\nfunction combineChunks(_ref2) {\n  var chunks = _ref2.chunks;\n  return chunks.sort(function (first, second) {\n    return first.start - second.start;\n  }).reduce(function (processedChunks, nextChunk) {\n    // First chunk just goes straight in the array...\n    if (processedChunks.length === 0) {\n      return [nextChunk];\n    } else {\n      // ... subsequent chunks get checked to see if they overlap...\n      var prevChunk = processedChunks.pop();\n\n      if (nextChunk.start <= prevChunk.end) {\n        // It may be the case that prevChunk completely surrounds nextChunk, so take the\n        // largest of the end indeces.\n        var endIndex = Math.max(prevChunk.end, nextChunk.end);\n        processedChunks.push({\n          highlight: false,\n          start: prevChunk.start,\n          end: endIndex\n        });\n      } else {\n        processedChunks.push(prevChunk, nextChunk);\n      }\n\n      return processedChunks;\n    }\n  }, []);\n}\n/**\n * Examine text for any matches. If we find matches, add them to the returned\n * array as a \"chunk\" object.\n *\n * @return Array of \"chunk\" objects\n */\n\n\nfunction defaultFindChunks(_ref3) {\n  var autoEscape = _ref3.autoEscape,\n      caseSensitive = _ref3.caseSensitive,\n      _ref3$sanitize = _ref3.sanitize,\n      sanitize = _ref3$sanitize === void 0 ? defaultSanitize : _ref3$sanitize,\n      searchWords = _ref3.searchWords,\n      textToHighlight = _ref3.textToHighlight;\n  textToHighlight = sanitize(textToHighlight || \"\");\n  return searchWords.filter(function (searchWord) {\n    return searchWord;\n  }) // Remove empty words\n  .reduce(function (chunks, searchWord) {\n    searchWord = sanitize(searchWord);\n\n    if (autoEscape) {\n      searchWord = escapeRegExpFn(searchWord);\n    }\n\n    var regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n    var match;\n\n    while (match = regex.exec(textToHighlight || \"\")) {\n      var start = match.index;\n      var end = regex.lastIndex; // We do not return zero-length matches\n\n      if (end > start) {\n        chunks.push({\n          highlight: false,\n          start: start,\n          end: end\n        });\n      } // Prevent browsers like Firefox from getting stuck in an infinite loop\n      // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\n\n      if (match.index === regex.lastIndex) {\n        regex.lastIndex++;\n      }\n    }\n\n    return chunks;\n  }, []);\n}\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n *\n * @return Array of \"chunk\" objects\n */\n\n\nfunction fillInChunks(_ref4) {\n  var chunksToHighlight = _ref4.chunksToHighlight,\n      totalLength = _ref4.totalLength;\n  var allChunks = [];\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false);\n  } else {\n    var lastIndex = 0;\n    chunksToHighlight.forEach(function (chunk) {\n      append(lastIndex, chunk.start, false);\n      append(chunk.start, chunk.end, true);\n      lastIndex = chunk.end;\n    });\n    append(lastIndex, totalLength, false);\n  }\n\n  return allChunks;\n\n  function append(start, end, highlight) {\n    if (end - start > 0) {\n      allChunks.push({\n        start: start,\n        end: end,\n        highlight: highlight\n      });\n    }\n  }\n}\n\nfunction defaultSanitize(string) {\n  return string;\n}\n\nfunction escapeRegExpFn(string) {\n  return string.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\n\nvar HighlightWords = {\n  combineChunks: combineChunks,\n  fillInChunks: fillInChunks,\n  findAll: findAll,\n  findChunks: defaultFindChunks\n};\n\nvar _excluded = [\"onSelect\", \"openOnFocus\", \"children\", \"as\", \"aria-label\", \"aria-labelledby\"],\n    _excluded2 = [\"as\", \"selectOnClick\", \"autocomplete\", \"onClick\", \"onChange\", \"onKeyDown\", \"onBlur\", \"onFocus\", \"value\"],\n    _excluded3 = [\"as\", \"children\", \"portal\", \"onKeyDown\", \"onBlur\", \"position\"],\n    _excluded4 = [\"persistSelection\", \"as\"],\n    _excluded5 = [\"as\", \"children\", \"index\", \"value\", \"onClick\"],\n    _excluded6 = [\"as\", \"onClick\", \"onKeyDown\"];\n\nvar _on, _on2, _on3, _on4, _states;\n// States\n// Nothing going on, waiting for the user to type or use the arrow keys\n\nvar IDLE = \"IDLE\"; // The component is suggesting options as the user types\n\nvar SUGGESTING = \"SUGGESTING\"; // The user is using the keyboard to navigate the list, not typing\n\nvar NAVIGATING = \"NAVIGATING\"; // The user is interacting with arbitrary elements inside the popup that\n// are not ComboboxInputs\n\nvar INTERACTING = \"INTERACTING\"; ////////////////////////////////////////////////////////////////////////////////\n// Events\n// User cleared the value w/ backspace, but input still has focus\n\nvar CLEAR = \"CLEAR\"; // User is typing\n\nvar CHANGE = \"CHANGE\"; // Initial input value change handler for syncing user state with state machine\n// Prevents initial change from sending the user to the NAVIGATING state\n// https://github.com/reach/reach-ui/issues/464\n\nvar INITIAL_CHANGE = \"INITIAL_CHANGE\"; // User is navigating w/ the keyboard\n\nvar NAVIGATE = \"NAVIGATE\"; // User can be navigating with keyboard and then click instead, we want the\n// value from the click, not the current nav item\n\nvar SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nvar SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\"; // Pretty self-explanatory, user can hit escape or blur to close the popover\n\nvar ESCAPE = \"ESCAPE\";\nvar BLUR = \"BLUR\"; // The user left the input to interact with arbitrary elements inside the popup\n\nvar INTERACT = \"INTERACT\";\nvar FOCUS = \"FOCUS\";\nvar OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\nvar OPEN_WITH_INPUT_CLICK = \"OPEN_WITH_INPUT_CLICK\";\nvar CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\"; ////////////////////////////////////////////////////////////////////////////////\n\nvar stateChart = {\n  initial: IDLE,\n  states: (_states = {}, _states[IDLE] = {\n    on: (_on = {}, _on[BLUR] = IDLE, _on[CLEAR] = IDLE, _on[CHANGE] = SUGGESTING, _on[INITIAL_CHANGE] = IDLE, _on[FOCUS] = SUGGESTING, _on[NAVIGATE] = NAVIGATING, _on[OPEN_WITH_BUTTON] = SUGGESTING, _on[OPEN_WITH_INPUT_CLICK] = SUGGESTING, _on)\n  }, _states[SUGGESTING] = {\n    on: (_on2 = {}, _on2[CHANGE] = SUGGESTING, _on2[FOCUS] = SUGGESTING, _on2[NAVIGATE] = NAVIGATING, _on2[CLEAR] = IDLE, _on2[ESCAPE] = IDLE, _on2[BLUR] = IDLE, _on2[SELECT_WITH_CLICK] = IDLE, _on2[INTERACT] = INTERACTING, _on2[CLOSE_WITH_BUTTON] = IDLE, _on2)\n  }, _states[NAVIGATING] = {\n    on: (_on3 = {}, _on3[CHANGE] = SUGGESTING, _on3[FOCUS] = SUGGESTING, _on3[CLEAR] = IDLE, _on3[BLUR] = IDLE, _on3[ESCAPE] = IDLE, _on3[NAVIGATE] = NAVIGATING, _on3[SELECT_WITH_CLICK] = IDLE, _on3[SELECT_WITH_KEYBOARD] = IDLE, _on3[CLOSE_WITH_BUTTON] = IDLE, _on3[INTERACT] = INTERACTING, _on3)\n  }, _states[INTERACTING] = {\n    on: (_on4 = {}, _on4[CLEAR] = IDLE, _on4[CHANGE] = SUGGESTING, _on4[FOCUS] = SUGGESTING, _on4[BLUR] = IDLE, _on4[ESCAPE] = IDLE, _on4[NAVIGATE] = NAVIGATING, _on4[CLOSE_WITH_BUTTON] = IDLE, _on4[SELECT_WITH_CLICK] = IDLE, _on4)\n  }, _states)\n};\n\nvar reducer = function reducer(data, event) {\n  var nextState = _extends({}, data, {\n    lastEventType: event.type\n  });\n\n  switch (event.type) {\n    case CHANGE:\n    case INITIAL_CHANGE:\n      return _extends({}, nextState, {\n        navigationValue: null,\n        value: event.value\n      });\n\n    case NAVIGATE:\n    case OPEN_WITH_BUTTON:\n    case OPEN_WITH_INPUT_CLICK:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    case CLEAR:\n      return _extends({}, nextState, {\n        value: \"\",\n        navigationValue: null\n      });\n\n    case BLUR:\n    case ESCAPE:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case SELECT_WITH_CLICK:\n      return _extends({}, nextState, {\n        // if controlled, \"set\" the input to what it already has, and let the\n        // user do whatever they want\n        value: event.isControlled ? data.value : event.value,\n        navigationValue: null\n      });\n\n    case SELECT_WITH_KEYBOARD:\n      return _extends({}, nextState, {\n        // if controlled, \"set\" the input to what it already has, and let the\n        // user do whatever they want\n        value: event.isControlled ? data.value : data.navigationValue,\n        navigationValue: null\n      });\n\n    case CLOSE_WITH_BUTTON:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case INTERACT:\n      return nextState;\n\n    case FOCUS:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    default:\n      return nextState;\n  }\n};\n\nfunction popoverIsExpanded(state) {\n  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\n/**\n * When we open a list, set the navigation value to the value in the input, if\n * it's in the list, then it'll automatically be highlighted.\n *\n * @param stateData\n * @param event\n */\n\n\nfunction findNavigationValue(stateData, event) {\n  // @ts-ignore\n  if (event.value) {\n    // @ts-ignore\n    return event.value; // @ts-ignore\n  } else if (event.persistSelection) {\n    return stateData.value;\n  } else {\n    return null;\n  }\n}\n\nvar ComboboxDescendantContext = /*#__PURE__*/(0,_reach_descendants__WEBPACK_IMPORTED_MODULE_11__.createDescendantContext)(\"ComboboxDescendantContext\");\nvar ComboboxContext = /*#__PURE__*/(0,_reach_utils_context__WEBPACK_IMPORTED_MODULE_2__.createNamedContext)(\"ComboboxContext\", {}); // Allows us to put the option's value on context so that ComboboxOptionText\n// can work it's highlight text magic no matter what else is rendered around\n// it.\n\nvar OptionContext = /*#__PURE__*/(0,_reach_utils_context__WEBPACK_IMPORTED_MODULE_2__.createNamedContext)(\"OptionContext\", {}); ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Combobox\n *\n * @see Docs https://reach.tech/combobox#combobox\n */\n\nvar Combobox = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, forwardedRef) {\n  var _data$navigationValue;\n\n  var onSelect = _ref.onSelect,\n      _ref$openOnFocus = _ref.openOnFocus,\n      openOnFocus = _ref$openOnFocus === void 0 ? false : _ref$openOnFocus,\n      children = _ref.children,\n      _ref$as = _ref.as,\n      Comp = _ref$as === void 0 ? \"div\" : _ref$as,\n      ariaLabel = _ref[\"aria-label\"],\n      ariaLabelledby = _ref[\"aria-labelledby\"],\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var _useDescendantsInit = (0,_reach_descendants__WEBPACK_IMPORTED_MODULE_11__.useDescendantsInit)(),\n      options = _useDescendantsInit[0],\n      setOptions = _useDescendantsInit[1]; // Need this to focus it\n\n\n  var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var popoverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var buttonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(); // When <ComboboxInput autocomplete={false} /> we don't want cycle back to\n  // the user's value while navigating (because it's always the user's value),\n  // but we need to know this in useKeyDown which is far away from the prop\n  // here, so we do something sneaky and write it to this ref on context so we\n  // can use it anywhere else ðŸ˜›. Another new trick for me and I'm excited\n  // about this one too!\n\n  var autocompletePropRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var persistSelectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var defaultData = {\n    // The value the user has typed. We derive this also when the developer is\n    // controlling the value of ComboboxInput.\n    value: \"\",\n    // the value the user has navigated to with the keyboard\n    navigationValue: null\n  };\n\n  var _useReducerMachine = useReducerMachine(stateChart, reducer, defaultData),\n      state = _useReducerMachine[0],\n      data = _useReducerMachine[1],\n      transition = _useReducerMachine[2];\n\n  useFocusManagement(data.lastEventType, inputRef);\n  var id = (0,_reach_auto_id__WEBPACK_IMPORTED_MODULE_12__.useId)(props.id);\n  var listboxId = id ? (0,_reach_utils_make_id__WEBPACK_IMPORTED_MODULE_4__.makeId)(\"listbox\", id) : \"listbox\";\n  var isControlledRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var isExpanded = popoverIsExpanded(state);\n  var context = {\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    autocompletePropRef: autocompletePropRef,\n    buttonRef: buttonRef,\n    comboboxId: id,\n    data: data,\n    inputRef: inputRef,\n    isExpanded: isExpanded,\n    listboxId: listboxId,\n    onSelect: onSelect || _reach_utils_noop__WEBPACK_IMPORTED_MODULE_5__.noop,\n    openOnFocus: openOnFocus,\n    persistSelectionRef: persistSelectionRef,\n    popoverRef: popoverRef,\n    state: state,\n    transition: transition,\n    isControlledRef: isControlledRef\n  };\n  (0,_reach_utils_dev_utils__WEBPACK_IMPORTED_MODULE_6__.useCheckStyles)(\"combobox\");\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_reach_descendants__WEBPACK_IMPORTED_MODULE_11__.DescendantProvider, {\n    context: ComboboxDescendantContext,\n    items: options,\n    set: setOptions\n  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ComboboxContext.Provider, {\n    value: context\n  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({}, props, {\n    \"data-reach-combobox\": \"\",\n    \"data-state\": getDataState(state),\n    \"data-expanded\": isExpanded || undefined,\n    ref: forwardedRef\n  }), (0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isFunction)(children) ? children({\n    id: id,\n    isExpanded: isExpanded,\n    navigationValue: (_data$navigationValue = data.navigationValue) != null ? _data$navigationValue : null,\n    state: state\n  }) : children)));\n});\n/**\n * @see Docs https://reach.tech/combobox#combobox-props\n */\n\nif (true) {\n  Combobox.displayName = \"Combobox\";\n  Combobox.propTypes = {\n    as: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().any),\n    onSelect: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func),\n    openOnFocus: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxInput\n *\n * Wraps an `<input/>` with a couple extra props that work with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxinput\n */\n\n\nvar ComboboxInput = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref2, forwardedRef) {\n  var _ref2$as = _ref2.as,\n      Comp = _ref2$as === void 0 ? \"input\" : _ref2$as,\n      _ref2$selectOnClick = _ref2.selectOnClick,\n      selectOnClick = _ref2$selectOnClick === void 0 ? false : _ref2$selectOnClick,\n      _ref2$autocomplete = _ref2.autocomplete,\n      autocomplete = _ref2$autocomplete === void 0 ? true : _ref2$autocomplete,\n      onClick = _ref2.onClick,\n      onChange = _ref2.onChange,\n      onKeyDown = _ref2.onKeyDown,\n      onBlur = _ref2.onBlur,\n      onFocus = _ref2.onFocus,\n      controlledValue = _ref2.value,\n      props = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  // https://github.com/reach/reach-ui/issues/464\n  var _React$useRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(controlledValue),\n      initialControlledValue = _React$useRef.current;\n\n  var controlledValueChangedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,_reach_utils_use_update_effect__WEBPACK_IMPORTED_MODULE_8__.useUpdateEffect)(function () {\n    controlledValueChangedRef.current = true;\n  }, [controlledValue]);\n\n  var _React$useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      _React$useContext$dat = _React$useContext.data,\n      navigationValue = _React$useContext$dat.navigationValue,\n      value = _React$useContext$dat.value,\n      lastEventType = _React$useContext$dat.lastEventType,\n      inputRef = _React$useContext.inputRef,\n      state = _React$useContext.state,\n      transition = _React$useContext.transition,\n      listboxId = _React$useContext.listboxId,\n      autocompletePropRef = _React$useContext.autocompletePropRef,\n      openOnFocus = _React$useContext.openOnFocus,\n      isExpanded = _React$useContext.isExpanded,\n      ariaLabel = _React$useContext.ariaLabel,\n      ariaLabelledby = _React$useContext.ariaLabelledby,\n      persistSelectionRef = _React$useContext.persistSelectionRef,\n      isControlledRef = _React$useContext.isControlledRef;\n\n  var ref = (0,_reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(inputRef, forwardedRef); // Because we close the List on blur, we need to track if the blur is\n  // caused by clicking inside the list, and if so, don't close the List.\n\n  var selectOnClickRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var isControlled = typeof controlledValue !== \"undefined\";\n  var wasInitiallyControlled = typeof initialControlledValue !== \"undefined\";\n\n  if (true) {\n     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(!(!isControlled && wasInitiallyControlled), \"ComboboxInput is changing from controlled to uncontrolled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\") : 0;\n     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(!(isControlled && !wasInitiallyControlled), \"ComboboxInput is changing from uncontrolled to controlled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\") : 0;\n  }\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    isControlledRef.current = isControlled; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isControlled]); // Layout effect should be SSR-safe here because we don't actually do\n  // anything with this ref that involves rendering until after we've\n  // let the client hydrate in nested components.\n\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__.useIsomorphicLayoutEffect)(function () {\n    autocompletePropRef.current = autocomplete;\n  }, [autocomplete, autocompletePropRef]);\n  var handleValueChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (value) {\n    if (value.trim() === \"\") {\n      transition(CLEAR, {\n        isControlled: isControlled\n      });\n    } else if (value === initialControlledValue && !controlledValueChangedRef.current) {\n      transition(INITIAL_CHANGE, {\n        value: value\n      });\n    } else {\n      transition(CHANGE, {\n        value: value\n      });\n    }\n  }, [initialControlledValue, transition, isControlled]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    // If they are controlling the value we still need to do our transitions,\n    // so  we have this derived state to emulate onChange of the input as we\n    // receive new `value`s ...[*]\n    if (isControlled && controlledValue !== value && ( // https://github.com/reach/reach-ui/issues/481\n    controlledValue.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)) {\n      handleValueChange(controlledValue);\n    }\n  }, [controlledValue, handleValueChange, isControlled, value]); // [*]... and when controlled, we don't trigger handleValueChange as the\n  // user types, instead the developer controls it with the normal input\n  // onChange prop\n\n  function handleChange(event) {\n    var value = event.target.value;\n\n    if (!isControlled) {\n      handleValueChange(value);\n    }\n  }\n\n  function handleFocus() {\n    if (selectOnClick) {\n      selectOnClickRef.current = true;\n    } // If we select an option with click, useFocusManagement will focus the\n    // input, in those cases we don't want to cause the menu to open back up,\n    // so we guard behind these states.\n\n\n    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n      transition(FOCUS, {\n        persistSelection: persistSelectionRef.current\n      });\n    }\n  }\n\n  function handleClick() {\n    if (selectOnClickRef.current) {\n      var _inputRef$current;\n\n      selectOnClickRef.current = false;\n      (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.select();\n    }\n\n    if (openOnFocus && state === IDLE) {\n      transition(OPEN_WITH_INPUT_CLICK);\n    }\n  }\n\n  var inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? // When idle, we don't have a navigationValue on ArrowUp/Down\n  navigationValue || controlledValue || value : controlledValue || value;\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    \"aria-activedescendant\": navigationValue ? String(makeHash(navigationValue)) : undefined,\n    \"aria-autocomplete\": \"both\",\n    \"aria-controls\": listboxId,\n    \"aria-expanded\": isExpanded,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledby,\n    role: \"combobox\"\n  }, props, {\n    \"data-reach-combobox-input\": \"\",\n    \"data-state\": getDataState(state),\n    ref: ref,\n    onBlur: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onBlur, handleBlur),\n    onChange: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onChange, handleChange),\n    onClick: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onClick, handleClick),\n    onFocus: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onFocus, handleFocus),\n    onKeyDown: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onKeyDown, handleKeyDown),\n    value: inputValue || \"\"\n  }));\n});\n/**\n * @see Docs https://reach.tech/combobox#comboboxinput-props\n */\n\nif (true) {\n  ComboboxInput.displayName = \"ComboboxInput\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxPopover\n *\n * Contains the popup that renders the list. Because some UI needs to render\n * more than the list in the popup, you need to render one of these around the\n * list. For example, maybe you want to render the number of results suggested.\n *\n * @see Docs https://reach.tech/combobox#comboboxpopover\n */\n\n\nvar ComboboxPopover = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref3, forwardedRef) {\n  var _ref3$as = _ref3.as,\n      Comp = _ref3$as === void 0 ? \"div\" : _ref3$as,\n      children = _ref3.children,\n      _ref3$portal = _ref3.portal,\n      portal = _ref3$portal === void 0 ? true : _ref3$portal,\n      onKeyDown = _ref3.onKeyDown,\n      onBlur = _ref3.onBlur,\n      _ref3$position = _ref3.position,\n      position = _ref3$position === void 0 ? _reach_popover__WEBPACK_IMPORTED_MODULE_15__.positionMatchWidth : _ref3$position,\n      props = _objectWithoutPropertiesLoose(_ref3, _excluded3);\n\n  var _React$useContext2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      popoverRef = _React$useContext2.popoverRef,\n      inputRef = _React$useContext2.inputRef,\n      isExpanded = _React$useContext2.isExpanded,\n      state = _React$useContext2.state;\n\n  var ref = (0,_reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(popoverRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var sharedProps = {\n    \"data-reach-combobox-popover\": \"\",\n    \"data-state\": getDataState(state),\n    onKeyDown: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onKeyDown, handleKeyDown),\n    onBlur: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onBlur, handleBlur),\n    // Instead of conditionally rendering the popover we use the `hidden` prop\n    // because we don't want to unmount on close (from escape or onSelect).\n    // However, the developer can conditionally render the ComboboxPopover if\n    // they do want to cause mount/unmount based on the app's own data (like\n    // results.length or whatever).\n    hidden: !isExpanded,\n    tabIndex: -1,\n    children: children\n  };\n  return portal ? /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_reach_popover__WEBPACK_IMPORTED_MODULE_15__.Popover, _extends({\n    as: Comp\n  }, props, {\n    ref: ref,\n    \"data-expanded\": isExpanded || undefined,\n    position: position,\n    targetRef: inputRef\n  }, sharedProps)) : /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    ref: ref\n  }, props, sharedProps));\n});\n\nif (true) {\n  ComboboxPopover.displayName = \"ComboboxPopover\";\n}\n/**\n * @see Docs https://reach.tech/combobox#comboboxpopover-props\n */\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxList\n *\n * Contains the `ComboboxOption` elements and sets up the proper aria attributes\n * for the list.\n *\n * @see Docs https://reach.tech/combobox#comboboxlist\n */\nvar ComboboxList = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref4, forwardedRef) {\n  var _ref4$persistSelectio = _ref4.persistSelection,\n      persistSelection = _ref4$persistSelectio === void 0 ? false : _ref4$persistSelectio,\n      _ref4$as = _ref4.as,\n      Comp = _ref4$as === void 0 ? \"ul\" : _ref4$as,\n      props = _objectWithoutPropertiesLoose(_ref4, _excluded4);\n\n  var _React$useContext3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      persistSelectionRef = _React$useContext3.persistSelectionRef,\n      listboxId = _React$useContext3.listboxId;\n\n  if (persistSelection) {\n    persistSelectionRef.current = true;\n  }\n\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    role: \"listbox\"\n  }, props, {\n    ref: forwardedRef,\n    \"data-reach-combobox-list\": \"\",\n    id: listboxId\n  }));\n});\n/**\n * @see Docs https://reach.tech/combobox#comboboxlist-props\n */\n\nif (true) {\n  ComboboxList.displayName = \"ComboboxList\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOption\n *\n * An option that is suggested to the user as they interact with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxoption\n */\n\n\nvar ComboboxOption = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref5, forwardedRef) {\n  var _ref5$as = _ref5.as,\n      Comp = _ref5$as === void 0 ? \"li\" : _ref5$as,\n      children = _ref5.children,\n      indexProp = _ref5.index,\n      value = _ref5.value,\n      onClick = _ref5.onClick,\n      props = _objectWithoutPropertiesLoose(_ref5, _excluded5);\n\n  var _React$useContext4 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      onSelect = _React$useContext4.onSelect,\n      navigationValue = _React$useContext4.data.navigationValue,\n      transition = _React$useContext4.transition,\n      isControlledRef = _React$useContext4.isControlledRef;\n\n  var ownRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n\n  var _useStatefulRefValue = (0,_reach_utils_use_stateful_ref_value__WEBPACK_IMPORTED_MODULE_9__.useStatefulRefValue)(ownRef, null),\n      element = _useStatefulRefValue[0],\n      handleRefSet = _useStatefulRefValue[1];\n\n  var descendant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return {\n      element: element,\n      value: value\n    };\n  }, [value, element]);\n  var index = (0,_reach_descendants__WEBPACK_IMPORTED_MODULE_11__.useDescendant)(descendant, ComboboxDescendantContext, indexProp);\n  var ref = (0,_reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, handleRefSet);\n  var isActive = navigationValue === value;\n\n  var handleClick = function handleClick() {\n    onSelect && onSelect(value);\n    transition(SELECT_WITH_CLICK, {\n      value: value,\n      isControlled: isControlledRef.current\n    });\n  };\n\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(OptionContext.Provider, {\n    value: {\n      value: value,\n      index: index\n    }\n  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    \"aria-selected\": isActive,\n    role: \"option\"\n  }, props, {\n    \"data-reach-combobox-option\": \"\",\n    ref: ref,\n    id: String(makeHash(value)),\n    \"data-highlighted\": isActive ? \"\" : undefined // Without this the menu will close from `onBlur`, but with it the\n    // element can be `document.activeElement` and then our focus checks in\n    // onBlur will work as intended\n    ,\n    tabIndex: -1,\n    onClick: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onClick, handleClick)\n  }), children ? (0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isFunction)(children) ? children({\n    value: value,\n    index: index\n  }) : children : /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ComboboxOptionText, null)));\n});\n/**\n * @see Docs https://reach.tech/combobox#comboboxoption-props\n */\n\nif (true) {\n  ComboboxOption.displayName = \"ComboboxOption\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOptionText\n *\n * Renders the value of a `ComboboxOption` as text but with spans wrapping the\n * matching and non-matching segments of text.\n *\n * We don't forwardRef or spread props because we render multiple spans or null,\n * should be fine ðŸ¤™\n *\n * @example\n *   <ComboboxOption value=\"Seattle\">\n *     ðŸŒ§ <ComboboxOptionText />\n *   </ComboboxOption>\n *\n * @see Docs https://reach.tech/combobox#comboboxoptiontext\n */\n\n\nfunction ComboboxOptionText() {\n  var _React$useContext5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OptionContext),\n      value = _React$useContext5.value;\n\n  var _React$useContext6 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      contextValue = _React$useContext6.data.value;\n\n  var results = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return HighlightWords.findAll({\n      searchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n      textToHighlight: value\n    });\n  }, [contextValue, value]);\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, results.length ? results.map(function (result, index) {\n    var str = value.slice(result.start, result.end);\n    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n      key: index,\n      \"data-reach-combobox-option-text\": \"\",\n      \"data-user-value\": result.highlight ? true : undefined,\n      \"data-suggested-value\": result.highlight ? undefined : true\n    }, str);\n  }) : value);\n}\n\nif (true) {\n  ComboboxOptionText.displayName = \"ComboboxOptionText\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxButton\n */\n\n\nvar ComboboxButton = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref6, forwardedRef) {\n  var _ref6$as = _ref6.as,\n      Comp = _ref6$as === void 0 ? \"button\" : _ref6$as,\n      onClick = _ref6.onClick,\n      onKeyDown = _ref6.onKeyDown,\n      props = _objectWithoutPropertiesLoose(_ref6, _excluded6);\n\n  var _React$useContext7 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      transition = _React$useContext7.transition,\n      state = _React$useContext7.state,\n      buttonRef = _React$useContext7.buttonRef,\n      listboxId = _React$useContext7.listboxId,\n      isExpanded = _React$useContext7.isExpanded;\n\n  var ref = (0,_reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(buttonRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n\n  var handleClick = function handleClick() {\n    if (state === IDLE) {\n      transition(OPEN_WITH_BUTTON);\n    } else {\n      transition(CLOSE_WITH_BUTTON);\n    }\n  };\n\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    \"aria-controls\": listboxId,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-expanded\": isExpanded\n  }, props, {\n    \"data-reach-combobox-button\": \"\",\n    ref: ref,\n    onClick: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onClick, handleClick),\n    onKeyDown: (0,_reach_utils_compose_event_handlers__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(onKeyDown, handleKeyDown)\n  }));\n});\n\nif (true) {\n  ComboboxButton.displayName = \"ComboboxButton\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Move focus back to the input if we start navigating w/ the\n * keyboard after focus has moved to any focusable content in\n * the popup.\n *\n * @param lastEventType\n * @param inputRef\n */\n\n\nfunction useFocusManagement(lastEventType, inputRef) {\n  // useLayoutEffect so that the cursor goes to the end of the input instead\n  // of awkwardly at the beginning, unclear to me why ðŸ¤·â€â™‚ï¸\n  //\n  // Should be safe to use here since we're just focusing an input.\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__.useIsomorphicLayoutEffect)(function () {\n    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {\n      var _inputRef$current2;\n\n      (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.focus();\n    }\n  }, [inputRef, lastEventType]);\n}\n/**\n * We want the same events when the input or the popup have focus (HOW COOL ARE\n * HOOKS BTW?) This is probably the hairiest piece but it's not bad.\n */\n\n\nfunction useKeyDown() {\n  var _React$useContext8 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      navigationValue = _React$useContext8.data.navigationValue,\n      onSelect = _React$useContext8.onSelect,\n      state = _React$useContext8.state,\n      transition = _React$useContext8.transition,\n      autocompletePropRef = _React$useContext8.autocompletePropRef,\n      persistSelectionRef = _React$useContext8.persistSelectionRef,\n      isControlledRef = _React$useContext8.isControlledRef;\n\n  var options = (0,_reach_descendants__WEBPACK_IMPORTED_MODULE_11__.useDescendants)(ComboboxDescendantContext);\n  return function handleKeyDown(event) {\n    var index = options.findIndex(function (_ref7) {\n      var value = _ref7.value;\n      return value === navigationValue;\n    });\n\n    function getNextOption() {\n      var atBottom = index === options.length - 1;\n\n      if (atBottom) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getFirstOption();\n        }\n      } else {\n        // Go to the next item in the list\n        return options[(index + 1) % options.length];\n      }\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n\n      if (atTop) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getLastOption();\n        }\n      } else if (index === -1) {\n        // displaying the user's value, so go select the last one\n        return getLastOption();\n      } else {\n        // normal case, select previous\n        return options[(index - 1 + options.length) % options.length];\n      }\n    }\n\n    function getFirstOption() {\n      return options[0];\n    }\n\n    function getLastOption() {\n      return options[options.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || !options.length) {\n          return;\n        }\n\n        if (state === IDLE) {\n          // Opening a closed list\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current\n          });\n        } else {\n          var next = getNextOption();\n          transition(NAVIGATE, {\n            value: next ? next.value : null\n          });\n        }\n\n        break;\n      // A lot of duplicate code with ArrowDown up next, I'm already over it.\n\n      case \"ArrowUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          var prev = getPreviousOption();\n          transition(NAVIGATE, {\n            value: prev ? prev.value : null\n          });\n        }\n\n        break;\n\n      case \"Home\":\n      case \"PageUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getFirstOption().value\n          });\n        }\n\n        break;\n\n      case \"End\":\n      case \"PageDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getLastOption().value\n          });\n        }\n\n        break;\n\n      case \"Escape\":\n        if (state !== IDLE) {\n          transition(ESCAPE);\n        }\n\n        break;\n\n      case \"Enter\":\n        if (state === NAVIGATING && navigationValue !== null) {\n          // don't want to submit forms\n          event.preventDefault();\n          onSelect && onSelect(navigationValue);\n          transition(SELECT_WITH_KEYBOARD, {\n            isControlled: isControlledRef.current\n          });\n        }\n\n        break;\n    }\n  };\n}\n\nfunction useBlur() {\n  var _React$useContext9 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      state = _React$useContext9.state,\n      transition = _React$useContext9.transition,\n      popoverRef = _React$useContext9.popoverRef,\n      inputRef = _React$useContext9.inputRef,\n      buttonRef = _React$useContext9.buttonRef;\n\n  return function handleBlur(event) {\n    var popover = popoverRef.current;\n    var input = inputRef.current;\n    var button = buttonRef.current;\n    var activeElement = event.relatedTarget; // we on want to close only if focus propss outside the combobox\n\n    if (activeElement !== input && activeElement !== button && popover) {\n      if (popover.contains(activeElement)) {\n        // focus landed inside the combobox, keep it open\n        if (state !== INTERACTING) {\n          transition(INTERACT);\n        }\n      } else {\n        // focus landed outside the combobox, close it.\n        transition(BLUR);\n      }\n    }\n  };\n}\n/**\n * This manages transitions between states with a built in reducer to manage\n * the data that goes with those transitions.\n *\n * @param chart\n * @param reducer\n * @param initialData\n */\n\n\nfunction useReducerMachine(chart, reducer, initialData) {\n  var _React$useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(chart.initial),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var _React$useReducer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, initialData),\n      data = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var transition = function transition(event, payload) {\n    if (payload === void 0) {\n      payload = {};\n    }\n\n    var currentState = chart.states[state];\n    var nextState = currentState && currentState.on[event];\n\n    if (nextState) {\n      dispatch(_extends({\n        type: event,\n        state: state,\n        nextState: state\n      }, payload));\n      setState(nextState);\n      return;\n    }\n  };\n\n  return [state, data, transition];\n}\n/**\n * We don't want to track the active descendant with indexes because nothing is\n * more annoying in a combobox than having it change values RIGHT AS YOU HIT\n * ENTER. That only happens if you use the index as your data, rather than\n * *your data as your data*. We use this to generate a unique ID based on the\n * value of each item.  This function is short, sweet, and good enoughâ„¢ (I also\n * don't know how it works, tbqh)\n *\n * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\n * @param str\n */\n\n\nfunction makeHash(str) {\n  var hash = 0;\n\n  if (str.length === 0) {\n    return hash;\n  }\n\n  for (var i = 0; i < str.length; i++) {\n    var _char = str.charCodeAt(i);\n\n    hash = (hash << 5) - hash + _char;\n    hash = hash & hash;\n  }\n\n  return hash;\n} // function getActiveElement(node: Element | null | undefined) {\n//   let activeElement: Element | null = null;\n//   try {\n//     // If Element.getRootNode is supported, we'll retrieve either the root\n//     // Document or shadow root depending on where the component is rendered.\n//     // https://github.com/reach/reach-ui/issues/787\n//     activeElement = (node?.getRootNode() as ShadowRoot | Document)\n//       .activeElement;\n//   } finally {\n//     return activeElement || (node?.ownerDocument || document).activeElement;\n//   }\n// }\n\n\nfunction getDataState(state) {\n  return state.toLowerCase();\n}\n/**\n * Escape regexp special characters in `str`\n *\n * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js\n * @param str\n */\n\n\nfunction escapeRegexp(str) {\n  return String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n} //////////////////////////\n//////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Combobox` component to its descendants.\n *\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\n */\n\nfunction useComboboxContext() {\n  var _React$useContext10 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComboboxContext),\n      isExpanded = _React$useContext10.isExpanded,\n      comboboxId = _React$useContext10.comboboxId,\n      data = _React$useContext10.data,\n      state = _React$useContext10.state;\n\n  var navigationValue = data.navigationValue;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return {\n      id: comboboxId,\n      isExpanded: isExpanded,\n      navigationValue: navigationValue != null ? navigationValue : null,\n      state: state\n    };\n  }, [comboboxId, isExpanded, navigationValue, state]);\n}\n/**\n * A hook that exposes data for a given `ComboboxOption` component to its descendants.\n *\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\n */\n\nfunction useComboboxOptionContext() {\n  var _React$useContext11 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OptionContext),\n      value = _React$useContext11.value,\n      index = _React$useContext11.index;\n\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return {\n      value: value,\n      index: index\n    };\n  }, [value, index]);\n} ////////////////////////////////////////////////////////////////////////////////\n// Well alright, you made it all the way here to like 1100 lines of code (geez,\n// what the heck?). Have a great day :D\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL2NvbWJvYm94L2Rpc3QvcmVhY2gtY29tYm9ib3guZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVJO0FBQ3BHO0FBQ21EO0FBQzVCO0FBQ0w7QUFDUDtBQUNMO0FBQ2U7QUFDSTtBQUNLO0FBQ1M7QUFDQztBQUN5RDtBQUM3RjtBQUNzQjtBQUMxQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNB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L0ByZWFjaC9jb21ib2JveC9kaXN0L3JlYWNoLWNvbWJvYm94LmVzbS5qcz8zZjgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgRnJhZ21lbnQsIHVzZVN0YXRlLCB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICdAcmVhY2gvdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBjcmVhdGVOYW1lZENvbnRleHQgfSBmcm9tICdAcmVhY2gvdXRpbHMvY29udGV4dCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnQHJlYWNoL3V0aWxzL3R5cGUtY2hlY2snO1xuaW1wb3J0IHsgbWFrZUlkIH0gZnJvbSAnQHJlYWNoL3V0aWxzL21ha2UtaWQnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ0ByZWFjaC91dGlscy9ub29wJztcbmltcG9ydCB7IHVzZUNoZWNrU3R5bGVzIH0gZnJvbSAnQHJlYWNoL3V0aWxzL2Rldi11dGlscyc7XG5pbXBvcnQgeyB1c2VDb21wb3NlZFJlZnMgfSBmcm9tICdAcmVhY2gvdXRpbHMvY29tcG9zZS1yZWZzJztcbmltcG9ydCB7IHVzZVVwZGF0ZUVmZmVjdCB9IGZyb20gJ0ByZWFjaC91dGlscy91c2UtdXBkYXRlLWVmZmVjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZWZ1bFJlZlZhbHVlIH0gZnJvbSAnQHJlYWNoL3V0aWxzL3VzZS1zdGF0ZWZ1bC1yZWYtdmFsdWUnO1xuaW1wb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfSBmcm9tICdAcmVhY2gvdXRpbHMvY29tcG9zZS1ldmVudC1oYW5kbGVycyc7XG5pbXBvcnQgeyBjcmVhdGVEZXNjZW5kYW50Q29udGV4dCwgdXNlRGVzY2VuZGFudHNJbml0LCBEZXNjZW5kYW50UHJvdmlkZXIsIHVzZURlc2NlbmRhbnQsIHVzZURlc2NlbmRhbnRzIH0gZnJvbSAnQHJlYWNoL2Rlc2NlbmRhbnRzJztcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSAnQHJlYWNoL2F1dG8taWQnO1xuaW1wb3J0IHsgUG9wb3ZlciwgcG9zaXRpb25NYXRjaFdpZHRoIH0gZnJvbSAnQHJlYWNoL3BvcG92ZXInO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL2hpZ2hsaWdodC13b3Jkcy1jb3JlXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBjaHVuayBvYmplY3RzIHJlcHJlc2VudGluZyBib3RoIGhpZ2xpZ2h0YWJsZSBhbmQgbm9uXG4gKiBoaWdobGlnaHRhYmxlIHBpZWNlcyBvZiB0ZXh0IHRoYXQgbWF0Y2ggZWFjaCBzZWFyY2ggd29yZC5cbiAqXG4gKiBAcmV0dXJuIEFycmF5IG9mIFwiY2h1bmtcIiBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGZpbmRBbGwoX3JlZikge1xuICB2YXIgYXV0b0VzY2FwZSA9IF9yZWYuYXV0b0VzY2FwZSxcbiAgICAgIF9yZWYkY2FzZVNlbnNpdGl2ZSA9IF9yZWYuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBfcmVmJGNhc2VTZW5zaXRpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRjYXNlU2Vuc2l0aXZlLFxuICAgICAgX3JlZiRmaW5kQ2h1bmtzID0gX3JlZi5maW5kQ2h1bmtzLFxuICAgICAgZmluZENodW5rcyA9IF9yZWYkZmluZENodW5rcyA9PT0gdm9pZCAwID8gZGVmYXVsdEZpbmRDaHVua3MgOiBfcmVmJGZpbmRDaHVua3MsXG4gICAgICBzYW5pdGl6ZSA9IF9yZWYuc2FuaXRpemUsXG4gICAgICBzZWFyY2hXb3JkcyA9IF9yZWYuc2VhcmNoV29yZHMsXG4gICAgICB0ZXh0VG9IaWdobGlnaHQgPSBfcmVmLnRleHRUb0hpZ2hsaWdodDtcbiAgcmV0dXJuIGZpbGxJbkNodW5rcyh7XG4gICAgY2h1bmtzVG9IaWdobGlnaHQ6IGNvbWJpbmVDaHVua3Moe1xuICAgICAgY2h1bmtzOiBmaW5kQ2h1bmtzKHtcbiAgICAgICAgYXV0b0VzY2FwZTogYXV0b0VzY2FwZSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgc2FuaXRpemU6IHNhbml0aXplLFxuICAgICAgICBzZWFyY2hXb3Jkczogc2VhcmNoV29yZHMsXG4gICAgICAgIHRleHRUb0hpZ2hsaWdodDogdGV4dFRvSGlnaGxpZ2h0XG4gICAgICB9KVxuICAgIH0pLFxuICAgIHRvdGFsTGVuZ3RoOiB0ZXh0VG9IaWdobGlnaHQgPyB0ZXh0VG9IaWdobGlnaHQubGVuZ3RoIDogMFxuICB9KTtcbn1cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgXCJjaHVua1wiIG9iamVjdHMgYW5kIGNvbWJpbmVzIGNodW5rcyB0aGF0IG92ZXJsYXAgaW50b1xuICogc2luZ2xlIGNodW5rcy5cbiAqXG4gKiBAcmV0dXJuIEFycmF5IG9mIFwiY2h1bmtcIiBvYmplY3RzXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lQ2h1bmtzKF9yZWYyKSB7XG4gIHZhciBjaHVua3MgPSBfcmVmMi5jaHVua3M7XG4gIHJldHVybiBjaHVua3Muc29ydChmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiBmaXJzdC5zdGFydCAtIHNlY29uZC5zdGFydDtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChwcm9jZXNzZWRDaHVua3MsIG5leHRDaHVuaykge1xuICAgIC8vIEZpcnN0IGNodW5rIGp1c3QgZ29lcyBzdHJhaWdodCBpbiB0aGUgYXJyYXkuLi5cbiAgICBpZiAocHJvY2Vzc2VkQ2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtuZXh0Q2h1bmtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAuLi4gc3Vic2VxdWVudCBjaHVua3MgZ2V0IGNoZWNrZWQgdG8gc2VlIGlmIHRoZXkgb3ZlcmxhcC4uLlxuICAgICAgdmFyIHByZXZDaHVuayA9IHByb2Nlc3NlZENodW5rcy5wb3AoKTtcblxuICAgICAgaWYgKG5leHRDaHVuay5zdGFydCA8PSBwcmV2Q2h1bmsuZW5kKSB7XG4gICAgICAgIC8vIEl0IG1heSBiZSB0aGUgY2FzZSB0aGF0IHByZXZDaHVuayBjb21wbGV0ZWx5IHN1cnJvdW5kcyBuZXh0Q2h1bmssIHNvIHRha2UgdGhlXG4gICAgICAgIC8vIGxhcmdlc3Qgb2YgdGhlIGVuZCBpbmRlY2VzLlxuICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1heChwcmV2Q2h1bmsuZW5kLCBuZXh0Q2h1bmsuZW5kKTtcbiAgICAgICAgcHJvY2Vzc2VkQ2h1bmtzLnB1c2goe1xuICAgICAgICAgIGhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgc3RhcnQ6IHByZXZDaHVuay5zdGFydCxcbiAgICAgICAgICBlbmQ6IGVuZEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkQ2h1bmtzLnB1c2gocHJldkNodW5rLCBuZXh0Q2h1bmspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc2VkQ2h1bmtzO1xuICAgIH1cbiAgfSwgW10pO1xufVxuLyoqXG4gKiBFeGFtaW5lIHRleHQgZm9yIGFueSBtYXRjaGVzLiBJZiB3ZSBmaW5kIG1hdGNoZXMsIGFkZCB0aGVtIHRvIHRoZSByZXR1cm5lZFxuICogYXJyYXkgYXMgYSBcImNodW5rXCIgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gQXJyYXkgb2YgXCJjaHVua1wiIG9iamVjdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZmF1bHRGaW5kQ2h1bmtzKF9yZWYzKSB7XG4gIHZhciBhdXRvRXNjYXBlID0gX3JlZjMuYXV0b0VzY2FwZSxcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBfcmVmMy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgX3JlZjMkc2FuaXRpemUgPSBfcmVmMy5zYW5pdGl6ZSxcbiAgICAgIHNhbml0aXplID0gX3JlZjMkc2FuaXRpemUgPT09IHZvaWQgMCA/IGRlZmF1bHRTYW5pdGl6ZSA6IF9yZWYzJHNhbml0aXplLFxuICAgICAgc2VhcmNoV29yZHMgPSBfcmVmMy5zZWFyY2hXb3JkcyxcbiAgICAgIHRleHRUb0hpZ2hsaWdodCA9IF9yZWYzLnRleHRUb0hpZ2hsaWdodDtcbiAgdGV4dFRvSGlnaGxpZ2h0ID0gc2FuaXRpemUodGV4dFRvSGlnaGxpZ2h0IHx8IFwiXCIpO1xuICByZXR1cm4gc2VhcmNoV29yZHMuZmlsdGVyKGZ1bmN0aW9uIChzZWFyY2hXb3JkKSB7XG4gICAgcmV0dXJuIHNlYXJjaFdvcmQ7XG4gIH0pIC8vIFJlbW92ZSBlbXB0eSB3b3Jkc1xuICAucmVkdWNlKGZ1bmN0aW9uIChjaHVua3MsIHNlYXJjaFdvcmQpIHtcbiAgICBzZWFyY2hXb3JkID0gc2FuaXRpemUoc2VhcmNoV29yZCk7XG5cbiAgICBpZiAoYXV0b0VzY2FwZSkge1xuICAgICAgc2VhcmNoV29yZCA9IGVzY2FwZVJlZ0V4cEZuKHNlYXJjaFdvcmQpO1xuICAgIH1cblxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoV29yZCwgY2FzZVNlbnNpdGl2ZSA/IFwiZ1wiIDogXCJnaVwiKTtcbiAgICB2YXIgbWF0Y2g7XG5cbiAgICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKHRleHRUb0hpZ2hsaWdodCB8fCBcIlwiKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gbWF0Y2guaW5kZXg7XG4gICAgICB2YXIgZW5kID0gcmVnZXgubGFzdEluZGV4OyAvLyBXZSBkbyBub3QgcmV0dXJuIHplcm8tbGVuZ3RoIG1hdGNoZXNcblxuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgICBoaWdobGlnaHQ6IGZhbHNlLFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUHJldmVudCBicm93c2VycyBsaWtlIEZpcmVmb3ggZnJvbSBnZXR0aW5nIHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnJlZ2V4Z3VydS5jb20vMjAwOC8wNC93YXRjaC1vdXQtZm9yLXplcm8tbGVuZ3RoLW1hdGNoZXMvXG5cblxuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgcmVnZXgubGFzdEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNodW5rcztcbiAgfSwgW10pO1xufVxuLyoqXG4gKiBHaXZlbiBhIHNldCBvZiBjaHVua3MgdG8gaGlnaGxpZ2h0LCBjcmVhdGUgYW4gYWRkaXRpb25hbCBzZXQgb2YgY2h1bmtzXG4gKiB0byByZXByZXNlbnQgdGhlIGJpdHMgb2YgdGV4dCBiZXR3ZWVuIHRoZSBoaWdobGlnaHRlZCB0ZXh0LlxuICpcbiAqIEByZXR1cm4gQXJyYXkgb2YgXCJjaHVua1wiIG9iamVjdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbGxJbkNodW5rcyhfcmVmNCkge1xuICB2YXIgY2h1bmtzVG9IaWdobGlnaHQgPSBfcmVmNC5jaHVua3NUb0hpZ2hsaWdodCxcbiAgICAgIHRvdGFsTGVuZ3RoID0gX3JlZjQudG90YWxMZW5ndGg7XG4gIHZhciBhbGxDaHVua3MgPSBbXTtcblxuICBpZiAoY2h1bmtzVG9IaWdobGlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgYXBwZW5kKDAsIHRvdGFsTGVuZ3RoLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgY2h1bmtzVG9IaWdobGlnaHQuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGFwcGVuZChsYXN0SW5kZXgsIGNodW5rLnN0YXJ0LCBmYWxzZSk7XG4gICAgICBhcHBlbmQoY2h1bmsuc3RhcnQsIGNodW5rLmVuZCwgdHJ1ZSk7XG4gICAgICBsYXN0SW5kZXggPSBjaHVuay5lbmQ7XG4gICAgfSk7XG4gICAgYXBwZW5kKGxhc3RJbmRleCwgdG90YWxMZW5ndGgsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBhbGxDaHVua3M7XG5cbiAgZnVuY3Rpb24gYXBwZW5kKHN0YXJ0LCBlbmQsIGhpZ2hsaWdodCkge1xuICAgIGlmIChlbmQgLSBzdGFydCA+IDApIHtcbiAgICAgIGFsbENodW5rcy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgaGlnaGxpZ2h0OiBoaWdobGlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2FuaXRpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cEZuKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stW1xcXS97fSgpKis/LlxcXFxeJHxdL2csIFwiXFxcXCQmXCIpO1xufVxuXG52YXIgSGlnaGxpZ2h0V29yZHMgPSB7XG4gIGNvbWJpbmVDaHVua3M6IGNvbWJpbmVDaHVua3MsXG4gIGZpbGxJbkNodW5rczogZmlsbEluQ2h1bmtzLFxuICBmaW5kQWxsOiBmaW5kQWxsLFxuICBmaW5kQ2h1bmtzOiBkZWZhdWx0RmluZENodW5rc1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcIm9uU2VsZWN0XCIsIFwib3Blbk9uRm9jdXNcIiwgXCJjaGlsZHJlblwiLCBcImFzXCIsIFwiYXJpYS1sYWJlbFwiLCBcImFyaWEtbGFiZWxsZWRieVwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1wiYXNcIiwgXCJzZWxlY3RPbkNsaWNrXCIsIFwiYXV0b2NvbXBsZXRlXCIsIFwib25DbGlja1wiLCBcIm9uQ2hhbmdlXCIsIFwib25LZXlEb3duXCIsIFwib25CbHVyXCIsIFwib25Gb2N1c1wiLCBcInZhbHVlXCJdLFxuICAgIF9leGNsdWRlZDMgPSBbXCJhc1wiLCBcImNoaWxkcmVuXCIsIFwicG9ydGFsXCIsIFwib25LZXlEb3duXCIsIFwib25CbHVyXCIsIFwicG9zaXRpb25cIl0sXG4gICAgX2V4Y2x1ZGVkNCA9IFtcInBlcnNpc3RTZWxlY3Rpb25cIiwgXCJhc1wiXSxcbiAgICBfZXhjbHVkZWQ1ID0gW1wiYXNcIiwgXCJjaGlsZHJlblwiLCBcImluZGV4XCIsIFwidmFsdWVcIiwgXCJvbkNsaWNrXCJdLFxuICAgIF9leGNsdWRlZDYgPSBbXCJhc1wiLCBcIm9uQ2xpY2tcIiwgXCJvbktleURvd25cIl07XG5cbnZhciBfb24sIF9vbjIsIF9vbjMsIF9vbjQsIF9zdGF0ZXM7XG4vLyBTdGF0ZXNcbi8vIE5vdGhpbmcgZ29pbmcgb24sIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIHR5cGUgb3IgdXNlIHRoZSBhcnJvdyBrZXlzXG5cbnZhciBJRExFID0gXCJJRExFXCI7IC8vIFRoZSBjb21wb25lbnQgaXMgc3VnZ2VzdGluZyBvcHRpb25zIGFzIHRoZSB1c2VyIHR5cGVzXG5cbnZhciBTVUdHRVNUSU5HID0gXCJTVUdHRVNUSU5HXCI7IC8vIFRoZSB1c2VyIGlzIHVzaW5nIHRoZSBrZXlib2FyZCB0byBuYXZpZ2F0ZSB0aGUgbGlzdCwgbm90IHR5cGluZ1xuXG52YXIgTkFWSUdBVElORyA9IFwiTkFWSUdBVElOR1wiOyAvLyBUaGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIGFyYml0cmFyeSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcHVwIHRoYXRcbi8vIGFyZSBub3QgQ29tYm9ib3hJbnB1dHNcblxudmFyIElOVEVSQUNUSU5HID0gXCJJTlRFUkFDVElOR1wiOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXZlbnRzXG4vLyBVc2VyIGNsZWFyZWQgdGhlIHZhbHVlIHcvIGJhY2tzcGFjZSwgYnV0IGlucHV0IHN0aWxsIGhhcyBmb2N1c1xuXG52YXIgQ0xFQVIgPSBcIkNMRUFSXCI7IC8vIFVzZXIgaXMgdHlwaW5nXG5cbnZhciBDSEFOR0UgPSBcIkNIQU5HRVwiOyAvLyBJbml0aWFsIGlucHV0IHZhbHVlIGNoYW5nZSBoYW5kbGVyIGZvciBzeW5jaW5nIHVzZXIgc3RhdGUgd2l0aCBzdGF0ZSBtYWNoaW5lXG4vLyBQcmV2ZW50cyBpbml0aWFsIGNoYW5nZSBmcm9tIHNlbmRpbmcgdGhlIHVzZXIgdG8gdGhlIE5BVklHQVRJTkcgc3RhdGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yZWFjaC11aS9pc3N1ZXMvNDY0XG5cbnZhciBJTklUSUFMX0NIQU5HRSA9IFwiSU5JVElBTF9DSEFOR0VcIjsgLy8gVXNlciBpcyBuYXZpZ2F0aW5nIHcvIHRoZSBrZXlib2FyZFxuXG52YXIgTkFWSUdBVEUgPSBcIk5BVklHQVRFXCI7IC8vIFVzZXIgY2FuIGJlIG5hdmlnYXRpbmcgd2l0aCBrZXlib2FyZCBhbmQgdGhlbiBjbGljayBpbnN0ZWFkLCB3ZSB3YW50IHRoZVxuLy8gdmFsdWUgZnJvbSB0aGUgY2xpY2ssIG5vdCB0aGUgY3VycmVudCBuYXYgaXRlbVxuXG52YXIgU0VMRUNUX1dJVEhfS0VZQk9BUkQgPSBcIlNFTEVDVF9XSVRIX0tFWUJPQVJEXCI7XG52YXIgU0VMRUNUX1dJVEhfQ0xJQ0sgPSBcIlNFTEVDVF9XSVRIX0NMSUNLXCI7IC8vIFByZXR0eSBzZWxmLWV4cGxhbmF0b3J5LCB1c2VyIGNhbiBoaXQgZXNjYXBlIG9yIGJsdXIgdG8gY2xvc2UgdGhlIHBvcG92ZXJcblxudmFyIEVTQ0FQRSA9IFwiRVNDQVBFXCI7XG52YXIgQkxVUiA9IFwiQkxVUlwiOyAvLyBUaGUgdXNlciBsZWZ0IHRoZSBpbnB1dCB0byBpbnRlcmFjdCB3aXRoIGFyYml0cmFyeSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcHVwXG5cbnZhciBJTlRFUkFDVCA9IFwiSU5URVJBQ1RcIjtcbnZhciBGT0NVUyA9IFwiRk9DVVNcIjtcbnZhciBPUEVOX1dJVEhfQlVUVE9OID0gXCJPUEVOX1dJVEhfQlVUVE9OXCI7XG52YXIgT1BFTl9XSVRIX0lOUFVUX0NMSUNLID0gXCJPUEVOX1dJVEhfSU5QVVRfQ0xJQ0tcIjtcbnZhciBDTE9TRV9XSVRIX0JVVFRPTiA9IFwiQ0xPU0VfV0lUSF9CVVRUT05cIjsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIHN0YXRlQ2hhcnQgPSB7XG4gIGluaXRpYWw6IElETEUsXG4gIHN0YXRlczogKF9zdGF0ZXMgPSB7fSwgX3N0YXRlc1tJRExFXSA9IHtcbiAgICBvbjogKF9vbiA9IHt9LCBfb25bQkxVUl0gPSBJRExFLCBfb25bQ0xFQVJdID0gSURMRSwgX29uW0NIQU5HRV0gPSBTVUdHRVNUSU5HLCBfb25bSU5JVElBTF9DSEFOR0VdID0gSURMRSwgX29uW0ZPQ1VTXSA9IFNVR0dFU1RJTkcsIF9vbltOQVZJR0FURV0gPSBOQVZJR0FUSU5HLCBfb25bT1BFTl9XSVRIX0JVVFRPTl0gPSBTVUdHRVNUSU5HLCBfb25bT1BFTl9XSVRIX0lOUFVUX0NMSUNLXSA9IFNVR0dFU1RJTkcsIF9vbilcbiAgfSwgX3N0YXRlc1tTVUdHRVNUSU5HXSA9IHtcbiAgICBvbjogKF9vbjIgPSB7fSwgX29uMltDSEFOR0VdID0gU1VHR0VTVElORywgX29uMltGT0NVU10gPSBTVUdHRVNUSU5HLCBfb24yW05BVklHQVRFXSA9IE5BVklHQVRJTkcsIF9vbjJbQ0xFQVJdID0gSURMRSwgX29uMltFU0NBUEVdID0gSURMRSwgX29uMltCTFVSXSA9IElETEUsIF9vbjJbU0VMRUNUX1dJVEhfQ0xJQ0tdID0gSURMRSwgX29uMltJTlRFUkFDVF0gPSBJTlRFUkFDVElORywgX29uMltDTE9TRV9XSVRIX0JVVFRPTl0gPSBJRExFLCBfb24yKVxuICB9LCBfc3RhdGVzW05BVklHQVRJTkddID0ge1xuICAgIG9uOiAoX29uMyA9IHt9LCBfb24zW0NIQU5HRV0gPSBTVUdHRVNUSU5HLCBfb24zW0ZPQ1VTXSA9IFNVR0dFU1RJTkcsIF9vbjNbQ0xFQVJdID0gSURMRSwgX29uM1tCTFVSXSA9IElETEUsIF9vbjNbRVNDQVBFXSA9IElETEUsIF9vbjNbTkFWSUdBVEVdID0gTkFWSUdBVElORywgX29uM1tTRUxFQ1RfV0lUSF9DTElDS10gPSBJRExFLCBfb24zW1NFTEVDVF9XSVRIX0tFWUJPQVJEXSA9IElETEUsIF9vbjNbQ0xPU0VfV0lUSF9CVVRUT05dID0gSURMRSwgX29uM1tJTlRFUkFDVF0gPSBJTlRFUkFDVElORywgX29uMylcbiAgfSwgX3N0YXRlc1tJTlRFUkFDVElOR10gPSB7XG4gICAgb246IChfb240ID0ge30sIF9vbjRbQ0xFQVJdID0gSURMRSwgX29uNFtDSEFOR0VdID0gU1VHR0VTVElORywgX29uNFtGT0NVU10gPSBTVUdHRVNUSU5HLCBfb240W0JMVVJdID0gSURMRSwgX29uNFtFU0NBUEVdID0gSURMRSwgX29uNFtOQVZJR0FURV0gPSBOQVZJR0FUSU5HLCBfb240W0NMT1NFX1dJVEhfQlVUVE9OXSA9IElETEUsIF9vbjRbU0VMRUNUX1dJVEhfQ0xJQ0tdID0gSURMRSwgX29uNClcbiAgfSwgX3N0YXRlcylcbn07XG5cbnZhciByZWR1Y2VyID0gZnVuY3Rpb24gcmVkdWNlcihkYXRhLCBldmVudCkge1xuICB2YXIgbmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICBsYXN0RXZlbnRUeXBlOiBldmVudC50eXBlXG4gIH0pO1xuXG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgQ0hBTkdFOlxuICAgIGNhc2UgSU5JVElBTF9DSEFOR0U6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGwsXG4gICAgICAgIHZhbHVlOiBldmVudC52YWx1ZVxuICAgICAgfSk7XG5cbiAgICBjYXNlIE5BVklHQVRFOlxuICAgIGNhc2UgT1BFTl9XSVRIX0JVVFRPTjpcbiAgICBjYXNlIE9QRU5fV0lUSF9JTlBVVF9DTElDSzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogZmluZE5hdmlnYXRpb25WYWx1ZShuZXh0U3RhdGUsIGV2ZW50KVxuICAgICAgfSk7XG5cbiAgICBjYXNlIENMRUFSOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogbnVsbFxuICAgICAgfSk7XG5cbiAgICBjYXNlIEJMVVI6XG4gICAgY2FzZSBFU0NBUEU6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgY2FzZSBTRUxFQ1RfV0lUSF9DTElDSzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICAgIC8vIGlmIGNvbnRyb2xsZWQsIFwic2V0XCIgdGhlIGlucHV0IHRvIHdoYXQgaXQgYWxyZWFkeSBoYXMsIGFuZCBsZXQgdGhlXG4gICAgICAgIC8vIHVzZXIgZG8gd2hhdGV2ZXIgdGhleSB3YW50XG4gICAgICAgIHZhbHVlOiBldmVudC5pc0NvbnRyb2xsZWQgPyBkYXRhLnZhbHVlIDogZXZlbnQudmFsdWUsXG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogbnVsbFxuICAgICAgfSk7XG5cbiAgICBjYXNlIFNFTEVDVF9XSVRIX0tFWUJPQVJEOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgICAgLy8gaWYgY29udHJvbGxlZCwgXCJzZXRcIiB0aGUgaW5wdXQgdG8gd2hhdCBpdCBhbHJlYWR5IGhhcywgYW5kIGxldCB0aGVcbiAgICAgICAgLy8gdXNlciBkbyB3aGF0ZXZlciB0aGV5IHdhbnRcbiAgICAgICAgdmFsdWU6IGV2ZW50LmlzQ29udHJvbGxlZCA/IGRhdGEudmFsdWUgOiBkYXRhLm5hdmlnYXRpb25WYWx1ZSxcbiAgICAgICAgbmF2aWdhdGlvblZhbHVlOiBudWxsXG4gICAgICB9KTtcblxuICAgIGNhc2UgQ0xPU0VfV0lUSF9CVVRUT046XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgY2FzZSBJTlRFUkFDVDpcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG5cbiAgICBjYXNlIEZPQ1VTOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgICAgbmF2aWdhdGlvblZhbHVlOiBmaW5kTmF2aWdhdGlvblZhbHVlKG5leHRTdGF0ZSwgZXZlbnQpXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwb3BvdmVySXNFeHBhbmRlZChzdGF0ZSkge1xuICByZXR1cm4gW1NVR0dFU1RJTkcsIE5BVklHQVRJTkcsIElOVEVSQUNUSU5HXS5pbmNsdWRlcyhzdGF0ZSk7XG59XG4vKipcbiAqIFdoZW4gd2Ugb3BlbiBhIGxpc3QsIHNldCB0aGUgbmF2aWdhdGlvbiB2YWx1ZSB0byB0aGUgdmFsdWUgaW4gdGhlIGlucHV0LCBpZlxuICogaXQncyBpbiB0aGUgbGlzdCwgdGhlbiBpdCdsbCBhdXRvbWF0aWNhbGx5IGJlIGhpZ2hsaWdodGVkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZURhdGFcbiAqIEBwYXJhbSBldmVudFxuICovXG5cblxuZnVuY3Rpb24gZmluZE5hdmlnYXRpb25WYWx1ZShzdGF0ZURhdGEsIGV2ZW50KSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGV2ZW50LnZhbHVlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBldmVudC52YWx1ZTsgLy8gQHRzLWlnbm9yZVxuICB9IGVsc2UgaWYgKGV2ZW50LnBlcnNpc3RTZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGVEYXRhLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBDb21ib2JveERlc2NlbmRhbnRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZURlc2NlbmRhbnRDb250ZXh0KFwiQ29tYm9ib3hEZXNjZW5kYW50Q29udGV4dFwiKTtcbnZhciBDb21ib2JveENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlTmFtZWRDb250ZXh0KFwiQ29tYm9ib3hDb250ZXh0XCIsIHt9KTsgLy8gQWxsb3dzIHVzIHRvIHB1dCB0aGUgb3B0aW9uJ3MgdmFsdWUgb24gY29udGV4dCBzbyB0aGF0IENvbWJvYm94T3B0aW9uVGV4dFxuLy8gY2FuIHdvcmsgaXQncyBoaWdobGlnaHQgdGV4dCBtYWdpYyBubyBtYXR0ZXIgd2hhdCBlbHNlIGlzIHJlbmRlcmVkIGFyb3VuZFxuLy8gaXQuXG5cbnZhciBPcHRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZU5hbWVkQ29udGV4dChcIk9wdGlvbkNvbnRleHRcIiwge30pOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94XG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveFxuICovXG5cbnZhciBDb21ib2JveCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9kYXRhJG5hdmlnYXRpb25WYWx1ZTtcblxuICB2YXIgb25TZWxlY3QgPSBfcmVmLm9uU2VsZWN0LFxuICAgICAgX3JlZiRvcGVuT25Gb2N1cyA9IF9yZWYub3Blbk9uRm9jdXMsXG4gICAgICBvcGVuT25Gb2N1cyA9IF9yZWYkb3Blbk9uRm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRvcGVuT25Gb2N1cyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIF9yZWYkYXMgPSBfcmVmLmFzLFxuICAgICAgQ29tcCA9IF9yZWYkYXMgPT09IHZvaWQgMCA/IFwiZGl2XCIgOiBfcmVmJGFzLFxuICAgICAgYXJpYUxhYmVsID0gX3JlZltcImFyaWEtbGFiZWxcIl0sXG4gICAgICBhcmlhTGFiZWxsZWRieSA9IF9yZWZbXCJhcmlhLWxhYmVsbGVkYnlcIl0sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgdmFyIF91c2VEZXNjZW5kYW50c0luaXQgPSB1c2VEZXNjZW5kYW50c0luaXQoKSxcbiAgICAgIG9wdGlvbnMgPSBfdXNlRGVzY2VuZGFudHNJbml0WzBdLFxuICAgICAgc2V0T3B0aW9ucyA9IF91c2VEZXNjZW5kYW50c0luaXRbMV07IC8vIE5lZWQgdGhpcyB0byBmb2N1cyBpdFxuXG5cbiAgdmFyIGlucHV0UmVmID0gdXNlUmVmKCk7XG4gIHZhciBwb3BvdmVyUmVmID0gdXNlUmVmKCk7XG4gIHZhciBidXR0b25SZWYgPSB1c2VSZWYoKTsgLy8gV2hlbiA8Q29tYm9ib3hJbnB1dCBhdXRvY29tcGxldGU9e2ZhbHNlfSAvPiB3ZSBkb24ndCB3YW50IGN5Y2xlIGJhY2sgdG9cbiAgLy8gdGhlIHVzZXIncyB2YWx1ZSB3aGlsZSBuYXZpZ2F0aW5nIChiZWNhdXNlIGl0J3MgYWx3YXlzIHRoZSB1c2VyJ3MgdmFsdWUpLFxuICAvLyBidXQgd2UgbmVlZCB0byBrbm93IHRoaXMgaW4gdXNlS2V5RG93biB3aGljaCBpcyBmYXIgYXdheSBmcm9tIHRoZSBwcm9wXG4gIC8vIGhlcmUsIHNvIHdlIGRvIHNvbWV0aGluZyBzbmVha3kgYW5kIHdyaXRlIGl0IHRvIHRoaXMgcmVmIG9uIGNvbnRleHQgc28gd2VcbiAgLy8gY2FuIHVzZSBpdCBhbnl3aGVyZSBlbHNlIPCfmJsuIEFub3RoZXIgbmV3IHRyaWNrIGZvciBtZSBhbmQgSSdtIGV4Y2l0ZWRcbiAgLy8gYWJvdXQgdGhpcyBvbmUgdG9vIVxuXG4gIHZhciBhdXRvY29tcGxldGVQcm9wUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIHBlcnNpc3RTZWxlY3Rpb25SZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgLy8gVGhlIHZhbHVlIHRoZSB1c2VyIGhhcyB0eXBlZC4gV2UgZGVyaXZlIHRoaXMgYWxzbyB3aGVuIHRoZSBkZXZlbG9wZXIgaXNcbiAgICAvLyBjb250cm9sbGluZyB0aGUgdmFsdWUgb2YgQ29tYm9ib3hJbnB1dC5cbiAgICB2YWx1ZTogXCJcIixcbiAgICAvLyB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIG5hdmlnYXRlZCB0byB3aXRoIHRoZSBrZXlib2FyZFxuICAgIG5hdmlnYXRpb25WYWx1ZTogbnVsbFxuICB9O1xuXG4gIHZhciBfdXNlUmVkdWNlck1hY2hpbmUgPSB1c2VSZWR1Y2VyTWFjaGluZShzdGF0ZUNoYXJ0LCByZWR1Y2VyLCBkZWZhdWx0RGF0YSksXG4gICAgICBzdGF0ZSA9IF91c2VSZWR1Y2VyTWFjaGluZVswXSxcbiAgICAgIGRhdGEgPSBfdXNlUmVkdWNlck1hY2hpbmVbMV0sXG4gICAgICB0cmFuc2l0aW9uID0gX3VzZVJlZHVjZXJNYWNoaW5lWzJdO1xuXG4gIHVzZUZvY3VzTWFuYWdlbWVudChkYXRhLmxhc3RFdmVudFR5cGUsIGlucHV0UmVmKTtcbiAgdmFyIGlkID0gdXNlSWQocHJvcHMuaWQpO1xuICB2YXIgbGlzdGJveElkID0gaWQgPyBtYWtlSWQoXCJsaXN0Ym94XCIsIGlkKSA6IFwibGlzdGJveFwiO1xuICB2YXIgaXNDb250cm9sbGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGlzRXhwYW5kZWQgPSBwb3BvdmVySXNFeHBhbmRlZChzdGF0ZSk7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGFyaWFMYWJlbDogYXJpYUxhYmVsLFxuICAgIGFyaWFMYWJlbGxlZGJ5OiBhcmlhTGFiZWxsZWRieSxcbiAgICBhdXRvY29tcGxldGVQcm9wUmVmOiBhdXRvY29tcGxldGVQcm9wUmVmLFxuICAgIGJ1dHRvblJlZjogYnV0dG9uUmVmLFxuICAgIGNvbWJvYm94SWQ6IGlkLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgaW5wdXRSZWY6IGlucHV0UmVmLFxuICAgIGlzRXhwYW5kZWQ6IGlzRXhwYW5kZWQsXG4gICAgbGlzdGJveElkOiBsaXN0Ym94SWQsXG4gICAgb25TZWxlY3Q6IG9uU2VsZWN0IHx8IG5vb3AsXG4gICAgb3Blbk9uRm9jdXM6IG9wZW5PbkZvY3VzLFxuICAgIHBlcnNpc3RTZWxlY3Rpb25SZWY6IHBlcnNpc3RTZWxlY3Rpb25SZWYsXG4gICAgcG9wb3ZlclJlZjogcG9wb3ZlclJlZixcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICBpc0NvbnRyb2xsZWRSZWY6IGlzQ29udHJvbGxlZFJlZlxuICB9O1xuICB1c2VDaGVja1N0eWxlcyhcImNvbWJvYm94XCIpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoRGVzY2VuZGFudFByb3ZpZGVyLCB7XG4gICAgY29udGV4dDogQ29tYm9ib3hEZXNjZW5kYW50Q29udGV4dCxcbiAgICBpdGVtczogb3B0aW9ucyxcbiAgICBzZXQ6IHNldE9wdGlvbnNcbiAgfSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoQ29tYm9ib3hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoQ29tcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgXCJkYXRhLXJlYWNoLWNvbWJvYm94XCI6IFwiXCIsXG4gICAgXCJkYXRhLXN0YXRlXCI6IGdldERhdGFTdGF0ZShzdGF0ZSksXG4gICAgXCJkYXRhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWQgfHwgdW5kZWZpbmVkLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gIH0pLCBpc0Z1bmN0aW9uKGNoaWxkcmVuKSA/IGNoaWxkcmVuKHtcbiAgICBpZDogaWQsXG4gICAgaXNFeHBhbmRlZDogaXNFeHBhbmRlZCxcbiAgICBuYXZpZ2F0aW9uVmFsdWU6IChfZGF0YSRuYXZpZ2F0aW9uVmFsdWUgPSBkYXRhLm5hdmlnYXRpb25WYWx1ZSkgIT0gbnVsbCA/IF9kYXRhJG5hdmlnYXRpb25WYWx1ZSA6IG51bGwsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pIDogY2hpbGRyZW4pKSk7XG59KTtcbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveC1wcm9wc1xuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQ29tYm9ib3guZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94XCI7XG4gIENvbWJvYm94LnByb3BUeXBlcyA9IHtcbiAgICBhczogUHJvcFR5cGVzLmFueSxcbiAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3Blbk9uRm9jdXM6IFByb3BUeXBlcy5ib29sXG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29tYm9ib3hJbnB1dFxuICpcbiAqIFdyYXBzIGFuIGA8aW5wdXQvPmAgd2l0aCBhIGNvdXBsZSBleHRyYSBwcm9wcyB0aGF0IHdvcmsgd2l0aCB0aGUgY29tYm9ib3guXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGlucHV0XG4gKi9cblxuXG52YXIgQ29tYm9ib3hJbnB1dCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmMiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmMiRhcyA9IF9yZWYyLmFzLFxuICAgICAgQ29tcCA9IF9yZWYyJGFzID09PSB2b2lkIDAgPyBcImlucHV0XCIgOiBfcmVmMiRhcyxcbiAgICAgIF9yZWYyJHNlbGVjdE9uQ2xpY2sgPSBfcmVmMi5zZWxlY3RPbkNsaWNrLFxuICAgICAgc2VsZWN0T25DbGljayA9IF9yZWYyJHNlbGVjdE9uQ2xpY2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkc2VsZWN0T25DbGljayxcbiAgICAgIF9yZWYyJGF1dG9jb21wbGV0ZSA9IF9yZWYyLmF1dG9jb21wbGV0ZSxcbiAgICAgIGF1dG9jb21wbGV0ZSA9IF9yZWYyJGF1dG9jb21wbGV0ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJGF1dG9jb21wbGV0ZSxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmMi5vbkNsaWNrLFxuICAgICAgb25DaGFuZ2UgPSBfcmVmMi5vbkNoYW5nZSxcbiAgICAgIG9uS2V5RG93biA9IF9yZWYyLm9uS2V5RG93bixcbiAgICAgIG9uQmx1ciA9IF9yZWYyLm9uQmx1cixcbiAgICAgIG9uRm9jdXMgPSBfcmVmMi5vbkZvY3VzLFxuICAgICAgY29udHJvbGxlZFZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBfZXhjbHVkZWQyKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcmVhY2gtdWkvaXNzdWVzLzQ2NFxuICB2YXIgX1JlYWN0JHVzZVJlZiA9IHVzZVJlZihjb250cm9sbGVkVmFsdWUpLFxuICAgICAgaW5pdGlhbENvbnRyb2xsZWRWYWx1ZSA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgY29udHJvbGxlZFZhbHVlQ2hhbmdlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHVzZVVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY29udHJvbGxlZFZhbHVlQ2hhbmdlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSwgW2NvbnRyb2xsZWRWYWx1ZV0pO1xuXG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIF9SZWFjdCR1c2VDb250ZXh0JGRhdCA9IF9SZWFjdCR1c2VDb250ZXh0LmRhdGEsXG4gICAgICBuYXZpZ2F0aW9uVmFsdWUgPSBfUmVhY3QkdXNlQ29udGV4dCRkYXQubmF2aWdhdGlvblZhbHVlLFxuICAgICAgdmFsdWUgPSBfUmVhY3QkdXNlQ29udGV4dCRkYXQudmFsdWUsXG4gICAgICBsYXN0RXZlbnRUeXBlID0gX1JlYWN0JHVzZUNvbnRleHQkZGF0Lmxhc3RFdmVudFR5cGUsXG4gICAgICBpbnB1dFJlZiA9IF9SZWFjdCR1c2VDb250ZXh0LmlucHV0UmVmLFxuICAgICAgc3RhdGUgPSBfUmVhY3QkdXNlQ29udGV4dC5zdGF0ZSxcbiAgICAgIHRyYW5zaXRpb24gPSBfUmVhY3QkdXNlQ29udGV4dC50cmFuc2l0aW9uLFxuICAgICAgbGlzdGJveElkID0gX1JlYWN0JHVzZUNvbnRleHQubGlzdGJveElkLFxuICAgICAgYXV0b2NvbXBsZXRlUHJvcFJlZiA9IF9SZWFjdCR1c2VDb250ZXh0LmF1dG9jb21wbGV0ZVByb3BSZWYsXG4gICAgICBvcGVuT25Gb2N1cyA9IF9SZWFjdCR1c2VDb250ZXh0Lm9wZW5PbkZvY3VzLFxuICAgICAgaXNFeHBhbmRlZCA9IF9SZWFjdCR1c2VDb250ZXh0LmlzRXhwYW5kZWQsXG4gICAgICBhcmlhTGFiZWwgPSBfUmVhY3QkdXNlQ29udGV4dC5hcmlhTGFiZWwsXG4gICAgICBhcmlhTGFiZWxsZWRieSA9IF9SZWFjdCR1c2VDb250ZXh0LmFyaWFMYWJlbGxlZGJ5LFxuICAgICAgcGVyc2lzdFNlbGVjdGlvblJlZiA9IF9SZWFjdCR1c2VDb250ZXh0LnBlcnNpc3RTZWxlY3Rpb25SZWYsXG4gICAgICBpc0NvbnRyb2xsZWRSZWYgPSBfUmVhY3QkdXNlQ29udGV4dC5pc0NvbnRyb2xsZWRSZWY7XG5cbiAgdmFyIHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhpbnB1dFJlZiwgZm9yd2FyZGVkUmVmKTsgLy8gQmVjYXVzZSB3ZSBjbG9zZSB0aGUgTGlzdCBvbiBibHVyLCB3ZSBuZWVkIHRvIHRyYWNrIGlmIHRoZSBibHVyIGlzXG4gIC8vIGNhdXNlZCBieSBjbGlja2luZyBpbnNpZGUgdGhlIGxpc3QsIGFuZCBpZiBzbywgZG9uJ3QgY2xvc2UgdGhlIExpc3QuXG5cbiAgdmFyIHNlbGVjdE9uQ2xpY2tSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgaGFuZGxlS2V5RG93biA9IHVzZUtleURvd24oKTtcbiAgdmFyIGhhbmRsZUJsdXIgPSB1c2VCbHVyKCk7XG4gIHZhciBpc0NvbnRyb2xsZWQgPSB0eXBlb2YgY29udHJvbGxlZFZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xuICB2YXIgd2FzSW5pdGlhbGx5Q29udHJvbGxlZCA9IHR5cGVvZiBpbml0aWFsQ29udHJvbGxlZFZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoIWlzQ29udHJvbGxlZCAmJiB3YXNJbml0aWFsbHlDb250cm9sbGVkKSwgXCJDb21ib2JveElucHV0IGlzIGNoYW5naW5nIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQuIENvbWJvYm94SW5wdXQgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgQ29tYm9ib3hJbnB1dCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIENoZWNrIHRoZSBgdmFsdWVgIHByb3AgYmVpbmcgcGFzc2VkIGluLlwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoaXNDb250cm9sbGVkICYmICF3YXNJbml0aWFsbHlDb250cm9sbGVkKSwgXCJDb21ib2JveElucHV0IGlzIGNoYW5naW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQuIENvbWJvYm94SW5wdXQgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgQ29tYm9ib3hJbnB1dCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIENoZWNrIHRoZSBgdmFsdWVgIHByb3AgYmVpbmcgcGFzc2VkIGluLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaXNDb250cm9sbGVkUmVmLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2lzQ29udHJvbGxlZF0pOyAvLyBMYXlvdXQgZWZmZWN0IHNob3VsZCBiZSBTU1Itc2FmZSBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgZG9cbiAgLy8gYW55dGhpbmcgd2l0aCB0aGlzIHJlZiB0aGF0IGludm9sdmVzIHJlbmRlcmluZyB1bnRpbCBhZnRlciB3ZSd2ZVxuICAvLyBsZXQgdGhlIGNsaWVudCBoeWRyYXRlIGluIG5lc3RlZCBjb21wb25lbnRzLlxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGF1dG9jb21wbGV0ZVByb3BSZWYuY3VycmVudCA9IGF1dG9jb21wbGV0ZTtcbiAgfSwgW2F1dG9jb21wbGV0ZSwgYXV0b2NvbXBsZXRlUHJvcFJlZl0pO1xuICB2YXIgaGFuZGxlVmFsdWVDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0cmFuc2l0aW9uKENMRUFSLCB7XG4gICAgICAgIGlzQ29udHJvbGxlZDogaXNDb250cm9sbGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBpbml0aWFsQ29udHJvbGxlZFZhbHVlICYmICFjb250cm9sbGVkVmFsdWVDaGFuZ2VkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHRyYW5zaXRpb24oSU5JVElBTF9DSEFOR0UsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbihDSEFOR0UsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtpbml0aWFsQ29udHJvbGxlZFZhbHVlLCB0cmFuc2l0aW9uLCBpc0NvbnRyb2xsZWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJZiB0aGV5IGFyZSBjb250cm9sbGluZyB0aGUgdmFsdWUgd2Ugc3RpbGwgbmVlZCB0byBkbyBvdXIgdHJhbnNpdGlvbnMsXG4gICAgLy8gc28gIHdlIGhhdmUgdGhpcyBkZXJpdmVkIHN0YXRlIHRvIGVtdWxhdGUgb25DaGFuZ2Ugb2YgdGhlIGlucHV0IGFzIHdlXG4gICAgLy8gcmVjZWl2ZSBuZXcgYHZhbHVlYHMgLi4uWypdXG4gICAgaWYgKGlzQ29udHJvbGxlZCAmJiBjb250cm9sbGVkVmFsdWUgIT09IHZhbHVlICYmICggLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL2lzc3Vlcy80ODFcbiAgICBjb250cm9sbGVkVmFsdWUudHJpbSgpID09PSBcIlwiID8gKHZhbHVlIHx8IFwiXCIpLnRyaW0oKSAhPT0gXCJcIiA6IHRydWUpKSB7XG4gICAgICBoYW5kbGVWYWx1ZUNoYW5nZShjb250cm9sbGVkVmFsdWUpO1xuICAgIH1cbiAgfSwgW2NvbnRyb2xsZWRWYWx1ZSwgaGFuZGxlVmFsdWVDaGFuZ2UsIGlzQ29udHJvbGxlZCwgdmFsdWVdKTsgLy8gWypdLi4uIGFuZCB3aGVuIGNvbnRyb2xsZWQsIHdlIGRvbid0IHRyaWdnZXIgaGFuZGxlVmFsdWVDaGFuZ2UgYXMgdGhlXG4gIC8vIHVzZXIgdHlwZXMsIGluc3RlYWQgdGhlIGRldmVsb3BlciBjb250cm9scyBpdCB3aXRoIHRoZSBub3JtYWwgaW5wdXRcbiAgLy8gb25DaGFuZ2UgcHJvcFxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShldmVudCkge1xuICAgIHZhciB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgIGlmICghaXNDb250cm9sbGVkKSB7XG4gICAgICBoYW5kbGVWYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9jdXMoKSB7XG4gICAgaWYgKHNlbGVjdE9uQ2xpY2spIHtcbiAgICAgIHNlbGVjdE9uQ2xpY2tSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSAvLyBJZiB3ZSBzZWxlY3QgYW4gb3B0aW9uIHdpdGggY2xpY2ssIHVzZUZvY3VzTWFuYWdlbWVudCB3aWxsIGZvY3VzIHRoZVxuICAgIC8vIGlucHV0LCBpbiB0aG9zZSBjYXNlcyB3ZSBkb24ndCB3YW50IHRvIGNhdXNlIHRoZSBtZW51IHRvIG9wZW4gYmFjayB1cCxcbiAgICAvLyBzbyB3ZSBndWFyZCBiZWhpbmQgdGhlc2Ugc3RhdGVzLlxuXG5cbiAgICBpZiAob3Blbk9uRm9jdXMgJiYgbGFzdEV2ZW50VHlwZSAhPT0gU0VMRUNUX1dJVEhfQ0xJQ0spIHtcbiAgICAgIHRyYW5zaXRpb24oRk9DVVMsIHtcbiAgICAgICAgcGVyc2lzdFNlbGVjdGlvbjogcGVyc2lzdFNlbGVjdGlvblJlZi5jdXJyZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAoc2VsZWN0T25DbGlja1JlZi5jdXJyZW50KSB7XG4gICAgICB2YXIgX2lucHV0UmVmJGN1cnJlbnQ7XG5cbiAgICAgIHNlbGVjdE9uQ2xpY2tSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgKF9pbnB1dFJlZiRjdXJyZW50ID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnB1dFJlZiRjdXJyZW50LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGlmIChvcGVuT25Gb2N1cyAmJiBzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgdHJhbnNpdGlvbihPUEVOX1dJVEhfSU5QVVRfQ0xJQ0spO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnB1dFZhbHVlID0gYXV0b2NvbXBsZXRlICYmIChzdGF0ZSA9PT0gTkFWSUdBVElORyB8fCBzdGF0ZSA9PT0gSU5URVJBQ1RJTkcpID8gLy8gV2hlbiBpZGxlLCB3ZSBkb24ndCBoYXZlIGEgbmF2aWdhdGlvblZhbHVlIG9uIEFycm93VXAvRG93blxuICBuYXZpZ2F0aW9uVmFsdWUgfHwgY29udHJvbGxlZFZhbHVlIHx8IHZhbHVlIDogY29udHJvbGxlZFZhbHVlIHx8IHZhbHVlO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoQ29tcCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IG5hdmlnYXRpb25WYWx1ZSA/IFN0cmluZyhtYWtlSGFzaChuYXZpZ2F0aW9uVmFsdWUpKSA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwiYm90aFwiLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBsaXN0Ym94SWQsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWQsXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsID8gdW5kZWZpbmVkIDogYXJpYUxhYmVsbGVkYnksXG4gICAgcm9sZTogXCJjb21ib2JveFwiXG4gIH0sIHByb3BzLCB7XG4gICAgXCJkYXRhLXJlYWNoLWNvbWJvYm94LWlucHV0XCI6IFwiXCIsXG4gICAgXCJkYXRhLXN0YXRlXCI6IGdldERhdGFTdGF0ZShzdGF0ZSksXG4gICAgcmVmOiByZWYsXG4gICAgb25CbHVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkJsdXIsIGhhbmRsZUJsdXIpLFxuICAgIG9uQ2hhbmdlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNoYW5nZSwgaGFuZGxlQ2hhbmdlKSxcbiAgICBvbkNsaWNrOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNsaWNrLCBoYW5kbGVDbGljayksXG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgaGFuZGxlRm9jdXMpLFxuICAgIG9uS2V5RG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25LZXlEb3duLCBoYW5kbGVLZXlEb3duKSxcbiAgICB2YWx1ZTogaW5wdXRWYWx1ZSB8fCBcIlwiXG4gIH0pKTtcbn0pO1xuLyoqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94aW5wdXQtcHJvcHNcbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIENvbWJvYm94SW5wdXQuZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94SW5wdXRcIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb21ib2JveFBvcG92ZXJcbiAqXG4gKiBDb250YWlucyB0aGUgcG9wdXAgdGhhdCByZW5kZXJzIHRoZSBsaXN0LiBCZWNhdXNlIHNvbWUgVUkgbmVlZHMgdG8gcmVuZGVyXG4gKiBtb3JlIHRoYW4gdGhlIGxpc3QgaW4gdGhlIHBvcHVwLCB5b3UgbmVlZCB0byByZW5kZXIgb25lIG9mIHRoZXNlIGFyb3VuZCB0aGVcbiAqIGxpc3QuIEZvciBleGFtcGxlLCBtYXliZSB5b3Ugd2FudCB0byByZW5kZXIgdGhlIG51bWJlciBvZiByZXN1bHRzIHN1Z2dlc3RlZC5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94cG9wb3ZlclxuICovXG5cblxudmFyIENvbWJvYm94UG9wb3ZlciA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmMywgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmMyRhcyA9IF9yZWYzLmFzLFxuICAgICAgQ29tcCA9IF9yZWYzJGFzID09PSB2b2lkIDAgPyBcImRpdlwiIDogX3JlZjMkYXMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYzLmNoaWxkcmVuLFxuICAgICAgX3JlZjMkcG9ydGFsID0gX3JlZjMucG9ydGFsLFxuICAgICAgcG9ydGFsID0gX3JlZjMkcG9ydGFsID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkcG9ydGFsLFxuICAgICAgb25LZXlEb3duID0gX3JlZjMub25LZXlEb3duLFxuICAgICAgb25CbHVyID0gX3JlZjMub25CbHVyLFxuICAgICAgX3JlZjMkcG9zaXRpb24gPSBfcmVmMy5wb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uID0gX3JlZjMkcG9zaXRpb24gPT09IHZvaWQgMCA/IHBvc2l0aW9uTWF0Y2hXaWR0aCA6IF9yZWYzJHBvc2l0aW9uLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMywgX2V4Y2x1ZGVkMyk7XG5cbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0MiA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIHBvcG92ZXJSZWYgPSBfUmVhY3QkdXNlQ29udGV4dDIucG9wb3ZlclJlZixcbiAgICAgIGlucHV0UmVmID0gX1JlYWN0JHVzZUNvbnRleHQyLmlucHV0UmVmLFxuICAgICAgaXNFeHBhbmRlZCA9IF9SZWFjdCR1c2VDb250ZXh0Mi5pc0V4cGFuZGVkLFxuICAgICAgc3RhdGUgPSBfUmVhY3QkdXNlQ29udGV4dDIuc3RhdGU7XG5cbiAgdmFyIHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhwb3BvdmVyUmVmLCBmb3J3YXJkZWRSZWYpO1xuICB2YXIgaGFuZGxlS2V5RG93biA9IHVzZUtleURvd24oKTtcbiAgdmFyIGhhbmRsZUJsdXIgPSB1c2VCbHVyKCk7XG4gIHZhciBzaGFyZWRQcm9wcyA9IHtcbiAgICBcImRhdGEtcmVhY2gtY29tYm9ib3gtcG9wb3ZlclwiOiBcIlwiLFxuICAgIFwiZGF0YS1zdGF0ZVwiOiBnZXREYXRhU3RhdGUoc3RhdGUpLFxuICAgIG9uS2V5RG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25LZXlEb3duLCBoYW5kbGVLZXlEb3duKSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgaGFuZGxlQmx1ciksXG4gICAgLy8gSW5zdGVhZCBvZiBjb25kaXRpb25hbGx5IHJlbmRlcmluZyB0aGUgcG9wb3ZlciB3ZSB1c2UgdGhlIGBoaWRkZW5gIHByb3BcbiAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gdW5tb3VudCBvbiBjbG9zZSAoZnJvbSBlc2NhcGUgb3Igb25TZWxlY3QpLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBkZXZlbG9wZXIgY2FuIGNvbmRpdGlvbmFsbHkgcmVuZGVyIHRoZSBDb21ib2JveFBvcG92ZXIgaWZcbiAgICAvLyB0aGV5IGRvIHdhbnQgdG8gY2F1c2UgbW91bnQvdW5tb3VudCBiYXNlZCBvbiB0aGUgYXBwJ3Mgb3duIGRhdGEgKGxpa2VcbiAgICAvLyByZXN1bHRzLmxlbmd0aCBvciB3aGF0ZXZlcikuXG4gICAgaGlkZGVuOiAhaXNFeHBhbmRlZCxcbiAgICB0YWJJbmRleDogLTEsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH07XG4gIHJldHVybiBwb3J0YWwgPyAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChQb3BvdmVyLCBfZXh0ZW5kcyh7XG4gICAgYXM6IENvbXBcbiAgfSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBcImRhdGEtZXhwYW5kZWRcIjogaXNFeHBhbmRlZCB8fCB1bmRlZmluZWQsXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHRhcmdldFJlZjogaW5wdXRSZWZcbiAgfSwgc2hhcmVkUHJvcHMpKSA6IC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KENvbXAsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcywgc2hhcmVkUHJvcHMpKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIENvbWJvYm94UG9wb3Zlci5kaXNwbGF5TmFtZSA9IFwiQ29tYm9ib3hQb3BvdmVyXCI7XG59XG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3hwb3BvdmVyLXByb3BzXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94TGlzdFxuICpcbiAqIENvbnRhaW5zIHRoZSBgQ29tYm9ib3hPcHRpb25gIGVsZW1lbnRzIGFuZCBzZXRzIHVwIHRoZSBwcm9wZXIgYXJpYSBhdHRyaWJ1dGVzXG4gKiBmb3IgdGhlIGxpc3QuXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGxpc3RcbiAqL1xudmFyIENvbWJvYm94TGlzdCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmNCwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmNCRwZXJzaXN0U2VsZWN0aW8gPSBfcmVmNC5wZXJzaXN0U2VsZWN0aW9uLFxuICAgICAgcGVyc2lzdFNlbGVjdGlvbiA9IF9yZWY0JHBlcnNpc3RTZWxlY3RpbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRwZXJzaXN0U2VsZWN0aW8sXG4gICAgICBfcmVmNCRhcyA9IF9yZWY0LmFzLFxuICAgICAgQ29tcCA9IF9yZWY0JGFzID09PSB2b2lkIDAgPyBcInVsXCIgOiBfcmVmNCRhcyxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjQsIF9leGNsdWRlZDQpO1xuXG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDMgPSB1c2VDb250ZXh0KENvbWJvYm94Q29udGV4dCksXG4gICAgICBwZXJzaXN0U2VsZWN0aW9uUmVmID0gX1JlYWN0JHVzZUNvbnRleHQzLnBlcnNpc3RTZWxlY3Rpb25SZWYsXG4gICAgICBsaXN0Ym94SWQgPSBfUmVhY3QkdXNlQ29udGV4dDMubGlzdGJveElkO1xuXG4gIGlmIChwZXJzaXN0U2VsZWN0aW9uKSB7XG4gICAgcGVyc2lzdFNlbGVjdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChDb21wLCBfZXh0ZW5kcyh7XG4gICAgcm9sZTogXCJsaXN0Ym94XCJcbiAgfSwgcHJvcHMsIHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICBcImRhdGEtcmVhY2gtY29tYm9ib3gtbGlzdFwiOiBcIlwiLFxuICAgIGlkOiBsaXN0Ym94SWRcbiAgfSkpO1xufSk7XG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3hsaXN0LXByb3BzXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBDb21ib2JveExpc3QuZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94TGlzdFwiO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94T3B0aW9uXG4gKlxuICogQW4gb3B0aW9uIHRoYXQgaXMgc3VnZ2VzdGVkIHRvIHRoZSB1c2VyIGFzIHRoZXkgaW50ZXJhY3Qgd2l0aCB0aGUgY29tYm9ib3guXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveG9wdGlvblxuICovXG5cblxudmFyIENvbWJvYm94T3B0aW9uID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWY1LCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9yZWY1JGFzID0gX3JlZjUuYXMsXG4gICAgICBDb21wID0gX3JlZjUkYXMgPT09IHZvaWQgMCA/IFwibGlcIiA6IF9yZWY1JGFzLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmNS5jaGlsZHJlbixcbiAgICAgIGluZGV4UHJvcCA9IF9yZWY1LmluZGV4LFxuICAgICAgdmFsdWUgPSBfcmVmNS52YWx1ZSxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmNS5vbkNsaWNrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNSwgX2V4Y2x1ZGVkNSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0NCA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIG9uU2VsZWN0ID0gX1JlYWN0JHVzZUNvbnRleHQ0Lm9uU2VsZWN0LFxuICAgICAgbmF2aWdhdGlvblZhbHVlID0gX1JlYWN0JHVzZUNvbnRleHQ0LmRhdGEubmF2aWdhdGlvblZhbHVlLFxuICAgICAgdHJhbnNpdGlvbiA9IF9SZWFjdCR1c2VDb250ZXh0NC50cmFuc2l0aW9uLFxuICAgICAgaXNDb250cm9sbGVkUmVmID0gX1JlYWN0JHVzZUNvbnRleHQ0LmlzQ29udHJvbGxlZFJlZjtcblxuICB2YXIgb3duUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGVmdWxSZWZWYWx1ZSA9IHVzZVN0YXRlZnVsUmVmVmFsdWUob3duUmVmLCBudWxsKSxcbiAgICAgIGVsZW1lbnQgPSBfdXNlU3RhdGVmdWxSZWZWYWx1ZVswXSxcbiAgICAgIGhhbmRsZVJlZlNldCA9IF91c2VTdGF0ZWZ1bFJlZlZhbHVlWzFdO1xuXG4gIHZhciBkZXNjZW5kYW50ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9LCBbdmFsdWUsIGVsZW1lbnRdKTtcbiAgdmFyIGluZGV4ID0gdXNlRGVzY2VuZGFudChkZXNjZW5kYW50LCBDb21ib2JveERlc2NlbmRhbnRDb250ZXh0LCBpbmRleFByb3ApO1xuICB2YXIgcmVmID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgaGFuZGxlUmVmU2V0KTtcbiAgdmFyIGlzQWN0aXZlID0gbmF2aWdhdGlvblZhbHVlID09PSB2YWx1ZTtcblxuICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBvblNlbGVjdCAmJiBvblNlbGVjdCh2YWx1ZSk7XG4gICAgdHJhbnNpdGlvbihTRUxFQ1RfV0lUSF9DTElDSywge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaXNDb250cm9sbGVkOiBpc0NvbnRyb2xsZWRSZWYuY3VycmVudFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChPcHRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoQ29tcCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0FjdGl2ZSxcbiAgICByb2xlOiBcIm9wdGlvblwiXG4gIH0sIHByb3BzLCB7XG4gICAgXCJkYXRhLXJlYWNoLWNvbWJvYm94LW9wdGlvblwiOiBcIlwiLFxuICAgIHJlZjogcmVmLFxuICAgIGlkOiBTdHJpbmcobWFrZUhhc2godmFsdWUpKSxcbiAgICBcImRhdGEtaGlnaGxpZ2h0ZWRcIjogaXNBY3RpdmUgPyBcIlwiIDogdW5kZWZpbmVkIC8vIFdpdGhvdXQgdGhpcyB0aGUgbWVudSB3aWxsIGNsb3NlIGZyb20gYG9uQmx1cmAsIGJ1dCB3aXRoIGl0IHRoZVxuICAgIC8vIGVsZW1lbnQgY2FuIGJlIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBhbmQgdGhlbiBvdXIgZm9jdXMgY2hlY2tzIGluXG4gICAgLy8gb25CbHVyIHdpbGwgd29yayBhcyBpbnRlbmRlZFxuICAgICxcbiAgICB0YWJJbmRleDogLTEsXG4gICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnMob25DbGljaywgaGFuZGxlQ2xpY2spXG4gIH0pLCBjaGlsZHJlbiA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pID8gY2hpbGRyZW4oe1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfSkgOiBjaGlsZHJlbiA6IC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KENvbWJvYm94T3B0aW9uVGV4dCwgbnVsbCkpKTtcbn0pO1xuLyoqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94b3B0aW9uLXByb3BzXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBDb21ib2JveE9wdGlvbi5kaXNwbGF5TmFtZSA9IFwiQ29tYm9ib3hPcHRpb25cIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb21ib2JveE9wdGlvblRleHRcbiAqXG4gKiBSZW5kZXJzIHRoZSB2YWx1ZSBvZiBhIGBDb21ib2JveE9wdGlvbmAgYXMgdGV4dCBidXQgd2l0aCBzcGFucyB3cmFwcGluZyB0aGVcbiAqIG1hdGNoaW5nIGFuZCBub24tbWF0Y2hpbmcgc2VnbWVudHMgb2YgdGV4dC5cbiAqXG4gKiBXZSBkb24ndCBmb3J3YXJkUmVmIG9yIHNwcmVhZCBwcm9wcyBiZWNhdXNlIHdlIHJlbmRlciBtdWx0aXBsZSBzcGFucyBvciBudWxsLFxuICogc2hvdWxkIGJlIGZpbmUg8J+kmVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIDxDb21ib2JveE9wdGlvbiB2YWx1ZT1cIlNlYXR0bGVcIj5cbiAqICAgICDwn4ynIDxDb21ib2JveE9wdGlvblRleHQgLz5cbiAqICAgPC9Db21ib2JveE9wdGlvbj5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94b3B0aW9udGV4dFxuICovXG5cblxuZnVuY3Rpb24gQ29tYm9ib3hPcHRpb25UZXh0KCkge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ1ID0gdXNlQ29udGV4dChPcHRpb25Db250ZXh0KSxcbiAgICAgIHZhbHVlID0gX1JlYWN0JHVzZUNvbnRleHQ1LnZhbHVlO1xuXG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDYgPSB1c2VDb250ZXh0KENvbWJvYm94Q29udGV4dCksXG4gICAgICBjb250ZXh0VmFsdWUgPSBfUmVhY3QkdXNlQ29udGV4dDYuZGF0YS52YWx1ZTtcblxuICB2YXIgcmVzdWx0cyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBIaWdobGlnaHRXb3Jkcy5maW5kQWxsKHtcbiAgICAgIHNlYXJjaFdvcmRzOiBlc2NhcGVSZWdleHAoY29udGV4dFZhbHVlIHx8IFwiXCIpLnNwbGl0KC9cXHMrLyksXG4gICAgICB0ZXh0VG9IaWdobGlnaHQ6IHZhbHVlXG4gICAgfSk7XG4gIH0sIFtjb250ZXh0VmFsdWUsIHZhbHVlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcmVzdWx0cy5sZW5ndGggPyByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xuICAgIHZhciBzdHIgPSB2YWx1ZS5zbGljZShyZXN1bHQuc3RhcnQsIHJlc3VsdC5lbmQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAga2V5OiBpbmRleCxcbiAgICAgIFwiZGF0YS1yZWFjaC1jb21ib2JveC1vcHRpb24tdGV4dFwiOiBcIlwiLFxuICAgICAgXCJkYXRhLXVzZXItdmFsdWVcIjogcmVzdWx0LmhpZ2hsaWdodCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICBcImRhdGEtc3VnZ2VzdGVkLXZhbHVlXCI6IHJlc3VsdC5oaWdobGlnaHQgPyB1bmRlZmluZWQgOiB0cnVlXG4gICAgfSwgc3RyKTtcbiAgfSkgOiB2YWx1ZSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQ29tYm9ib3hPcHRpb25UZXh0LmRpc3BsYXlOYW1lID0gXCJDb21ib2JveE9wdGlvblRleHRcIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb21ib2JveEJ1dHRvblxuICovXG5cblxudmFyIENvbWJvYm94QnV0dG9uID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWY2LCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9yZWY2JGFzID0gX3JlZjYuYXMsXG4gICAgICBDb21wID0gX3JlZjYkYXMgPT09IHZvaWQgMCA/IFwiYnV0dG9uXCIgOiBfcmVmNiRhcyxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmNi5vbkNsaWNrLFxuICAgICAgb25LZXlEb3duID0gX3JlZjYub25LZXlEb3duLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNiwgX2V4Y2x1ZGVkNik7XG5cbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0NyA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIHRyYW5zaXRpb24gPSBfUmVhY3QkdXNlQ29udGV4dDcudHJhbnNpdGlvbixcbiAgICAgIHN0YXRlID0gX1JlYWN0JHVzZUNvbnRleHQ3LnN0YXRlLFxuICAgICAgYnV0dG9uUmVmID0gX1JlYWN0JHVzZUNvbnRleHQ3LmJ1dHRvblJlZixcbiAgICAgIGxpc3Rib3hJZCA9IF9SZWFjdCR1c2VDb250ZXh0Ny5saXN0Ym94SWQsXG4gICAgICBpc0V4cGFuZGVkID0gX1JlYWN0JHVzZUNvbnRleHQ3LmlzRXhwYW5kZWQ7XG5cbiAgdmFyIHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhidXR0b25SZWYsIGZvcndhcmRlZFJlZik7XG4gIHZhciBoYW5kbGVLZXlEb3duID0gdXNlS2V5RG93bigpO1xuXG4gIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmIChzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgdHJhbnNpdGlvbihPUEVOX1dJVEhfQlVUVE9OKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbihDTE9TRV9XSVRIX0JVVFRPTik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChDb21wLCBfZXh0ZW5kcyh7XG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IGxpc3Rib3hJZCxcbiAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBcImRhdGEtcmVhY2gtY29tYm9ib3gtYnV0dG9uXCI6IFwiXCIsXG4gICAgcmVmOiByZWYsXG4gICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnMob25DbGljaywgaGFuZGxlQ2xpY2spLFxuICAgIG9uS2V5RG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25LZXlEb3duLCBoYW5kbGVLZXlEb3duKVxuICB9KSk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBDb21ib2JveEJ1dHRvbi5kaXNwbGF5TmFtZSA9IFwiQ29tYm9ib3hCdXR0b25cIjtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBNb3ZlIGZvY3VzIGJhY2sgdG8gdGhlIGlucHV0IGlmIHdlIHN0YXJ0IG5hdmlnYXRpbmcgdy8gdGhlXG4gKiBrZXlib2FyZCBhZnRlciBmb2N1cyBoYXMgbW92ZWQgdG8gYW55IGZvY3VzYWJsZSBjb250ZW50IGluXG4gKiB0aGUgcG9wdXAuXG4gKlxuICogQHBhcmFtIGxhc3RFdmVudFR5cGVcbiAqIEBwYXJhbSBpbnB1dFJlZlxuICovXG5cblxuZnVuY3Rpb24gdXNlRm9jdXNNYW5hZ2VtZW50KGxhc3RFdmVudFR5cGUsIGlucHV0UmVmKSB7XG4gIC8vIHVzZUxheW91dEVmZmVjdCBzbyB0aGF0IHRoZSBjdXJzb3IgZ29lcyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBpbnN0ZWFkXG4gIC8vIG9mIGF3a3dhcmRseSBhdCB0aGUgYmVnaW5uaW5nLCB1bmNsZWFyIHRvIG1lIHdoeSDwn6S34oCN4pmC77iPXG4gIC8vXG4gIC8vIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBoZXJlIHNpbmNlIHdlJ3JlIGp1c3QgZm9jdXNpbmcgYW4gaW5wdXQuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChsYXN0RXZlbnRUeXBlID09PSBOQVZJR0FURSB8fCBsYXN0RXZlbnRUeXBlID09PSBFU0NBUEUgfHwgbGFzdEV2ZW50VHlwZSA9PT0gU0VMRUNUX1dJVEhfQ0xJQ0sgfHwgbGFzdEV2ZW50VHlwZSA9PT0gT1BFTl9XSVRIX0JVVFRPTikge1xuICAgICAgdmFyIF9pbnB1dFJlZiRjdXJyZW50MjtcblxuICAgICAgKF9pbnB1dFJlZiRjdXJyZW50MiA9IGlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfaW5wdXRSZWYkY3VycmVudDIuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFtpbnB1dFJlZiwgbGFzdEV2ZW50VHlwZV0pO1xufVxuLyoqXG4gKiBXZSB3YW50IHRoZSBzYW1lIGV2ZW50cyB3aGVuIHRoZSBpbnB1dCBvciB0aGUgcG9wdXAgaGF2ZSBmb2N1cyAoSE9XIENPT0wgQVJFXG4gKiBIT09LUyBCVFc/KSBUaGlzIGlzIHByb2JhYmx5IHRoZSBoYWlyaWVzdCBwaWVjZSBidXQgaXQncyBub3QgYmFkLlxuICovXG5cblxuZnVuY3Rpb24gdXNlS2V5RG93bigpIHtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0OCA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIG5hdmlnYXRpb25WYWx1ZSA9IF9SZWFjdCR1c2VDb250ZXh0OC5kYXRhLm5hdmlnYXRpb25WYWx1ZSxcbiAgICAgIG9uU2VsZWN0ID0gX1JlYWN0JHVzZUNvbnRleHQ4Lm9uU2VsZWN0LFxuICAgICAgc3RhdGUgPSBfUmVhY3QkdXNlQ29udGV4dDguc3RhdGUsXG4gICAgICB0cmFuc2l0aW9uID0gX1JlYWN0JHVzZUNvbnRleHQ4LnRyYW5zaXRpb24sXG4gICAgICBhdXRvY29tcGxldGVQcm9wUmVmID0gX1JlYWN0JHVzZUNvbnRleHQ4LmF1dG9jb21wbGV0ZVByb3BSZWYsXG4gICAgICBwZXJzaXN0U2VsZWN0aW9uUmVmID0gX1JlYWN0JHVzZUNvbnRleHQ4LnBlcnNpc3RTZWxlY3Rpb25SZWYsXG4gICAgICBpc0NvbnRyb2xsZWRSZWYgPSBfUmVhY3QkdXNlQ29udGV4dDguaXNDb250cm9sbGVkUmVmO1xuXG4gIHZhciBvcHRpb25zID0gdXNlRGVzY2VuZGFudHMoQ29tYm9ib3hEZXNjZW5kYW50Q29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gb3B0aW9ucy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfcmVmNy52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbmF2aWdhdGlvblZhbHVlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dE9wdGlvbigpIHtcbiAgICAgIHZhciBhdEJvdHRvbSA9IGluZGV4ID09PSBvcHRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChhdEJvdHRvbSkge1xuICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUHJvcFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkIGJlY2F1c2Ugd2UgYXJlXG4gICAgICAgICAgLy8gYXV0b2NvbXBsZXRpbmcgYW5kIHRoZXkgbmVlZCB0byBiZSBhYmxlIHRvIGdldCBiYWNrIHRvIHdoYXRcbiAgICAgICAgICAvLyB0aGV5IGhhZCB0eXBlZCB3L28gaGF2aW5nIHRvIGJhY2tzcGFjZSBvdXQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3ljbGUgdGhyb3VnaFxuICAgICAgICAgIHJldHVybiBnZXRGaXJzdE9wdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHbyB0byB0aGUgbmV4dCBpdGVtIGluIHRoZSBsaXN0XG4gICAgICAgIHJldHVybiBvcHRpb25zWyhpbmRleCArIDEpICUgb3B0aW9ucy5sZW5ndGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByZXZpb3VzT3B0aW9uKCkge1xuICAgICAgdmFyIGF0VG9wID0gaW5kZXggPT09IDA7XG5cbiAgICAgIGlmIChhdFRvcCkge1xuICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUHJvcFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkIGJlY2F1c2Ugd2UgYXJlXG4gICAgICAgICAgLy8gYXV0b2NvbXBsZXRpbmcgYW5kIHRoZXkgbmVlZCB0byBiZSBhYmxlIHRvIGdldCBiYWNrIHRvIHdoYXRcbiAgICAgICAgICAvLyB0aGV5IGhhZCB0eXBlZCB3L28gaGF2aW5nIHRvIGJhY2tzcGFjZSBvdXQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3ljbGUgdGhyb3VnaFxuICAgICAgICAgIHJldHVybiBnZXRMYXN0T3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIGRpc3BsYXlpbmcgdGhlIHVzZXIncyB2YWx1ZSwgc28gZ28gc2VsZWN0IHRoZSBsYXN0IG9uZVxuICAgICAgICByZXR1cm4gZ2V0TGFzdE9wdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9ybWFsIGNhc2UsIHNlbGVjdCBwcmV2aW91c1xuICAgICAgICByZXR1cm4gb3B0aW9uc1soaW5kZXggLSAxICsgb3B0aW9ucy5sZW5ndGgpICUgb3B0aW9ucy5sZW5ndGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0T3B0aW9uKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBvcHRpb25zW29wdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgICAgIC8vIE9wZW5pbmcgYSBjbG9zZWQgbGlzdFxuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUsIHtcbiAgICAgICAgICAgIHBlcnNpc3RTZWxlY3Rpb246IHBlcnNpc3RTZWxlY3Rpb25SZWYuY3VycmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dE9wdGlvbigpO1xuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXh0ID8gbmV4dC52YWx1ZSA6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gQSBsb3Qgb2YgZHVwbGljYXRlIGNvZGUgd2l0aCBBcnJvd0Rvd24gdXAgbmV4dCwgSSdtIGFscmVhZHkgb3ZlciBpdC5cblxuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBJRExFKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbihOQVZJR0FURSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBnZXRQcmV2aW91c09wdGlvbigpO1xuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcmV2ID8gcHJldi52YWx1ZSA6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgY2FzZSBcIlBhZ2VVcFwiOlxuICAgICAgICAvLyBEb24ndCBzY3JvbGwgdGhlIHBhZ2VcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IElETEUpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFLCB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0Rmlyc3RPcHRpb24oKS52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgIGNhc2UgXCJQYWdlRG93blwiOlxuICAgICAgICAvLyBEb24ndCBzY3JvbGwgdGhlIHBhZ2VcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IElETEUpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFLCB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0TGFzdE9wdGlvbigpLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxuICAgICAgICBpZiAoc3RhdGUgIT09IElETEUpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKEVTQ0FQRSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gTkFWSUdBVElORyAmJiBuYXZpZ2F0aW9uVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRvIHN1Ym1pdCBmb3Jtc1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb25TZWxlY3QgJiYgb25TZWxlY3QobmF2aWdhdGlvblZhbHVlKTtcbiAgICAgICAgICB0cmFuc2l0aW9uKFNFTEVDVF9XSVRIX0tFWUJPQVJELCB7XG4gICAgICAgICAgICBpc0NvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZFJlZi5jdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUJsdXIoKSB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDkgPSB1c2VDb250ZXh0KENvbWJvYm94Q29udGV4dCksXG4gICAgICBzdGF0ZSA9IF9SZWFjdCR1c2VDb250ZXh0OS5zdGF0ZSxcbiAgICAgIHRyYW5zaXRpb24gPSBfUmVhY3QkdXNlQ29udGV4dDkudHJhbnNpdGlvbixcbiAgICAgIHBvcG92ZXJSZWYgPSBfUmVhY3QkdXNlQ29udGV4dDkucG9wb3ZlclJlZixcbiAgICAgIGlucHV0UmVmID0gX1JlYWN0JHVzZUNvbnRleHQ5LmlucHV0UmVmLFxuICAgICAgYnV0dG9uUmVmID0gX1JlYWN0JHVzZUNvbnRleHQ5LmJ1dHRvblJlZjtcblxuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICAgIHZhciBwb3BvdmVyID0gcG9wb3ZlclJlZi5jdXJyZW50O1xuICAgIHZhciBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgdmFyIGJ1dHRvbiA9IGJ1dHRvblJlZi5jdXJyZW50O1xuICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDsgLy8gd2Ugb24gd2FudCB0byBjbG9zZSBvbmx5IGlmIGZvY3VzIHByb3BzcyBvdXRzaWRlIHRoZSBjb21ib2JveFxuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09IGlucHV0ICYmIGFjdGl2ZUVsZW1lbnQgIT09IGJ1dHRvbiAmJiBwb3BvdmVyKSB7XG4gICAgICBpZiAocG9wb3Zlci5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAvLyBmb2N1cyBsYW5kZWQgaW5zaWRlIHRoZSBjb21ib2JveCwga2VlcCBpdCBvcGVuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gSU5URVJBQ1RJTkcpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKElOVEVSQUNUKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9jdXMgbGFuZGVkIG91dHNpZGUgdGhlIGNvbWJvYm94LCBjbG9zZSBpdC5cbiAgICAgICAgdHJhbnNpdGlvbihCTFVSKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFRoaXMgbWFuYWdlcyB0cmFuc2l0aW9ucyBiZXR3ZWVuIHN0YXRlcyB3aXRoIGEgYnVpbHQgaW4gcmVkdWNlciB0byBtYW5hZ2VcbiAqIHRoZSBkYXRhIHRoYXQgZ29lcyB3aXRoIHRob3NlIHRyYW5zaXRpb25zLlxuICpcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIHJlZHVjZXJcbiAqIEBwYXJhbSBpbml0aWFsRGF0YVxuICovXG5cblxuZnVuY3Rpb24gdXNlUmVkdWNlck1hY2hpbmUoY2hhcnQsIHJlZHVjZXIsIGluaXRpYWxEYXRhKSB7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSB1c2VTdGF0ZShjaGFydC5pbml0aWFsKSxcbiAgICAgIHN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VSZWR1Y2VyID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsRGF0YSksXG4gICAgICBkYXRhID0gX1JlYWN0JHVzZVJlZHVjZXJbMF0sXG4gICAgICBkaXNwYXRjaCA9IF9SZWFjdCR1c2VSZWR1Y2VyWzFdO1xuXG4gIHZhciB0cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkID09PSB2b2lkIDApIHtcbiAgICAgIHBheWxvYWQgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0YXRlID0gY2hhcnQuc3RhdGVzW3N0YXRlXTtcbiAgICB2YXIgbmV4dFN0YXRlID0gY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5vbltldmVudF07XG5cbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICBkaXNwYXRjaChfZXh0ZW5kcyh7XG4gICAgICAgIHR5cGU6IGV2ZW50LFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIG5leHRTdGF0ZTogc3RhdGVcbiAgICAgIH0sIHBheWxvYWQpKTtcbiAgICAgIHNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBbc3RhdGUsIGRhdGEsIHRyYW5zaXRpb25dO1xufVxuLyoqXG4gKiBXZSBkb24ndCB3YW50IHRvIHRyYWNrIHRoZSBhY3RpdmUgZGVzY2VuZGFudCB3aXRoIGluZGV4ZXMgYmVjYXVzZSBub3RoaW5nIGlzXG4gKiBtb3JlIGFubm95aW5nIGluIGEgY29tYm9ib3ggdGhhbiBoYXZpbmcgaXQgY2hhbmdlIHZhbHVlcyBSSUdIVCBBUyBZT1UgSElUXG4gKiBFTlRFUi4gVGhhdCBvbmx5IGhhcHBlbnMgaWYgeW91IHVzZSB0aGUgaW5kZXggYXMgeW91ciBkYXRhLCByYXRoZXIgdGhhblxuICogKnlvdXIgZGF0YSBhcyB5b3VyIGRhdGEqLiBXZSB1c2UgdGhpcyB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBiYXNlZCBvbiB0aGVcbiAqIHZhbHVlIG9mIGVhY2ggaXRlbS4gIFRoaXMgZnVuY3Rpb24gaXMgc2hvcnQsIHN3ZWV0LCBhbmQgZ29vZCBlbm91Z2jihKIgKEkgYWxzb1xuICogZG9uJ3Qga25vdyBob3cgaXQgd29ya3MsIHRicWgpXG4gKlxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MTIyNTcxL3NpbXBsZS1ub24tc2VjdXJlLWhhc2gtZnVuY3Rpb24tZm9yLWphdmFzY3JpcHRcbiAqIEBwYXJhbSBzdHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VIYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgX2NoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59IC8vIGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQobm9kZTogRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQpIHtcbi8vICAgbGV0IGFjdGl2ZUVsZW1lbnQ6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbi8vICAgdHJ5IHtcbi8vICAgICAvLyBJZiBFbGVtZW50LmdldFJvb3ROb2RlIGlzIHN1cHBvcnRlZCwgd2UnbGwgcmV0cmlldmUgZWl0aGVyIHRoZSByb290XG4vLyAgICAgLy8gRG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQuXG4vLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL2lzc3Vlcy83ODdcbi8vICAgICBhY3RpdmVFbGVtZW50ID0gKG5vZGU/LmdldFJvb3ROb2RlKCkgYXMgU2hhZG93Um9vdCB8IERvY3VtZW50KVxuLy8gICAgICAgLmFjdGl2ZUVsZW1lbnQ7XG4vLyAgIH0gZmluYWxseSB7XG4vLyAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQgfHwgKG5vZGU/Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQ7XG4vLyAgIH1cbi8vIH1cblxuXG5mdW5jdGlvbiBnZXREYXRhU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIEVzY2FwZSByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGBzdHJgXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2VzY2FwZS1yZWdleHAvYmxvYi81Y2U5MjNjMTUxMGM5ODAyYjNkYTk3MmM5MGI2ODYxZGQyODI5YjZiL2luZGV4LmpzXG4gKiBAcGFyYW0gc3RyXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVSZWdleHAoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy4qKz89XiE6JHt9KCl8W1xcXS9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBleHBvc2VzIGRhdGEgZm9yIGEgZ2l2ZW4gYENvbWJvYm94YCBjb21wb25lbnQgdG8gaXRzIGRlc2NlbmRhbnRzLlxuICpcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjdXNlY29tYm9ib3hjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gdXNlQ29tYm9ib3hDb250ZXh0KCkge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQxMCA9IHVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KSxcbiAgICAgIGlzRXhwYW5kZWQgPSBfUmVhY3QkdXNlQ29udGV4dDEwLmlzRXhwYW5kZWQsXG4gICAgICBjb21ib2JveElkID0gX1JlYWN0JHVzZUNvbnRleHQxMC5jb21ib2JveElkLFxuICAgICAgZGF0YSA9IF9SZWFjdCR1c2VDb250ZXh0MTAuZGF0YSxcbiAgICAgIHN0YXRlID0gX1JlYWN0JHVzZUNvbnRleHQxMC5zdGF0ZTtcblxuICB2YXIgbmF2aWdhdGlvblZhbHVlID0gZGF0YS5uYXZpZ2F0aW9uVmFsdWU7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNvbWJvYm94SWQsXG4gICAgICBpc0V4cGFuZGVkOiBpc0V4cGFuZGVkLFxuICAgICAgbmF2aWdhdGlvblZhbHVlOiBuYXZpZ2F0aW9uVmFsdWUgIT0gbnVsbCA/IG5hdmlnYXRpb25WYWx1ZSA6IG51bGwsXG4gICAgICBzdGF0ZTogc3RhdGVcbiAgICB9O1xuICB9LCBbY29tYm9ib3hJZCwgaXNFeHBhbmRlZCwgbmF2aWdhdGlvblZhbHVlLCBzdGF0ZV0pO1xufVxuLyoqXG4gKiBBIGhvb2sgdGhhdCBleHBvc2VzIGRhdGEgZm9yIGEgZ2l2ZW4gYENvbWJvYm94T3B0aW9uYCBjb21wb25lbnQgdG8gaXRzIGRlc2NlbmRhbnRzLlxuICpcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjdXNlY29tYm9ib3hjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gdXNlQ29tYm9ib3hPcHRpb25Db250ZXh0KCkge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQxMSA9IHVzZUNvbnRleHQoT3B0aW9uQ29udGV4dCksXG4gICAgICB2YWx1ZSA9IF9SZWFjdCR1c2VDb250ZXh0MTEudmFsdWUsXG4gICAgICBpbmRleCA9IF9SZWFjdCR1c2VDb250ZXh0MTEuaW5kZXg7XG5cbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9LCBbdmFsdWUsIGluZGV4XSk7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXZWxsIGFscmlnaHQsIHlvdSBtYWRlIGl0IGFsbCB0aGUgd2F5IGhlcmUgdG8gbGlrZSAxMTAwIGxpbmVzIG9mIGNvZGUgKGdlZXosXG4vLyB3aGF0IHRoZSBoZWNrPykuIEhhdmUgYSBncmVhdCBkYXkgOkRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUeXBlc1xuXG5leHBvcnQgeyBDb21ib2JveCwgQ29tYm9ib3hCdXR0b24sIENvbWJvYm94SW5wdXQsIENvbWJvYm94TGlzdCwgQ29tYm9ib3hPcHRpb24sIENvbWJvYm94T3B0aW9uVGV4dCwgQ29tYm9ib3hQb3BvdmVyLCBlc2NhcGVSZWdleHAsIHVzZUtleURvd24gYXMgdW5zdGFibGVfdXNlS2V5RG93biwgdXNlQ29tYm9ib3hDb250ZXh0LCB1c2VDb21ib2JveE9wdGlvbkNvbnRleHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/combobox/dist/reach-combobox.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/descendants/dist/reach-descendants.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@reach/descendants/dist/reach-descendants.esm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DescendantProvider\": function() { return /* binding */ DescendantProvider; },\n/* harmony export */   \"createDescendantContext\": function() { return /* binding */ createDescendantContext; },\n/* harmony export */   \"useDescendant\": function() { return /* binding */ useDescendant; },\n/* harmony export */   \"useDescendantKeyDown\": function() { return /* binding */ useDescendantKeyDown; },\n/* harmony export */   \"useDescendants\": function() { return /* binding */ useDescendants; },\n/* harmony export */   \"useDescendantsInit\": function() { return /* binding */ useDescendantsInit; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils_use_force_update__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils/use-force-update */ \"./node_modules/@reach/utils/use-force-update/dist/reach-utils-use-force-update.esm.js\");\n/* harmony import */ var _reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils/use-isomorphic-layout-effect */ \"./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\");\n/* harmony import */ var _reach_utils_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/utils/context */ \"./node_modules/@reach/utils/context/dist/reach-utils-context.esm.js\");\n/* harmony import */ var _reach_utils_noop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reach/utils/noop */ \"./node_modules/@reach/utils/noop/dist/reach-utils-noop.esm.js\");\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return (0,_reach_utils_context__WEBPACK_IMPORTED_MODULE_3__.createNamedContext)(name, _extends({\n    descendants: descendants,\n    registerDescendant: _reach_utils_noop__WEBPACK_IMPORTED_MODULE_4__.noop,\n    unregisterDescendant: _reach_utils_noop__WEBPACK_IMPORTED_MODULE_4__.noop\n  }, initialValue));\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = (0,_reach_utils_use_force_update__WEBPACK_IMPORTED_MODULE_1__.useForceUpdate)();\n\n  var _React$useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n}\n\nfunction useDescendants(ctx) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Ctx.Provider, {\n    value: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL2Rlc2NlbmRhbnRzL2Rpc3QvcmVhY2gtZGVzY2VuZGFudHMuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNuQjtBQUN1QjtBQUM1QjtBQUNqQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHdFQUFrQjtBQUMzQjtBQUNBLHdCQUF3QixtREFBSTtBQUM1QiwwQkFBMEIsbURBQUk7QUFDOUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvQkFBb0IsNkVBQWM7O0FBRWxDLDBCQUEwQixpREFBVTtBQUNwQztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTixFQUFFLG9HQUF5QjtBQUMzQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLFNBQVMsK0NBQVE7QUFDakI7O0FBRUE7QUFDQSxTQUFTLGlEQUFVO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQVc7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxTQUFTOztBQUVULGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxHQUFHOzs7QUFHWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBVztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQWE7QUFDbkMsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQixpREFBVTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUU4SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL2Rlc2NlbmRhbnRzL2Rpc3QvcmVhY2gtZGVzY2VuZGFudHMuZXNtLmpzPzYyMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCBjcmVhdGVFbGVtZW50LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tICdAcmVhY2gvdXRpbHMvdXNlLWZvcmNlLXVwZGF0ZSc7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnQHJlYWNoL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgY3JlYXRlTmFtZWRDb250ZXh0IH0gZnJvbSAnQHJlYWNoL3V0aWxzL2NvbnRleHQnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ0ByZWFjaC91dGlscy9ub29wJztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlbGVtZW50XCIsIFwiaW5kZXhcIl07XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NlbmRhbnRDb250ZXh0KG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAoaW5pdGlhbFZhbHVlID09PSB2b2lkIDApIHtcbiAgICBpbml0aWFsVmFsdWUgPSB7fTtcbiAgfVxuXG4gIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICByZXR1cm4gY3JlYXRlTmFtZWRDb250ZXh0KG5hbWUsIF9leHRlbmRzKHtcbiAgICBkZXNjZW5kYW50czogZGVzY2VuZGFudHMsXG4gICAgcmVnaXN0ZXJEZXNjZW5kYW50OiBub29wLFxuICAgIHVucmVnaXN0ZXJEZXNjZW5kYW50OiBub29wXG4gIH0sIGluaXRpYWxWYWx1ZSkpO1xufVxuLyoqXG4gKiBUaGlzIGhvb2sgcmVnaXN0ZXJzIG91ciBkZXNjZW5kYW50IGJ5IHBhc3NpbmcgaXQgaW50byBhbiBhcnJheS4gV2UgY2FuIHRoZW5cbiAqIHNlYXJjaCB0aGF0IGFycmF5IGJ5IHRvIGZpbmQgaXRzIGluZGV4IHdoZW4gcmVnaXN0ZXJpbmcgaXQgaW4gdGhlIGNvbXBvbmVudC5cbiAqIFdlIHVzZSB0aGlzIGZvciBmb2N1cyBtYW5hZ2VtZW50LCBrZXlib2FyZCBuYXZpZ2F0aW9uLCBhbmQgdHlwZWFoZWFkXG4gKiBmdW5jdGlvbmFsaXR5IGZvciBzb21lIGNvbXBvbmVudHMuXG4gKlxuICogVGhlIGhvb2sgYWNjZXB0cyB0aGUgZWxlbWVudCBub2RlIGFuZCAob3B0aW9uYWxseSkgYSBrZXkuIFRoZSBrZXkgaXMgdXNlZnVsXG4gKiBpZiBtdWx0aXBsZSBkZXNjZW5kYW50cyBoYXZlIGlkZW50aWNhbCB0ZXh0IHZhbHVlcyBhbmQgd2UgbmVlZCB0b1xuICogZGlmZmVyZW50aWF0ZSBzaWJsaW5ncyBmb3Igc29tZSByZWFzb24uXG4gKlxuICogT3VyIG1haW4gZ29hbHMgd2l0aCB0aGlzIGFyZTpcbiAqICAgMSkgbWF4aW11bSBjb21wb3NhYmlsaXR5LFxuICogICAyKSBtaW5pbWFsIEFQSSBmcmljdGlvblxuICogICAzKSBTU1IgY29tcGF0aWJpbGl0eSpcbiAqICAgNCkgY29uY3VycmVudCBzYWZlXG4gKiAgIDUpIGluZGV4IGFsd2F5cyB1cC10by1kYXRlIHdpdGggdGhlIHRyZWUgZGVzcGl0ZSBjaGFuZ2VzXG4gKiAgIDYpIHdvcmtzIHdpdGggbWVtb2l6YXRpb24gb2YgYW55IGNvbXBvbmVudCBpbiB0aGUgdHJlZSAoaG9wZWZ1bGx5KVxuICpcbiAqIEFzIGZvciBTU1IsIHRoZSBnb29kIG5ld3MgaXMgdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoZSBpbmRleCBvbiB0aGVcbiAqIHNlcnZlciBmb3IgbW9zdCB1c2UtY2FzZXMsIGFzIHdlIGFyZSBvbmx5IHVzaW5nIGl0IHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2ZcbiAqIGNvbXBvc2VkIGRlc2NlbmRhbnRzIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLiBIb3dldmVyLCBpbiB0aGUgZmV3IGNhc2VzIHdoZXJlXG4gKiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgd2UgY2FuIHJlcXVpcmUgYW4gZXhwbGljaXQgaW5kZXggZnJvbSB0aGUgYXBwLlxuICovXG5cblxuZnVuY3Rpb24gdXNlRGVzY2VuZGFudChkZXNjZW5kYW50LCBjb250ZXh0LCBpbmRleFByb3ApIHtcbiAgdmFyIGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcblxuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSB1c2VDb250ZXh0KGNvbnRleHQpLFxuICAgICAgcmVnaXN0ZXJEZXNjZW5kYW50ID0gX1JlYWN0JHVzZUNvbnRleHQucmVnaXN0ZXJEZXNjZW5kYW50LFxuICAgICAgdW5yZWdpc3RlckRlc2NlbmRhbnQgPSBfUmVhY3QkdXNlQ29udGV4dC51bnJlZ2lzdGVyRGVzY2VuZGFudCxcbiAgICAgIGRlc2NlbmRhbnRzID0gX1JlYWN0JHVzZUNvbnRleHQuZGVzY2VuZGFudHM7IC8vIFRoaXMgd2lsbCBpbml0aWFsbHkgcmV0dXJuIC0xIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWdpc3RlcmVkIHRoZSBkZXNjZW5kYW50XG4gIC8vIG9uIHRoZSBmaXJzdCByZW5kZXIuIEFmdGVyIHdlIHJlZ2lzdGVyLCB0aGlzIHdpbGwgdGhlbiByZXR1cm4gdGhlIGNvcnJlY3RcbiAgLy8gaW5kZXggb24gdGhlIGZvbGxvd2luZyByZW5kZXIgYW5kIHdlIHdpbGwgcmUtcmVnaXN0ZXIgZGVzY2VuZGFudHMgc28gdGhhdFxuICAvLyBldmVyeXRoaW5nIGlzIHVwLXRvLWRhdGUgYmVmb3JlIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIGEgY29sbGVjdGlvbi5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4UHJvcCAhPSBudWxsID8gaW5kZXhQcm9wIDogZGVzY2VuZGFudHMuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCA9PT0gZGVzY2VuZGFudC5lbGVtZW50O1xuICB9KTsgLy8gUHJldmVudCBhbnkgZmxhc2hpbmdcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRlc2NlbmRhbnQuZWxlbWVudCkgZm9yY2VVcGRhdGUoKTtcbiAgICByZWdpc3RlckRlc2NlbmRhbnQoX2V4dGVuZHMoe30sIGRlc2NlbmRhbnQsIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5yZWdpc3RlckRlc2NlbmRhbnQoZGVzY2VuZGFudC5lbGVtZW50KTtcbiAgICB9O1xuICB9LCBbZGVzY2VuZGFudCwgZm9yY2VVcGRhdGUsIGluZGV4LCByZWdpc3RlckRlc2NlbmRhbnQsIHVucmVnaXN0ZXJEZXNjZW5kYW50XS5jb25jYXQoT2JqZWN0LnZhbHVlcyhkZXNjZW5kYW50KSkpO1xuICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHVzZURlc2NlbmRhbnRzSW5pdCgpIHtcbiAgcmV0dXJuIHVzZVN0YXRlKFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVzY2VuZGFudHMoY3R4KSB7XG4gIHJldHVybiB1c2VDb250ZXh0KGN0eCkuZGVzY2VuZGFudHM7XG59XG5cbmZ1bmN0aW9uIERlc2NlbmRhbnRQcm92aWRlcihfcmVmKSB7XG4gIHZhciBDdHggPSBfcmVmLmNvbnRleHQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBpdGVtcyA9IF9yZWYuaXRlbXMsXG4gICAgICBzZXQgPSBfcmVmLnNldDtcbiAgdmFyIHJlZ2lzdGVyRGVzY2VuZGFudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBlbGVtZW50ID0gX3JlZjIuZWxlbWVudCxcbiAgICAgICAgZXhwbGljaXRJbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIF9leGNsdWRlZCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXQoZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICB2YXIgbmV3SXRlbXM7XG5cbiAgICAgIGlmIChleHBsaWNpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChpdGVtcywgW19leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBpbmRleDogZXhwbGljaXRJbmRleFxuICAgICAgICB9KV0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGl0ZW1zLCByZWdpc3RlciBhdCBpbmRleCAwIGFuZCBiYWlsLlxuICAgICAgICBuZXdJdGVtcyA9IFtfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgfSldO1xuICAgICAgfSBlbHNlIGlmIChpdGVtcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgICB9KSkge1xuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIGp1c3QgdXNlIHRoZSBzYW1lIGFycmF5XG4gICAgICAgIG5ld0l0ZW1zID0gaXRlbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHJlZ2lzdGVyaW5nIGEgZGVzY2VuZGFudCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgaW5zZXJ0IGluXG4gICAgICAgIC8vIGludG8gdGhlIGFycmF5IGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgaXQgYXBwZWFycyBpbiB0aGUgRE9NLiBTbyBhc1xuICAgICAgICAvLyBuZXcgZGVzY2VuZGFudHMgYXJlIGFkZGVkIG9yIG1heWJlIHNvbWUgYXJlIHJlbW92ZWQsIHdlIGFsd2F5cyBrbm93XG4gICAgICAgIC8vIHRoYXQgdGhlIGFycmF5IGlzIHVwLXRvLWRhdGUgYW5kIGNvcnJlY3QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNvIGhlcmUgd2UgbG9vayBhdCBvdXIgcmVnaXN0ZXJlZCBkZXNjZW5kYW50cyBhbmQgc2VlIGlmIHRoZSBuZXdcbiAgICAgICAgLy8gZWxlbWVudCB3ZSBhcmUgYWRkaW5nIGFwcGVhcnMgZWFybGllciB0aGFuIGFuIGV4aXN0aW5nIGRlc2NlbmRhbnQnc1xuICAgICAgICAvLyBET00gbm9kZSB2aWEgYG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25gLiBJZiBpdCBkb2VzLCB3ZSBpbnNlcnRcbiAgICAgICAgLy8gdGhlIG5ldyBlbGVtZW50IGF0IHRoaXMgaW5kZXguIEJlY2F1c2UgYHJlZ2lzdGVyRGVzY2VuZGFudGAgd2lsbCBiZVxuICAgICAgICAvLyBjYWxsZWQgaW4gYW4gZWZmZWN0IGV2ZXJ5IHRpbWUgdGhlIGRlc2NlbmRhbnRzIHN0YXRlIHZhbHVlIGNoYW5nZXMsXG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBzdXJlIHRoYXQgdGhpcyBpbmRleCBpcyBhY2N1cmF0ZSB3aGVuIGRlc2NlbmRlbnRcbiAgICAgICAgLy8gZWxlbWVudHMgY29tZSBvciBnbyBmcm9tIG91ciBjb21wb25lbnQuXG4gICAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmICghaXRlbS5lbGVtZW50IHx8ICFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBEb2VzIHRoaXMgZWxlbWVudCdzIERPTSBub2RlIGFwcGVhciBiZWZvcmUgYW5vdGhlciBpdGVtIGluIHRoZVxuICAgICAgICAgIC8vIGFycmF5IGluIG91ciBET00gdHJlZT8gSWYgc28sIHJldHVybiB0cnVlIHRvIGdyYWIgdGhlIGluZGV4IGF0XG4gICAgICAgICAgLy8gdGhpcyBwb2ludCBpbiB0aGUgYXJyYXkgc28gd2Uga25vdyB3aGVyZSB0byBpbnNlcnQgdGhlIG5ld1xuICAgICAgICAgIC8vIGVsZW1lbnQuXG5cblxuICAgICAgICAgIHJldHVybiBCb29sZWFuKGl0ZW0uZWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5ld0l0ZW0gPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pOyAvLyBJZiBhbiBpbmRleCBpcyBub3QgZm91bmQgd2Ugd2lsbCBwdXNoIHRoZSBlbGVtZW50IHRvIHRoZSBlbmQuXG5cblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgbmV3SXRlbXMgPSBbXS5jb25jYXQoaXRlbXMsIFtuZXdJdGVtXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SXRlbXMgPSBbXS5jb25jYXQoaXRlbXMuc2xpY2UoMCwgaW5kZXgpLCBbbmV3SXRlbV0sIGl0ZW1zLnNsaWNlKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIC8vIHNldCBpcyBhIHN0YXRlIHNldHRlciBpbml0aWFsaXplZCBieSB0aGUgdXNlRGVzY2VuZGFudHNJbml0IGhvb2suXG4gIC8vIFdlIGNhbiBzYWZlbHkgaWdub3JlIHRoZSBsaW50IHdhcm5pbmcgaGVyZSBiZWNhdXNlIGl0IHdpbGwgbm90IGNoYW5nZVxuICAvLyBiZXR3ZWVuIHJlbmRlcnMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW10pO1xuICB2YXIgdW5yZWdpc3RlckRlc2NlbmRhbnQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldChmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgIT09IGl0ZW0uZWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAvLyBzZXQgaXMgYSBzdGF0ZSBzZXR0ZXIgaW5pdGlhbGl6ZWQgYnkgdGhlIHVzZURlc2NlbmRhbnRzSW5pdCBob29rLlxuICAvLyBXZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgbGludCB3YXJuaW5nIGhlcmUgYmVjYXVzZSBpdCB3aWxsIG5vdCBjaGFuZ2VcbiAgLy8gYmV0d2VlbiByZW5kZXJzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEN0eC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc2NlbmRhbnRzOiBpdGVtcyxcbiAgICAgICAgcmVnaXN0ZXJEZXNjZW5kYW50OiByZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgICAgIHVucmVnaXN0ZXJEZXNjZW5kYW50OiB1bnJlZ2lzdGVyRGVzY2VuZGFudFxuICAgICAgfTtcbiAgICB9LCBbaXRlbXMsIHJlZ2lzdGVyRGVzY2VuZGFudCwgdW5yZWdpc3RlckRlc2NlbmRhbnRdKVxuICB9LCBjaGlsZHJlbik7XG59XG4vKipcbiAqIFRlc3RpbmcgdGhpcyBhcyBhbiBhYnN0cmFjdGlvbiBmb3IgY29tcG91bmQgY29tcG9uZW50cyB0aGF0IHVzZSBrZXlib2FyZFxuICogbmF2aWdhdGlvbi4gSG9waW5nIHRoaXMgd2lsbCBoZWxwIHVzIHByZXZlbnQgYnVncyBhbmQgbWlzbWF0Y2hlZCBiZWhhdmlvclxuICogYWNyb3NzIHZhcmlvdXMgY29tcG9uZW50cywgYnV0IGl0IG1heSBhbHNvIHByb3ZlIHRvIGJlIHRvbyBtZXNzeSBvZiBhblxuICogYWJzdHJhY3Rpb24gaW4gdGhlIGVuZC5cbiAqXG4gKiBDdXJyZW50bHkgdXNlZCBpbjpcbiAqICAgLSBUYWJzXG4gKiAgIC0gQWNjb3JkaW9uXG4gKlxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VEZXNjZW5kYW50S2V5RG93bihjb250ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDIgPSB1c2VDb250ZXh0KGNvbnRleHQpLFxuICAgICAgZGVzY2VuZGFudHMgPSBfUmVhY3QkdXNlQ29udGV4dDIuZGVzY2VuZGFudHM7XG5cbiAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayxcbiAgICAgIGN1cnJlbnRJbmRleCA9IG9wdGlvbnMuY3VycmVudEluZGV4LFxuICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXIsXG4gICAgICBfb3B0aW9ucyRrZXkgPSBvcHRpb25zLmtleSxcbiAgICAgIGtleSA9IF9vcHRpb25zJGtleSA9PT0gdm9pZCAwID8gXCJpbmRleFwiIDogX29wdGlvbnMka2V5LFxuICAgICAgX29wdGlvbnMkb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgb3JpZW50YXRpb24gPSBfb3B0aW9ucyRvcmllbnRhdGlvbiA9PT0gdm9pZCAwID8gXCJ2ZXJ0aWNhbFwiIDogX29wdGlvbnMkb3JpZW50YXRpb24sXG4gICAgICBfb3B0aW9ucyRyb3RhdGUgPSBvcHRpb25zLnJvdGF0ZSxcbiAgICAgIHJvdGF0ZSA9IF9vcHRpb25zJHJvdGF0ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdGF0ZSxcbiAgICAgIF9vcHRpb25zJHJ0bCA9IG9wdGlvbnMucnRsLFxuICAgICAgcnRsID0gX29wdGlvbnMkcnRsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJ0bDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIVtcIkFycm93RG93blwiLCBcIkFycm93VXBcIiwgXCJBcnJvd0xlZnRcIiwgXCJBcnJvd1JpZ2h0XCIsIFwiUGFnZVVwXCIsIFwiUGFnZURvd25cIiwgXCJIb21lXCIsIFwiRW5kXCJdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBjdXJyZW50SW5kZXggIT0gbnVsbCA/IGN1cnJlbnRJbmRleCA6IC0xOyAvLyBJZiB3ZSB1c2UgYSBmaWx0ZXIgZnVuY3Rpb24sIHdlIG5lZWQgdG8gcmUtaW5kZXggb3VyIGRlc2NlbmRhbnRzIGFycmF5XG4gICAgLy8gc28gdGhhdCBmaWx0ZXJlZCBkZXNjZW5kZW50IGVsZW1lbnRzIGFyZW4ndCBzZWxlY3RlZC5cblxuICAgIHZhciBzZWxlY3RhYmxlRGVzY2VuZGFudHMgPSBmaWx0ZXIgPyBkZXNjZW5kYW50cy5maWx0ZXIoZmlsdGVyKSA6IGRlc2NlbmRhbnRzOyAvLyBXZSBuZWVkIHNvbWUgb3B0aW9ucyBmb3IgYW55IG9mIHRoaXMgdG8gd29yayFcblxuICAgIGlmICghc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RhYmxlSW5kZXggPSBzZWxlY3RhYmxlRGVzY2VuZGFudHMuZmluZEluZGV4KGZ1bmN0aW9uIChkZXNjZW5kYW50KSB7XG4gICAgICByZXR1cm4gZGVzY2VuZGFudC5pbmRleCA9PT0gY3VycmVudEluZGV4O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dE9wdGlvbigpIHtcbiAgICAgIHZhciBhdEJvdHRvbSA9IGluZGV4ID09PSBnZXRMYXN0T3B0aW9uKCkuaW5kZXg7XG4gICAgICByZXR1cm4gYXRCb3R0b20gPyByb3RhdGUgPyBnZXRGaXJzdE9wdGlvbigpIDogc2VsZWN0YWJsZURlc2NlbmRhbnRzW3NlbGVjdGFibGVJbmRleF0gOiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbKHNlbGVjdGFibGVJbmRleCArIDEpICUgc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJldmlvdXNPcHRpb24oKSB7XG4gICAgICB2YXIgYXRUb3AgPSBpbmRleCA9PT0gZ2V0Rmlyc3RPcHRpb24oKS5pbmRleDtcbiAgICAgIHJldHVybiBhdFRvcCA/IHJvdGF0ZSA/IGdldExhc3RPcHRpb24oKSA6IHNlbGVjdGFibGVEZXNjZW5kYW50c1tzZWxlY3RhYmxlSW5kZXhdIDogc2VsZWN0YWJsZURlc2NlbmRhbnRzWyhzZWxlY3RhYmxlSW5kZXggLSAxICsgc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCkgJSBzZWxlY3RhYmxlRGVzY2VuZGFudHMubGVuZ3RoXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiIHx8IG9yaWVudGF0aW9uID09PSBcImJvdGhcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0T3B0aW9uKCk7XG4gICAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gbmV4dCA6IG5leHRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgfHwgb3JpZW50YXRpb24gPT09IFwiYm90aFwiKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgcHJldiA9IGdldFByZXZpb3VzT3B0aW9uKCk7XG4gICAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gcHJldiA6IHByZXZba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiIHx8IG9yaWVudGF0aW9uID09PSBcImJvdGhcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG5leHRPclByZXYgPSAocnRsID8gZ2V0TmV4dE9wdGlvbiA6IGdldFByZXZpb3VzT3B0aW9uKSgpO1xuICAgICAgICAgIGNhbGxiYWNrKGtleSA9PT0gXCJvcHRpb25cIiA/IG5leHRPclByZXYgOiBuZXh0T3JQcmV2W2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgfHwgb3JpZW50YXRpb24gPT09IFwiYm90aFwiKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgcHJldk9yTmV4dCA9IChydGwgPyBnZXRQcmV2aW91c09wdGlvbiA6IGdldE5leHRPcHRpb24pKCk7XG4gICAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gcHJldk9yTmV4dCA6IHByZXZPck5leHRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBhZ2VVcFwiOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcHJldk9yRmlyc3QgPSAoZXZlbnQuY3RybEtleSA/IGdldFByZXZpb3VzT3B0aW9uIDogZ2V0Rmlyc3RPcHRpb24pKCk7XG4gICAgICAgIGNhbGxiYWNrKGtleSA9PT0gXCJvcHRpb25cIiA/IHByZXZPckZpcnN0IDogcHJldk9yRmlyc3Rba2V5XSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZmlyc3QgPSBnZXRGaXJzdE9wdGlvbigpO1xuICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBmaXJzdCA6IGZpcnN0W2tleV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBhZ2VEb3duXCI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBuZXh0T3JMYXN0ID0gKGV2ZW50LmN0cmxLZXkgPyBnZXROZXh0T3B0aW9uIDogZ2V0TGFzdE9wdGlvbikoKTtcbiAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gbmV4dE9yTGFzdCA6IG5leHRPckxhc3Rba2V5XSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBsYXN0ID0gZ2V0TGFzdE9wdGlvbigpO1xuICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBsYXN0IDogbGFzdFtrZXldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgeyBEZXNjZW5kYW50UHJvdmlkZXIsIGNyZWF0ZURlc2NlbmRhbnRDb250ZXh0LCB1c2VEZXNjZW5kYW50LCB1c2VEZXNjZW5kYW50S2V5RG93biwgdXNlRGVzY2VuZGFudHMsIHVzZURlc2NlbmRhbnRzSW5pdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/descendants/dist/reach-descendants.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/observe-rect/dist/observe-rect.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@reach/observe-rect/dist/observe-rect.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar props = [\"bottom\", \"height\", \"left\", \"right\", \"top\", \"width\"];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (observeRect);\n//# sourceMappingURL=observe-rect.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL29ic2VydmUtcmVjdC9kaXN0L29ic2VydmUtcmVjdC5lc20uanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFELG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxXQUFXLEVBQUM7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC9vYnNlcnZlLXJlY3QvZGlzdC9vYnNlcnZlLXJlY3QuZXNtLmpzPzA5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb3BzID0gW1wiYm90dG9tXCIsIFwiaGVpZ2h0XCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwid2lkdGhcIl07XG5cbnZhciByZWN0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlY3RDaGFuZ2VkKGEsIGIpIHtcbiAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgIGEgPSB7fTtcbiAgfVxuXG4gIGlmIChiID09PSB2b2lkIDApIHtcbiAgICBiID0ge307XG4gIH1cblxuICByZXR1cm4gcHJvcHMuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBhW3Byb3BdICE9PSBiW3Byb3BdO1xuICB9KTtcbn07XG5cbnZhciBvYnNlcnZlZE5vZGVzID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcbnZhciByYWZJZDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcbiAgdmFyIGNoYW5nZWRTdGF0ZXMgPSBbXTtcbiAgb2JzZXJ2ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgIHZhciBuZXdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChyZWN0Q2hhbmdlZChuZXdSZWN0LCBzdGF0ZS5yZWN0KSkge1xuICAgICAgc3RhdGUucmVjdCA9IG5ld1JlY3Q7XG4gICAgICBjaGFuZ2VkU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH1cbiAgfSk7XG4gIGNoYW5nZWRTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBzdGF0ZS5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHJldHVybiBjYihzdGF0ZS5yZWN0KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pO1xufTtcblxuZnVuY3Rpb24gb2JzZXJ2ZVJlY3Qobm9kZSwgY2IpIHtcbiAgcmV0dXJuIHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbiBvYnNlcnZlKCkge1xuICAgICAgdmFyIHdhc0VtcHR5ID0gb2JzZXJ2ZWROb2Rlcy5zaXplID09PSAwO1xuXG4gICAgICBpZiAob2JzZXJ2ZWROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgb2JzZXJ2ZWROb2Rlcy5nZXQobm9kZSkuY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JzZXJ2ZWROb2Rlcy5zZXQobm9kZSwge1xuICAgICAgICAgIHJlY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBoYXNSZWN0Q2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgY2FsbGJhY2tzOiBbY2JdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FzRW1wdHkpIHJ1bigpO1xuICAgIH0sXG4gICAgdW5vYnNlcnZlOiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBvYnNlcnZlZE5vZGVzLmdldChub2RlKTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuY2FsbGJhY2tzLmluZGV4T2YoY2IpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkgc3RhdGUuY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSB0aGUgbm9kZSByZWZlcmVuY2VcblxuICAgICAgICBpZiAoIXN0YXRlLmNhbGxiYWNrcy5sZW5ndGgpIG9ic2VydmVkTm9kZXNbXCJkZWxldGVcIl0obm9kZSk7IC8vIFN0b3AgdGhlIGxvb3BcblxuICAgICAgICBpZiAoIW9ic2VydmVkTm9kZXMuc2l6ZSkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JzZXJ2ZVJlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlLXJlY3QuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/observe-rect/dist/observe-rect.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/popover/dist/reach-popover.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@reach/popover/dist/reach-popover.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Popover\": function() { return /* binding */ Popover; },\n/* harmony export */   \"getCollisions\": function() { return /* binding */ getCollisions; },\n/* harmony export */   \"positionDefault\": function() { return /* binding */ positionDefault; },\n/* harmony export */   \"positionMatchWidth\": function() { return /* binding */ positionMatchWidth; },\n/* harmony export */   \"positionRight\": function() { return /* binding */ positionRight; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_portal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reach/portal */ \"./node_modules/@reach/portal/dist/reach-portal.esm.js\");\n/* harmony import */ var _reach_rect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reach/rect */ \"./node_modules/@reach/rect/dist/reach-rect.esm.js\");\n/* harmony import */ var _reach_utils_owner_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils/owner-document */ \"./node_modules/@reach/utils/owner-document/dist/reach-utils-owner-document.esm.js\");\n/* harmony import */ var _reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils/compose-refs */ \"./node_modules/@reach/utils/compose-refs/dist/reach-utils-compose-refs.esm.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tabbable */ \"./node_modules/tabbable/index.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(tabbable__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"as\", \"targetRef\", \"position\", \"unstable_observableRefs\"];\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Popover\n */\nvar Popover = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Popover(props, ref) {\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_reach_portal__WEBPACK_IMPORTED_MODULE_4__.Portal, null, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PopoverImpl, _extends({\n    ref: ref\n  }, props)));\n});\n\nif (true) {\n  Popover.displayName = \"Popover\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\n * PopoverImpl\n *\n * Popover is conditionally rendered so we can't start measuring until it shows\n * up, so useRect needs to live down here not up in Popover\n */\n\n\nvar PopoverImpl = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function PopoverImpl(_ref, forwardedRef) {\n  var _ref$as = _ref.as,\n      Comp = _ref$as === void 0 ? \"div\" : _ref$as,\n      targetRef = _ref.targetRef,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? positionDefault : _ref$position,\n      _ref$unstable_observa = _ref.unstable_observableRefs,\n      unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var popoverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var popoverRect = (0,_reach_rect__WEBPACK_IMPORTED_MODULE_5__.useRect)(popoverRef, {\n    observe: !props.hidden\n  });\n  var targetRect = (0,_reach_rect__WEBPACK_IMPORTED_MODULE_5__.useRect)(targetRef, {\n    observe: !props.hidden\n  });\n  var ref = (0,_reach_utils_compose_refs__WEBPACK_IMPORTED_MODULE_2__.useComposedRefs)(popoverRef, forwardedRef);\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Comp, _extends({\n    \"data-reach-popover\": \"\",\n    ref: ref\n  }, props, {\n    style: _extends({\n      position: \"absolute\"\n    }, getStyles.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props.style)\n  }));\n});\n\nif (true) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction getStyles(position, targetRect, popoverRect) {\n  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    unstable_observableRefs[_key - 3] = arguments[_key];\n  }\n\n  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function (ref) {\n    return ref.current;\n  }))) : {\n    visibility: \"hidden\"\n  };\n}\n\nfunction getTopPosition(targetRect, popoverRect, isDirectionUp) {\n  return {\n    top: isDirectionUp ? targetRect.top - popoverRect.height + window.pageYOffset + \"px\" : targetRect.top + targetRect.height + window.pageYOffset + \"px\"\n  };\n}\n\nvar positionDefault = function positionDefault(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions = getCollisions(targetRect, popoverRect),\n      directionRight = _getCollisions.directionRight,\n      directionUp = _getCollisions.directionUp;\n\n  return _extends({\n    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + \"px\" : targetRect.left + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect, directionUp));\n};\n\nvar positionRight = function positionRight(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions2 = getCollisions(targetRect, popoverRect),\n      directionLeft = _getCollisions2.directionLeft,\n      directionUp = _getCollisions2.directionUp;\n\n  return _extends({\n    left: directionLeft ? targetRect.left + window.pageXOffset + \"px\" : targetRect.right - popoverRect.width + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect, directionUp));\n};\n\nvar positionMatchWidth = function positionMatchWidth(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions3 = getCollisions(targetRect, popoverRect),\n      directionUp = _getCollisions3.directionUp;\n\n  return _extends({\n    width: targetRect.width,\n    left: targetRect.left\n  }, getTopPosition(targetRect, popoverRect, directionUp));\n};\n\nfunction getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {\n  if (offsetLeft === void 0) {\n    offsetLeft = 0;\n  }\n\n  if (offsetBottom === void 0) {\n    offsetBottom = 0;\n  }\n\n  var collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0\n  };\n  var directionRight = collisions.right && !collisions.left;\n  var directionLeft = collisions.left && !collisions.right;\n  var directionUp = collisions.bottom && !collisions.top;\n  var directionDown = collisions.top && !collisions.bottom;\n  return {\n    directionRight: directionRight,\n    directionLeft: directionLeft,\n    directionUp: directionUp,\n    directionDown: directionDown\n  };\n} // Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\n\n\nfunction useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {\n  var ownerDocument = (0,_reach_utils_owner_document__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(triggerRef.current);\n\n  function handleKeyDown(event) {\n    if (event.key === \"Tab\" && popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current).length === 0) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return function () {\n      ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    var elements = tabbable__WEBPACK_IMPORTED_MODULE_3___default()(ownerDocument);\n    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;\n    var elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;\n  }\n\n  function focusFirstPopoverTabbable(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current);\n\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    var inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;\n\n    if (inPopover) {\n      var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current);\n      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);\n    }\n\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event) {\n    var elementAfterTrigger = getElementAfterTrigger();\n\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event) {\n    if (!event.shiftKey) return;\n    var elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current);\n    var last = elements && elements[elements.length - 1];\n\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current);\n\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n\n    return false;\n  }\n\n  function focusTriggerRef(event) {\n    var _triggerRef$current;\n\n    event.preventDefault();\n    (_triggerRef$current = triggerRef.current) == null ? void 0 : _triggerRef$current.focus();\n  }\n\n  function tabbedToBrowserChrome(event) {\n    var elements = popoverRef.current ? tabbable__WEBPACK_IMPORTED_MODULE_3___default()(ownerDocument).filter(function (element) {\n      return !popoverRef.current.contains(element);\n    }) : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return event.target === tabbable__WEBPACK_IMPORTED_MODULE_3___default()(ownerDocument)[0];\n  }\n\n  var restoreTabIndexTuplÃ©s = [];\n\n  function disableTabbablesInPopover() {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_3___default()(popoverRef.current);\n\n    if (elements) {\n      elements.forEach(function (element) {\n        restoreTabIndexTuplÃ©s.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplÃ©s.forEach(function (_ref2) {\n      var element = _ref2[0],\n          tabIndex = _ref2[1];\n      element.tabIndex = tabIndex;\n    });\n  }\n} ////////////////////////////////////////////////////////////////////////////////\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popover);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3BvcG92ZXIvZGlzdC9yZWFjaC1wb3BvdmVyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXFFO0FBQzlCO0FBQ0Q7QUFDeUI7QUFDSDtBQUM1Qjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQVU7QUFDckMsc0JBQXNCLG9EQUFhLENBQUMsaURBQU0scUJBQXFCLG9EQUFhO0FBQzVFO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsSUFBSSxJQUFxQztBQUN6QztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSwrQkFBK0IsaURBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNkNBQU07QUFDekIsb0JBQW9CLG9EQUFPO0FBQzNCO0FBQ0EsR0FBRztBQUNILG1CQUFtQixvREFBTztBQUMxQjtBQUNBLEdBQUc7QUFDSCxZQUFZLDBFQUFlO0FBQzNCO0FBQ0Esc0JBQXNCLG9EQUFhO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSw0R0FBNEcsYUFBYTtBQUN6SDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esc0JBQXNCLDZFQUFnQjs7QUFFdEM7QUFDQSxxREFBcUQsK0NBQVE7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQiwrQ0FBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsK0NBQVE7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQywrQ0FBUTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsK0NBQVE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QywrQ0FBUTs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsK0NBQVE7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQVE7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsK0NBQVE7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFOztBQUVGLCtEQUFlLE9BQU8sRUFBQztBQUMrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL3BvcG92ZXIvZGlzdC9yZWFjaC1wb3BvdmVyLmVzbS5qcz82YmNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcndhcmRSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnQHJlYWNoL3BvcnRhbCc7XG5pbXBvcnQgeyB1c2VSZWN0IH0gZnJvbSAnQHJlYWNoL3JlY3QnO1xuaW1wb3J0IHsgZ2V0T3duZXJEb2N1bWVudCB9IGZyb20gJ0ByZWFjaC91dGlscy9vd25lci1kb2N1bWVudCc7XG5pbXBvcnQgeyB1c2VDb21wb3NlZFJlZnMgfSBmcm9tICdAcmVhY2gvdXRpbHMvY29tcG9zZS1yZWZzJztcbmltcG9ydCB0YWJiYWJsZSBmcm9tICd0YWJiYWJsZSc7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiYXNcIiwgXCJ0YXJnZXRSZWZcIiwgXCJwb3NpdGlvblwiLCBcInVuc3RhYmxlX29ic2VydmFibGVSZWZzXCJdO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBQb3BvdmVyXG4gKi9cbnZhciBQb3BvdmVyID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gUG9wb3Zlcihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChQb3J0YWwsIG51bGwsIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFBvcG92ZXJJbXBsLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgcHJvcHMpKSk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBQb3BvdmVyLmRpc3BsYXlOYW1lID0gXCJQb3BvdmVyXCI7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUG9wb3ZlckltcGxcbiAqXG4gKiBQb3BvdmVyIGlzIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgc28gd2UgY2FuJ3Qgc3RhcnQgbWVhc3VyaW5nIHVudGlsIGl0IHNob3dzXG4gKiB1cCwgc28gdXNlUmVjdCBuZWVkcyB0byBsaXZlIGRvd24gaGVyZSBub3QgdXAgaW4gUG9wb3ZlclxuICovXG5cblxudmFyIFBvcG92ZXJJbXBsID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gUG9wb3ZlckltcGwoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmJGFzID0gX3JlZi5hcyxcbiAgICAgIENvbXAgPSBfcmVmJGFzID09PSB2b2lkIDAgPyBcImRpdlwiIDogX3JlZiRhcyxcbiAgICAgIHRhcmdldFJlZiA9IF9yZWYudGFyZ2V0UmVmLFxuICAgICAgX3JlZiRwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiA9IF9yZWYkcG9zaXRpb24gPT09IHZvaWQgMCA/IHBvc2l0aW9uRGVmYXVsdCA6IF9yZWYkcG9zaXRpb24sXG4gICAgICBfcmVmJHVuc3RhYmxlX29ic2VydmEgPSBfcmVmLnVuc3RhYmxlX29ic2VydmFibGVSZWZzLFxuICAgICAgdW5zdGFibGVfb2JzZXJ2YWJsZVJlZnMgPSBfcmVmJHVuc3RhYmxlX29ic2VydmEgPT09IHZvaWQgMCA/IFtdIDogX3JlZiR1bnN0YWJsZV9vYnNlcnZhLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIHZhciBwb3BvdmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcG9wb3ZlclJlY3QgPSB1c2VSZWN0KHBvcG92ZXJSZWYsIHtcbiAgICBvYnNlcnZlOiAhcHJvcHMuaGlkZGVuXG4gIH0pO1xuICB2YXIgdGFyZ2V0UmVjdCA9IHVzZVJlY3QodGFyZ2V0UmVmLCB7XG4gICAgb2JzZXJ2ZTogIXByb3BzLmhpZGRlblxuICB9KTtcbiAgdmFyIHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhwb3BvdmVyUmVmLCBmb3J3YXJkZWRSZWYpO1xuICB1c2VTaW11bGF0ZVRhYk5hdmlnYXRpb25Gb3JSZWFjdFRyZWUodGFyZ2V0UmVmLCBwb3BvdmVyUmVmKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KENvbXAsIF9leHRlbmRzKHtcbiAgICBcImRhdGEtcmVhY2gtcG9wb3ZlclwiOiBcIlwiLFxuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LCBnZXRTdHlsZXMuYXBwbHkodm9pZCAwLCBbcG9zaXRpb24sIHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0XS5jb25jYXQodW5zdGFibGVfb2JzZXJ2YWJsZVJlZnMpKSwgcHJvcHMuc3R5bGUpXG4gIH0pKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFBvcG92ZXJJbXBsLmRpc3BsYXlOYW1lID0gXCJQb3BvdmVySW1wbFwiO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbmZ1bmN0aW9uIGdldFN0eWxlcyhwb3NpdGlvbiwgdGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHVuc3RhYmxlX29ic2VydmFibGVSZWZzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB1bnN0YWJsZV9vYnNlcnZhYmxlUmVmc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gcG9wb3ZlclJlY3QgPyBwb3NpdGlvbi5hcHBseSh2b2lkIDAsIFt0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdF0uY29uY2F0KHVuc3RhYmxlX29ic2VydmFibGVSZWZzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICB9KSkpIDoge1xuICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wUG9zaXRpb24odGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QsIGlzRGlyZWN0aW9uVXApIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGlzRGlyZWN0aW9uVXAgPyB0YXJnZXRSZWN0LnRvcCAtIHBvcG92ZXJSZWN0LmhlaWdodCArIHdpbmRvdy5wYWdlWU9mZnNldCArIFwicHhcIiA6IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyBcInB4XCJcbiAgfTtcbn1cblxudmFyIHBvc2l0aW9uRGVmYXVsdCA9IGZ1bmN0aW9uIHBvc2l0aW9uRGVmYXVsdCh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCkge1xuICBpZiAoIXRhcmdldFJlY3QgfHwgIXBvcG92ZXJSZWN0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIF9nZXRDb2xsaXNpb25zID0gZ2V0Q29sbGlzaW9ucyh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCksXG4gICAgICBkaXJlY3Rpb25SaWdodCA9IF9nZXRDb2xsaXNpb25zLmRpcmVjdGlvblJpZ2h0LFxuICAgICAgZGlyZWN0aW9uVXAgPSBfZ2V0Q29sbGlzaW9ucy5kaXJlY3Rpb25VcDtcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGxlZnQ6IGRpcmVjdGlvblJpZ2h0ID8gdGFyZ2V0UmVjdC5yaWdodCAtIHBvcG92ZXJSZWN0LndpZHRoICsgd2luZG93LnBhZ2VYT2Zmc2V0ICsgXCJweFwiIDogdGFyZ2V0UmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0ICsgXCJweFwiXG4gIH0sIGdldFRvcFBvc2l0aW9uKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0LCBkaXJlY3Rpb25VcCkpO1xufTtcblxudmFyIHBvc2l0aW9uUmlnaHQgPSBmdW5jdGlvbiBwb3NpdGlvblJpZ2h0KHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSB7XG4gIGlmICghdGFyZ2V0UmVjdCB8fCAhcG9wb3ZlclJlY3QpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgX2dldENvbGxpc2lvbnMyID0gZ2V0Q29sbGlzaW9ucyh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCksXG4gICAgICBkaXJlY3Rpb25MZWZ0ID0gX2dldENvbGxpc2lvbnMyLmRpcmVjdGlvbkxlZnQsXG4gICAgICBkaXJlY3Rpb25VcCA9IF9nZXRDb2xsaXNpb25zMi5kaXJlY3Rpb25VcDtcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGxlZnQ6IGRpcmVjdGlvbkxlZnQgPyB0YXJnZXRSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgKyBcInB4XCIgOiB0YXJnZXRSZWN0LnJpZ2h0IC0gcG9wb3ZlclJlY3Qud2lkdGggKyB3aW5kb3cucGFnZVhPZmZzZXQgKyBcInB4XCJcbiAgfSwgZ2V0VG9wUG9zaXRpb24odGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QsIGRpcmVjdGlvblVwKSk7XG59O1xuXG52YXIgcG9zaXRpb25NYXRjaFdpZHRoID0gZnVuY3Rpb24gcG9zaXRpb25NYXRjaFdpZHRoKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSB7XG4gIGlmICghdGFyZ2V0UmVjdCB8fCAhcG9wb3ZlclJlY3QpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgX2dldENvbGxpc2lvbnMzID0gZ2V0Q29sbGlzaW9ucyh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCksXG4gICAgICBkaXJlY3Rpb25VcCA9IF9nZXRDb2xsaXNpb25zMy5kaXJlY3Rpb25VcDtcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHdpZHRoOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgIGxlZnQ6IHRhcmdldFJlY3QubGVmdFxuICB9LCBnZXRUb3BQb3NpdGlvbih0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCwgZGlyZWN0aW9uVXApKTtcbn07XG5cbmZ1bmN0aW9uIGdldENvbGxpc2lvbnModGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QsIG9mZnNldExlZnQsIG9mZnNldEJvdHRvbSkge1xuICBpZiAob2Zmc2V0TGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgb2Zmc2V0TGVmdCA9IDA7XG4gIH1cblxuICBpZiAob2Zmc2V0Qm90dG9tID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXRCb3R0b20gPSAwO1xuICB9XG5cbiAgdmFyIGNvbGxpc2lvbnMgPSB7XG4gICAgdG9wOiB0YXJnZXRSZWN0LnRvcCAtIHBvcG92ZXJSZWN0LmhlaWdodCA8IDAsXG4gICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIDwgdGFyZ2V0UmVjdC5sZWZ0ICsgcG9wb3ZlclJlY3Qud2lkdGggLSBvZmZzZXRMZWZ0LFxuICAgIGJvdHRvbTogd2luZG93LmlubmVySGVpZ2h0IDwgdGFyZ2V0UmVjdC5ib3R0b20gKyBwb3BvdmVyUmVjdC5oZWlnaHQgLSBvZmZzZXRCb3R0b20sXG4gICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAtIHBvcG92ZXJSZWN0LndpZHRoIDwgMFxuICB9O1xuICB2YXIgZGlyZWN0aW9uUmlnaHQgPSBjb2xsaXNpb25zLnJpZ2h0ICYmICFjb2xsaXNpb25zLmxlZnQ7XG4gIHZhciBkaXJlY3Rpb25MZWZ0ID0gY29sbGlzaW9ucy5sZWZ0ICYmICFjb2xsaXNpb25zLnJpZ2h0O1xuICB2YXIgZGlyZWN0aW9uVXAgPSBjb2xsaXNpb25zLmJvdHRvbSAmJiAhY29sbGlzaW9ucy50b3A7XG4gIHZhciBkaXJlY3Rpb25Eb3duID0gY29sbGlzaW9ucy50b3AgJiYgIWNvbGxpc2lvbnMuYm90dG9tO1xuICByZXR1cm4ge1xuICAgIGRpcmVjdGlvblJpZ2h0OiBkaXJlY3Rpb25SaWdodCxcbiAgICBkaXJlY3Rpb25MZWZ0OiBkaXJlY3Rpb25MZWZ0LFxuICAgIGRpcmVjdGlvblVwOiBkaXJlY3Rpb25VcCxcbiAgICBkaXJlY3Rpb25Eb3duOiBkaXJlY3Rpb25Eb3duXG4gIH07XG59IC8vIEhlYWRzIHVwLCBteSBqUXVlcnkgcGFzdCBoYXVudHMgdGhpcyBmdW5jdGlvbi4gVGhpcyBob29rIHNjb3BlcyB0aGUgdGFiXG4vLyBvcmRlciB0byB0aGUgUmVhY3QgZWxlbWVudCB0cmVlLCBpbnN0ZWFkIG9mIHRoZSBET00gdHJlZS4gVGhpcyB3YXksIHdoZW4gdGhlXG4vLyB1c2VyIG5hdmlnYXRlcyB3aXRoIHRhYiBmcm9tIHRoZSB0YXJnZXRSZWYsIHRoZSB0YWIgb3JkZXIgbW92ZXMgaW50byB0aGVcbi8vIHBvcHVwLCBhbmQgdGhlbiBvdXQgb2YgdGhlIHBvcHVwIGJhY2sgdG8gdGhlIHJlc3Qgb2YgdGhlIGRvY3VtZW50LlxuLy8gKFdlIGNhbGwgdGFyZ2V0UmVmLCB0cmlnZ2VyUmVmIGluc2lkZSB0aGlzIGZ1bmN0aW9uIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoXG4vLyBldmVudC50YXJnZXQpXG5cblxuZnVuY3Rpb24gdXNlU2ltdWxhdGVUYWJOYXZpZ2F0aW9uRm9yUmVhY3RUcmVlKHRyaWdnZXJSZWYsIHBvcG92ZXJSZWYpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50KHRyaWdnZXJSZWYuY3VycmVudCk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgcG9wb3ZlclJlZi5jdXJyZW50ICYmIHRhYmJhYmxlKHBvcG92ZXJSZWYuY3VycmVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgaWYgKHNoaWZ0VGFiYmVkRnJvbUVsZW1lbnRBZnRlclRyaWdnZXIoZXZlbnQpKSB7XG4gICAgICAgIGZvY3VzTGFzdFRhYmJhYmxlSW5Qb3BvdmVyKGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc2hpZnRUYWJiZWRPdXRPZlBvcG92ZXIoZXZlbnQpKSB7XG4gICAgICAgIGZvY3VzVHJpZ2dlclJlZihldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHNoaWZ0VGFiYmVkVG9Ccm93c2VyQ2hyb21lKGV2ZW50KSkge1xuICAgICAgICBkaXNhYmxlVGFiYmFibGVzSW5Qb3BvdmVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgIGlmICh0YWJiZWRGcm9tVHJpZ2dlclRvUG9wb3ZlcigpKSB7XG4gICAgICAgIGZvY3VzRmlyc3RQb3BvdmVyVGFiYmFibGUoZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmICh0YWJiZWRPdXRPZlBvcG92ZXIoKSkge1xuICAgICAgICBmb2N1c1RhYmJhYmxlQWZ0ZXJUcmlnZ2VyKGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGFiYmVkVG9Ccm93c2VyQ2hyb21lKGV2ZW50KSkge1xuICAgICAgICBkaXNhYmxlVGFiYmFibGVzSW5Qb3BvdmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRBZnRlclRyaWdnZXIoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGFiYmFibGUob3duZXJEb2N1bWVudCk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gZWxlbWVudHMgJiYgdHJpZ2dlclJlZi5jdXJyZW50ID8gZWxlbWVudHMuaW5kZXhPZih0cmlnZ2VyUmVmLmN1cnJlbnQpIDogLTE7XG4gICAgdmFyIGVsZW1lbnRBZnRlclRyaWdnZXIgPSBlbGVtZW50cyAmJiBlbGVtZW50c1t0YXJnZXRJbmRleCArIDFdO1xuICAgIHJldHVybiBwb3BvdmVyUmVmLmN1cnJlbnQgJiYgcG9wb3ZlclJlZi5jdXJyZW50LmNvbnRhaW5zKGVsZW1lbnRBZnRlclRyaWdnZXIgfHwgbnVsbCkgPyBmYWxzZSA6IGVsZW1lbnRBZnRlclRyaWdnZXI7XG4gIH1cblxuICBmdW5jdGlvbiB0YWJiZWRGcm9tVHJpZ2dlclRvUG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdHJpZ2dlclJlZi5jdXJyZW50ID8gdHJpZ2dlclJlZi5jdXJyZW50ID09PSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvY3VzRmlyc3RQb3BvdmVyVGFiYmFibGUoZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBwb3BvdmVyUmVmLmN1cnJlbnQgJiYgdGFiYmFibGUocG9wb3ZlclJlZi5jdXJyZW50KTtcblxuICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50c1swXSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGFiYmVkT3V0T2ZQb3BvdmVyKCkge1xuICAgIHZhciBpblBvcG92ZXIgPSBwb3BvdmVyUmVmLmN1cnJlbnQgPyBwb3BvdmVyUmVmLmN1cnJlbnQuY29udGFpbnMob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IG51bGwpIDogZmFsc2U7XG5cbiAgICBpZiAoaW5Qb3BvdmVyKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBwb3BvdmVyUmVmLmN1cnJlbnQgJiYgdGFiYmFibGUocG9wb3ZlclJlZi5jdXJyZW50KTtcbiAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRzICYmIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdID09PSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvY3VzVGFiYmFibGVBZnRlclRyaWdnZXIoZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudEFmdGVyVHJpZ2dlciA9IGdldEVsZW1lbnRBZnRlclRyaWdnZXIoKTtcblxuICAgIGlmIChlbGVtZW50QWZ0ZXJUcmlnZ2VyKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWxlbWVudEFmdGVyVHJpZ2dlci5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNoaWZ0VGFiYmVkRnJvbUVsZW1lbnRBZnRlclRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRBZnRlclRyaWdnZXIgPSBnZXRFbGVtZW50QWZ0ZXJUcmlnZ2VyKCk7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudEFmdGVyVHJpZ2dlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvY3VzTGFzdFRhYmJhYmxlSW5Qb3BvdmVyKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gcG9wb3ZlclJlZi5jdXJyZW50ICYmIHRhYmJhYmxlKHBvcG92ZXJSZWYuY3VycmVudCk7XG4gICAgdmFyIGxhc3QgPSBlbGVtZW50cyAmJiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGFzdC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNoaWZ0VGFiYmVkT3V0T2ZQb3BvdmVyKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gcG9wb3ZlclJlZi5jdXJyZW50ICYmIHRhYmJhYmxlKHBvcG92ZXJSZWYuY3VycmVudCk7XG5cbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggPT09IDAgPyBmYWxzZSA6IGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudHNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9jdXNUcmlnZ2VyUmVmKGV2ZW50KSB7XG4gICAgdmFyIF90cmlnZ2VyUmVmJGN1cnJlbnQ7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIChfdHJpZ2dlclJlZiRjdXJyZW50ID0gdHJpZ2dlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RyaWdnZXJSZWYkY3VycmVudC5mb2N1cygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFiYmVkVG9Ccm93c2VyQ2hyb21lKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gcG9wb3ZlclJlZi5jdXJyZW50ID8gdGFiYmFibGUob3duZXJEb2N1bWVudCkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gIXBvcG92ZXJSZWYuY3VycmVudC5jb250YWlucyhlbGVtZW50KTtcbiAgICB9KSA6IG51bGw7XG4gICAgcmV0dXJuIGVsZW1lbnRzID8gZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hpZnRUYWJiZWRUb0Jyb3dzZXJDaHJvbWUoZXZlbnQpIHtcbiAgICAvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcG9wb3ZlciB3aWxsIG5ldmVyIGNvbnRhaW4gdGhlIGZpcnN0IHRhYmJhYmxlXG4gICAgLy8gZWxlbWVudCwgYW5kIGl0IGJldHRlciBub3QsIGJlY2F1c2UgdGhlIHRyaWdnZXIgbmVlZHMgdG8gYmUgdGFiYmFibGUhXG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gdGFiYmFibGUob3duZXJEb2N1bWVudClbMF07XG4gIH1cblxuICB2YXIgcmVzdG9yZVRhYkluZGV4VHVwbMOpcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRpc2FibGVUYWJiYWJsZXNJblBvcG92ZXIoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gcG9wb3ZlclJlZi5jdXJyZW50ICYmIHRhYmJhYmxlKHBvcG92ZXJSZWYuY3VycmVudCk7XG5cbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmVzdG9yZVRhYkluZGV4VHVwbMOpcy5wdXNoKFtlbGVtZW50LCBlbGVtZW50LnRhYkluZGV4XSk7XG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgIH0pO1xuICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBlbmFibGVUYWJiYWJsZXNJblBvcG92ZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuYWJsZVRhYmJhYmxlc0luUG9wb3ZlcigpIHtcbiAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGVuYWJsZVRhYmJhYmxlc0luUG9wb3Zlcik7XG4gICAgcmVzdG9yZVRhYkluZGV4VHVwbMOpcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfcmVmMlswXSxcbiAgICAgICAgICB0YWJJbmRleCA9IF9yZWYyWzFdO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgIH0pO1xuICB9XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IFBvcG92ZXI7XG5leHBvcnQgeyBQb3BvdmVyLCBnZXRDb2xsaXNpb25zLCBwb3NpdGlvbkRlZmF1bHQsIHBvc2l0aW9uTWF0Y2hXaWR0aCwgcG9zaXRpb25SaWdodCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/popover/dist/reach-popover.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/portal/dist/reach-portal.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@reach/portal/dist/reach-portal.esm.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Portal\": function() { return /* binding */ Portal; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils/use-isomorphic-layout-effect */ \"./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\");\n/* harmony import */ var _reach_utils_use_force_update__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils/use-force-update */ \"./node_modules/@reach/utils/use-force-update/dist/reach-utils-use-force-update.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n\n\n\n\n\n\n/**\n * Welcome to @reach/portal!\n *\n * Creates and appends a DOM node to the end of `document.body` and renders a\n * React tree into it. Useful for rendering a natural React element hierarchy\n * with a different DOM hierarchy to prevent parent styles from clipping or\n * hiding content (for popovers, dropdowns, and modals).\n *\n * @see Docs   https://reach.tech/portal\n * @see Source https://github.com/reach/reach-ui/tree/main/packages/portal\n * @see React  https://reactjs.org/docs/portals.html\n */\n/**\n * Portal\n *\n * @see Docs https://reach.tech/portal#portal\n */\n\nvar Portal = function Portal(_ref) {\n  var children = _ref.children,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"reach-portal\" : _ref$type,\n      containerRef = _ref.containerRef;\n  var mountNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var portalNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var forceUpdate = (0,_reach_utils_use_force_update__WEBPACK_IMPORTED_MODULE_2__.useForceUpdate)();\n\n  if (true) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      if (containerRef != null) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(typeof containerRef === \"object\" && \"current\" in containerRef, \"@reach/portal: Invalid value passed to the `containerRef` of a \" + \"`Portal`. The portal will be appended to the document body, but if \" + \"you want to attach it to another DOM node you must pass a valid \" + \"React ref object to `containerRef`.\") : 0;\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(containerRef ? containerRef.current != null : true, \"@reach/portal: A ref was passed to the `containerRef` prop of a \" + \"`Portal`, but no DOM node was attached to it. Be sure to pass the \" + \"ref to a DOM component.\\n\\nIf you are forwarding the ref from \" + \"another component, be sure to use the React.forwardRef API. \" + \"See https://reactjs.org/docs/forwarding-refs.html.\") : 0;\n      }\n    }, [containerRef]);\n  }\n\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__.useIsomorphicLayoutEffect)(function () {\n    // This ref may be null when a hot-loader replaces components on the page\n    if (!mountNode.current) return; // It's possible that the content of the portal has, itself, been portaled.\n    // In that case, it's important to append to the correct document element.\n\n    var ownerDocument = mountNode.current.ownerDocument;\n    var body = (containerRef == null ? void 0 : containerRef.current) || ownerDocument.body;\n    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);\n    body.appendChild(portalNode.current);\n    forceUpdate();\n    return function () {\n      if (portalNode.current && body) {\n        body.removeChild(portalNode.current);\n      }\n    };\n  }, [type, forceUpdate, containerRef]);\n  return portalNode.current ? /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(children, portalNode.current) : /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n    ref: mountNode\n  });\n};\n/**\n * @see Docs https://reach.tech/portal#portal-props\n */\n\n\nif (true) {\n  Portal.displayName = \"Portal\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Portal);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3BvcnRhbC9kaXN0L3JlYWNoLXBvcnRhbC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDNkI7QUFDdkI7QUFDdEI7QUFDTjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFNO0FBQ3hCLG1CQUFtQiw2Q0FBTTtBQUN6QixvQkFBb0IsNkVBQWM7O0FBRWxDLE1BQU0sSUFBcUM7QUFDM0M7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxRQUFRLEtBQXFDLEdBQUcsd0RBQU8sMFRBQTBULENBQU07QUFDdlgsUUFBUSxLQUFxQyxHQUFHLHdEQUFPLDZYQUE2WCxDQUFNO0FBQzFiO0FBQ0EsS0FBSztBQUNMOztBQUVBLEVBQUUsb0dBQXlCO0FBQzNCO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyx1REFBWSw4Q0FBOEMsb0RBQWE7QUFDbEg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLElBQUksSUFBcUM7QUFDekM7QUFDQSxFQUFFOztBQUVGLCtEQUFlLE1BQU0sRUFBQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvcG9ydGFsL2Rpc3QvcmVhY2gtcG9ydGFsLmVzbS5qcz84Yzg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJ0ByZWFjaC91dGlscy91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0JztcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnQHJlYWNoL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbi8qKlxuICogV2VsY29tZSB0byBAcmVhY2gvcG9ydGFsIVxuICpcbiAqIENyZWF0ZXMgYW5kIGFwcGVuZHMgYSBET00gbm9kZSB0byB0aGUgZW5kIG9mIGBkb2N1bWVudC5ib2R5YCBhbmQgcmVuZGVycyBhXG4gKiBSZWFjdCB0cmVlIGludG8gaXQuIFVzZWZ1bCBmb3IgcmVuZGVyaW5nIGEgbmF0dXJhbCBSZWFjdCBlbGVtZW50IGhpZXJhcmNoeVxuICogd2l0aCBhIGRpZmZlcmVudCBET00gaGllcmFyY2h5IHRvIHByZXZlbnQgcGFyZW50IHN0eWxlcyBmcm9tIGNsaXBwaW5nIG9yXG4gKiBoaWRpbmcgY29udGVudCAoZm9yIHBvcG92ZXJzLCBkcm9wZG93bnMsIGFuZCBtb2RhbHMpLlxuICpcbiAqIEBzZWUgRG9jcyAgIGh0dHBzOi8vcmVhY2gudGVjaC9wb3J0YWxcbiAqIEBzZWUgU291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yZWFjaC11aS90cmVlL21haW4vcGFja2FnZXMvcG9ydGFsXG4gKiBAc2VlIFJlYWN0ICBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcG9ydGFscy5odG1sXG4gKi9cbi8qKlxuICogUG9ydGFsXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9wb3J0YWwjcG9ydGFsXG4gKi9cblxudmFyIFBvcnRhbCA9IGZ1bmN0aW9uIFBvcnRhbChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyBcInJlYWNoLXBvcnRhbFwiIDogX3JlZiR0eXBlLFxuICAgICAgY29udGFpbmVyUmVmID0gX3JlZi5jb250YWluZXJSZWY7XG4gIHZhciBtb3VudE5vZGUgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBwb3J0YWxOb2RlID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnRhaW5lclJlZiAhPSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcodHlwZW9mIGNvbnRhaW5lclJlZiA9PT0gXCJvYmplY3RcIiAmJiBcImN1cnJlbnRcIiBpbiBjb250YWluZXJSZWYsIFwiQHJlYWNoL3BvcnRhbDogSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gdGhlIGBjb250YWluZXJSZWZgIG9mIGEgXCIgKyBcImBQb3J0YWxgLiBUaGUgcG9ydGFsIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50IGJvZHksIGJ1dCBpZiBcIiArIFwieW91IHdhbnQgdG8gYXR0YWNoIGl0IHRvIGFub3RoZXIgRE9NIG5vZGUgeW91IG11c3QgcGFzcyBhIHZhbGlkIFwiICsgXCJSZWFjdCByZWYgb2JqZWN0IHRvIGBjb250YWluZXJSZWZgLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhjb250YWluZXJSZWYgPyBjb250YWluZXJSZWYuY3VycmVudCAhPSBudWxsIDogdHJ1ZSwgXCJAcmVhY2gvcG9ydGFsOiBBIHJlZiB3YXMgcGFzc2VkIHRvIHRoZSBgY29udGFpbmVyUmVmYCBwcm9wIG9mIGEgXCIgKyBcImBQb3J0YWxgLCBidXQgbm8gRE9NIG5vZGUgd2FzIGF0dGFjaGVkIHRvIGl0LiBCZSBzdXJlIHRvIHBhc3MgdGhlIFwiICsgXCJyZWYgdG8gYSBET00gY29tcG9uZW50LlxcblxcbklmIHlvdSBhcmUgZm9yd2FyZGluZyB0aGUgcmVmIGZyb20gXCIgKyBcImFub3RoZXIgY29tcG9uZW50LCBiZSBzdXJlIHRvIHVzZSB0aGUgUmVhY3QuZm9yd2FyZFJlZiBBUEkuIFwiICsgXCJTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2ZvcndhcmRpbmctcmVmcy5odG1sLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9LCBbY29udGFpbmVyUmVmXSk7XG4gIH1cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIHJlZiBtYXkgYmUgbnVsbCB3aGVuIGEgaG90LWxvYWRlciByZXBsYWNlcyBjb21wb25lbnRzIG9uIHRoZSBwYWdlXG4gICAgaWYgKCFtb3VudE5vZGUuY3VycmVudCkgcmV0dXJuOyAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcnRhbCBoYXMsIGl0c2VsZiwgYmVlbiBwb3J0YWxlZC5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIGl0J3MgaW1wb3J0YW50IHRvIGFwcGVuZCB0byB0aGUgY29ycmVjdCBkb2N1bWVudCBlbGVtZW50LlxuXG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBtb3VudE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50O1xuICAgIHZhciBib2R5ID0gKGNvbnRhaW5lclJlZiA9PSBudWxsID8gdm9pZCAwIDogY29udGFpbmVyUmVmLmN1cnJlbnQpIHx8IG93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBwb3J0YWxOb2RlLmN1cnJlbnQgPSBvd25lckRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgYm9keS5hcHBlbmRDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xuICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwb3J0YWxOb2RlLmN1cnJlbnQgJiYgYm9keSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKHBvcnRhbE5vZGUuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3R5cGUsIGZvcmNlVXBkYXRlLCBjb250YWluZXJSZWZdKTtcbiAgcmV0dXJuIHBvcnRhbE5vZGUuY3VycmVudCA/IC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUuY3VycmVudCkgOiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHJlZjogbW91bnROb2RlXG4gIH0pO1xufTtcbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9wb3J0YWwjcG9ydGFsLXByb3BzXG4gKi9cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFBvcnRhbC5kaXNwbGF5TmFtZSA9IFwiUG9ydGFsXCI7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IFBvcnRhbDtcbmV4cG9ydCB7IFBvcnRhbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/portal/dist/reach-portal.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/rect/dist/reach-rect.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@reach/rect/dist/reach-rect.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rect\": function() { return /* binding */ Rect; },\n/* harmony export */   \"useRect\": function() { return /* binding */ useRect; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _reach_observe_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/observe-rect */ \"./node_modules/@reach/observe-rect/dist/observe-rect.esm.js\");\n/* harmony import */ var _reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils/use-isomorphic-layout-effect */ \"./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\");\n/* harmony import */ var _reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/utils/type-check */ \"./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js\");\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n\n\n\n\n\n\n\n/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\n/**\n * Rect\n *\n * @param props\n */\n\nvar Rect = function Rect(_ref) {\n  var onChange = _ref.onChange,\n      _ref$observe = _ref.observe,\n      observe = _ref$observe === void 0 ? true : _ref$observe,\n      children = _ref.children;\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var rect = useRect(ref, {\n    observe: observe,\n    onChange: onChange\n  });\n  return children({\n    ref: ref,\n    rect: rect\n  });\n};\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\n\n\nif (true) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func.isRequired),\n    observe: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),\n    onChange: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().func)\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nfunction useRect(nodeRef, observeOrOptions, deprecated_onChange) {\n  var observe;\n  var onChange;\n\n  if ((0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    var _observeOrOptions$obs;\n\n    observe = (_observeOrOptions$obs = observeOrOptions == null ? void 0 : observeOrOptions.observe) != null ? _observeOrOptions$obs : true;\n    onChange = observeOrOptions == null ? void 0 : observeOrOptions.onChange;\n  }\n\n  if ((0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isFunction)(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (true) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(!(0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(observeOrOptions), \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" + \"See https://reach.tech/rect#userect-observe\") : 0;\n    }, [observeOrOptions]); // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(!(0,_reach_utils_type_check__WEBPACK_IMPORTED_MODULE_3__.isFunction)(deprecated_onChange), \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" + \"See https://reach.tech/rect#userect-onchange\") : 0;\n    }, [deprecated_onChange]);\n  }\n\n  var _React$useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var initialRectIsSet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var initialRefIsSet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n\n  var _React$useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),\n      rect = _React$useState2[0],\n      setRect = _React$useState2[1];\n\n  var onChangeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onChange); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(function () {\n    onChangeRef.current = onChange;\n\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(function () {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  (0,_reach_utils_use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(function () {\n    if (!observe) {\n      return;\n    }\n\n    var elem = element; // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (true) {\n        console.warn(\"You need to place the ref\");\n      }\n\n      return;\n    }\n\n    var observer = (0,_reach_observe_rect__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(elem, function (rect) {\n      onChangeRef.current == null ? void 0 : onChangeRef.current(rect);\n      setRect(rect);\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [observe, element, nodeRef]);\n  return rect;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Rect);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3JlY3QvZGlzdC9yZWFjaC1yZWN0LmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2pCO0FBQ1c7QUFDd0M7QUFDdEI7QUFDN0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBLGNBQWMsbUVBQXlCO0FBQ3ZDLGFBQWEsd0RBQWM7QUFDM0IsY0FBYyx3REFBYztBQUM1QjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sa0VBQVM7QUFDZjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxtRUFBVTtBQUNoQjtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQSxJQUFJLGdEQUFTO0FBQ2IsTUFBTSxLQUFxQyxHQUFHLHdEQUFPLEVBQUUsa0VBQVMsNFBBQTRQLFNBQVMsMkRBQTJELENBQU07QUFDdFksS0FBSyx1QkFBdUI7O0FBRTVCLElBQUksZ0RBQVM7QUFDYixNQUFNLEtBQXFDLEdBQUcsd0RBQU8sRUFBRSxtRUFBVSxnUUFBZ1EsVUFBVSw0REFBNEQsQ0FBTTtBQUM3WSxLQUFLO0FBQ0w7O0FBRUEsd0JBQXdCLCtDQUFRO0FBQ2hDO0FBQ0E7O0FBRUEseUJBQXlCLDZDQUFNO0FBQy9CLHdCQUF3Qiw2Q0FBTTs7QUFFOUIseUJBQXlCLCtDQUFRO0FBQ2pDO0FBQ0E7O0FBRUEsb0JBQW9CLDZDQUFNLFlBQVk7O0FBRXRDLEVBQUUsb0dBQXlCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLG9HQUF5QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLG9HQUF5QjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiwrREFBVztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsK0RBQWUsSUFBSSxFQUFDO0FBQ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC9yZWN0L2Rpc3QvcmVhY2gtcmVjdC5lc20uanM/YjFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG9ic2VydmVSZWN0IGZyb20gJ0ByZWFjaC9vYnNlcnZlLXJlY3QnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJ0ByZWFjaC91dGlscy91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0JztcbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNGdW5jdGlvbiB9IGZyb20gJ0ByZWFjaC91dGlscy90eXBlLWNoZWNrJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbi8qKlxuICogV2VsY29tZSB0byBAcmVhY2gvcmVjdCFcbiAqXG4gKiBNZWFzdXJlcyBET00gZWxlbWVudHMgKGFrYS4gYm91bmRpbmcgY2xpZW50IHJlY3QpLlxuICpcbiAqIEBzZWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQHNlZSBEb2NzICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9yZWFjaC50ZWNoL3JlY3RcbiAqIEBzZWUgU291cmNlICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yZWFjaC11aS90cmVlL21haW4vcGFja2FnZXMvcmVjdFxuICovXG5cbi8qKlxuICogUmVjdFxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5cbnZhciBSZWN0ID0gZnVuY3Rpb24gUmVjdChfcmVmKSB7XG4gIHZhciBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICBfcmVmJG9ic2VydmUgPSBfcmVmLm9ic2VydmUsXG4gICAgICBvYnNlcnZlID0gX3JlZiRvYnNlcnZlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRvYnNlcnZlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcmVjdCA9IHVzZVJlY3QocmVmLCB7XG4gICAgb2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgICBvbkNoYW5nZTogb25DaGFuZ2VcbiAgfSk7XG4gIHJldHVybiBjaGlsZHJlbih7XG4gICAgcmVmOiByZWYsXG4gICAgcmVjdDogcmVjdFxuICB9KTtcbn07XG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvcmVjdCNyZWN0LXByb3BzXG4gKi9cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJlY3QuZGlzcGxheU5hbWUgPSBcIlJlY3RcIjtcbiAgUmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb2JzZXJ2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiB1c2VSZWN0XG4gKlxuICogQHBhcmFtIG5vZGVSZWZcbiAqIEBwYXJhbSBvYnNlcnZlXG4gKiBAcGFyYW0gb25DaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXNlUmVjdChub2RlUmVmLCBvYnNlcnZlT3JPcHRpb25zLCBkZXByZWNhdGVkX29uQ2hhbmdlKSB7XG4gIHZhciBvYnNlcnZlO1xuICB2YXIgb25DaGFuZ2U7XG5cbiAgaWYgKGlzQm9vbGVhbihvYnNlcnZlT3JPcHRpb25zKSkge1xuICAgIG9ic2VydmUgPSBvYnNlcnZlT3JPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIHZhciBfb2JzZXJ2ZU9yT3B0aW9ucyRvYnM7XG5cbiAgICBvYnNlcnZlID0gKF9vYnNlcnZlT3JPcHRpb25zJG9icyA9IG9ic2VydmVPck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9ic2VydmVPck9wdGlvbnMub2JzZXJ2ZSkgIT0gbnVsbCA/IF9vYnNlcnZlT3JPcHRpb25zJG9icyA6IHRydWU7XG4gICAgb25DaGFuZ2UgPSBvYnNlcnZlT3JPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlT3JPcHRpb25zLm9uQ2hhbmdlO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oZGVwcmVjYXRlZF9vbkNoYW5nZSkpIHtcbiAgICBvbkNoYW5nZSA9IGRlcHJlY2F0ZWRfb25DaGFuZ2U7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWlzQm9vbGVhbihvYnNlcnZlT3JPcHRpb25zKSwgXCJQYXNzaW5nIGBvYnNlcnZlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGB1c2VSZWN0YCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjaCBVSS4gSW5zdGVhZCwgeW91IGNhbiBwYXNzIGFuIG9iamVjdCBvZiBvcHRpb25zIHdpdGggYW4gYG9ic2VydmVgIHByb3BlcnR5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgKGB1c2VSZWN0KHJlZiwgeyBvYnNlcnZlIH0pYCkuXFxuXCIgKyBcIlNlZSBodHRwczovL3JlYWNoLnRlY2gvcmVjdCN1c2VyZWN0LW9ic2VydmVcIikgOiB2b2lkIDA7XG4gICAgfSwgW29ic2VydmVPck9wdGlvbnNdKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG5cbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghaXNGdW5jdGlvbihkZXByZWNhdGVkX29uQ2hhbmdlKSwgXCJQYXNzaW5nIGBvbkNoYW5nZWAgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHRvIGB1c2VSZWN0YCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjaCBVSS4gSW5zdGVhZCwgeW91IGNhbiBwYXNzIGFuIG9iamVjdCBvZiBvcHRpb25zIHdpdGggYW4gYG9uQ2hhbmdlYCBwcm9wZXJ0eSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IChgdXNlUmVjdChyZWYsIHsgb25DaGFuZ2UgfSlgKS5cXG5cIiArIFwiU2VlIGh0dHBzOi8vcmVhY2gudGVjaC9yZWN0I3VzZXJlY3Qtb25jaGFuZ2VcIikgOiB2b2lkIDA7XG4gICAgfSwgW2RlcHJlY2F0ZWRfb25DaGFuZ2VdKTtcbiAgfVxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSB1c2VTdGF0ZShub2RlUmVmLmN1cnJlbnQpLFxuICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIGluaXRpYWxSZWN0SXNTZXQgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgaW5pdGlhbFJlZklzU2V0ID0gdXNlUmVmKGZhbHNlKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgcmVjdCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRSZWN0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgb25DaGFuZ2VSZWYgPSB1c2VSZWYob25DaGFuZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgb25DaGFuZ2VSZWYuY3VycmVudCA9IG9uQ2hhbmdlO1xuXG4gICAgaWYgKG5vZGVSZWYuY3VycmVudCAhPT0gZWxlbWVudCkge1xuICAgICAgc2V0RWxlbWVudChub2RlUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbGVtZW50ICYmICFpbml0aWFsUmVjdElzU2V0LmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxSZWN0SXNTZXQuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRSZWN0KGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgIH1cbiAgfSwgW2VsZW1lbnRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFvYnNlcnZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW0gPSBlbGVtZW50OyAvLyBTdGF0ZSBpbml0aWFsaXplcyBiZWZvcmUgcmVmcyBhcmUgcGxhY2VkLCBtZWFuaW5nIHRoZSBlbGVtZW50IHN0YXRlIHdpbGxcbiAgICAvLyBiZSB1bmRlZmluZWQgb24gdGhlIGZpcnN0IHJlbmRlci4gV2Ugc3RpbGwgd2FudCB0aGUgcmVjdCBvbiB0aGUgZmlyc3RcbiAgICAvLyByZW5kZXIsIHNvIGluaXRpYWxseSB3ZSdsbCB1c2UgdGhlIG5vZGVSZWYgdGhhdCB3YXMgcGFzc2VkIGluc3RlYWQgb2ZcbiAgICAvLyBzdGF0ZSBmb3Igb3VyIG1lYXN1cmVtZW50cy5cblxuICAgIGlmICghaW5pdGlhbFJlZklzU2V0LmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxSZWZJc1NldC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGVsZW0gPSBub2RlUmVmLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIllvdSBuZWVkIHRvIHBsYWNlIHRoZSByZWZcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBvYnNlcnZlUmVjdChlbGVtLCBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgb25DaGFuZ2VSZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2VSZWYuY3VycmVudChyZWN0KTtcbiAgICAgIHNldFJlY3QocmVjdCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbiAgICB9O1xuICB9LCBbb2JzZXJ2ZSwgZWxlbWVudCwgbm9kZVJlZl0pO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdDtcbmV4cG9ydCB7IFJlY3QsIHVzZVJlY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/rect/dist/reach-rect.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/can-use-dom/dist/reach-utils-can-use-dom.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reach/utils/can-use-dom/dist/reach-utils-can-use-dom.esm.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canUseDOM\": function() { return /* binding */ canUseDOM; }\n/* harmony export */ });\nfunction canUseDOM() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2Nhbi11c2UtZG9tL2Rpc3QvcmVhY2gtdXRpbHMtY2FuLXVzZS1kb20uZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvdXRpbHMvY2FuLXVzZS1kb20vZGlzdC9yZWFjaC11dGlscy1jYW4tdXNlLWRvbS5lc20uanM/NTM1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjYW5Vc2VET00oKSB7XG4gIHJldHVybiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG59XG5cbmV4cG9ydCB7IGNhblVzZURPTSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/can-use-dom/dist/reach-utils-can-use-dom.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/compose-event-handlers/dist/reach-utils-compose-event-handlers.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@reach/utils/compose-event-handlers/dist/reach-utils-compose-event-handlers.esm.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composeEventHandlers\": function() { return /* binding */ composeEventHandlers; }\n/* harmony export */ });\n/**\n * Wraps a lib-defined event handler and a user-defined event handler, returning\n * a single handler that allows a user to prevent lib-defined handlers from\n * firing.\n *\n * @param theirHandler User-supplied event handler\n * @param ourHandler Library-supplied event handler\n */\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return function (event) {\n    theirHandler && theirHandler(event);\n\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2NvbXBvc2UtZXZlbnQtaGFuZGxlcnMvZGlzdC9yZWFjaC11dGlscy1jb21wb3NlLWV2ZW50LWhhbmRsZXJzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2NvbXBvc2UtZXZlbnQtaGFuZGxlcnMvZGlzdC9yZWFjaC11dGlscy1jb21wb3NlLWV2ZW50LWhhbmRsZXJzLmVzbS5qcz80MDYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV3JhcHMgYSBsaWItZGVmaW5lZCBldmVudCBoYW5kbGVyIGFuZCBhIHVzZXItZGVmaW5lZCBldmVudCBoYW5kbGVyLCByZXR1cm5pbmdcbiAqIGEgc2luZ2xlIGhhbmRsZXIgdGhhdCBhbGxvd3MgYSB1c2VyIHRvIHByZXZlbnQgbGliLWRlZmluZWQgaGFuZGxlcnMgZnJvbVxuICogZmlyaW5nLlxuICpcbiAqIEBwYXJhbSB0aGVpckhhbmRsZXIgVXNlci1zdXBwbGllZCBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0gb3VySGFuZGxlciBMaWJyYXJ5LXN1cHBsaWVkIGV2ZW50IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGVpckhhbmRsZXIgJiYgdGhlaXJIYW5kbGVyKGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/compose-event-handlers/dist/reach-utils-compose-event-handlers.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/compose-refs/dist/reach-utils-compose-refs.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@reach/utils/compose-refs/dist/reach-utils-compose-refs.esm.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assignRef\": function() { return /* binding */ assignRef; },\n/* harmony export */   \"useComposedRefs\": function() { return /* binding */ useComposedRefs; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _type_check_dist_reach_utils_type_check_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../type-check/dist/reach-utils-type-check.esm.js */ \"./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js\");\n\n\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\n/**\n * Passes or assigns an arbitrary value to a ref function or object.\n *\n * @param ref\n * @param value\n */\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if ((0,_type_check_dist_reach_utils_type_check_esm_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to ref \\\"\" + ref + \"\\\"\");\n    }\n  }\n}\n/**\n * Passes or assigns a value to multiple refs (typically a DOM node). Useful for\n * dealing with components that need an explicit ref for DOM calculations but\n * also forwards refs assigned by an app.\n *\n * @param refs Refs to fork\n */\n\nfunction useComposedRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (node) {\n    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {\n      var ref = _step.value;\n      assignRef(ref, node);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, refs);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2NvbXBvc2UtcmVmcy9kaXN0L3JlYWNoLXV0aWxzLWNvbXBvc2UtcmVmcy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0M7QUFDNkM7O0FBRWpGO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLDBGQUFVO0FBQ2hCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7O0FBRUEsU0FBUyxrREFBVztBQUNwQix1RUFBdUUsNEJBQTRCO0FBQ25HO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDs7QUFFc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy9jb21wb3NlLXJlZnMvZGlzdC9yZWFjaC11dGlscy1jb21wb3NlLXJlZnMuZXNtLmpzP2Q4YWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZS1jaGVjay9kaXN0L3JlYWNoLXV0aWxzLXR5cGUtY2hlY2suZXNtLmpzJztcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxuLyoqXG4gKiBQYXNzZXMgb3IgYXNzaWducyBhbiBhcmJpdHJhcnkgdmFsdWUgdG8gYSByZWYgZnVuY3Rpb24gb3Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZWZcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NpZ25SZWYocmVmLCB2YWx1ZSkge1xuICBpZiAocmVmID09IG51bGwpIHJldHVybjtcblxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgcmVmKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiB2YWx1ZSBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0byByZWYgXFxcIlwiICsgcmVmICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBQYXNzZXMgb3IgYXNzaWducyBhIHZhbHVlIHRvIG11bHRpcGxlIHJlZnMgKHR5cGljYWxseSBhIERPTSBub2RlKS4gVXNlZnVsIGZvclxuICogZGVhbGluZyB3aXRoIGNvbXBvbmVudHMgdGhhdCBuZWVkIGFuIGV4cGxpY2l0IHJlZiBmb3IgRE9NIGNhbGN1bGF0aW9ucyBidXRcbiAqIGFsc28gZm9yd2FyZHMgcmVmcyBhc3NpZ25lZCBieSBhbiBhcHAuXG4gKlxuICogQHBhcmFtIHJlZnMgUmVmcyB0byBmb3JrXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVmcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICByZWZzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZWZzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciByZWYgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGFzc2lnblJlZihyZWYsIG5vZGUpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gIH0sIHJlZnMpO1xufVxuXG5leHBvcnQgeyBhc3NpZ25SZWYsIHVzZUNvbXBvc2VkUmVmcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/compose-refs/dist/reach-utils-compose-refs.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/context/dist/reach-utils-context.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@reach/utils/context/dist/reach-utils-context.esm.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createNamedContext\": function() { return /* binding */ createNamedContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction createNamedContext(name, defaultValue) {\n  var Ctx = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue);\n\n  if (true) {\n    Ctx.displayName = name;\n  }\n\n  return Ctx;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2NvbnRleHQvZGlzdC9yZWFjaC11dGlscy1jb250ZXh0LmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0M7O0FBRXRDO0FBQ0EseUJBQXlCLG9EQUFhOztBQUV0QyxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy9jb250ZXh0L2Rpc3QvcmVhY2gtdXRpbHMtY29udGV4dC5lc20uanM/YjJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVOYW1lZENvbnRleHQobmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBDdHggPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBDdHguZGlzcGxheU5hbWUgPSBuYW1lO1xuICB9XG5cbiAgcmV0dXJuIEN0eDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTmFtZWRDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/context/dist/reach-utils-context.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/dev-utils/dist/reach-utils-dev-utils.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@reach/utils/dev-utils/dist/reach-utils-dev-utils.esm.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkStyles\": function() { return /* binding */ checkStyles; },\n/* harmony export */   \"useCheckStyles\": function() { return /* binding */ useCheckStyles; },\n/* harmony export */   \"useControlledSwitchWarning\": function() { return /* binding */ useControlledSwitchWarning; },\n/* harmony export */   \"useStateLogger\": function() { return /* binding */ useStateLogger; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n/* eslint-disable react-hooks/rules-of-hooks */\nvar checkedPkgs = {};\n/**\n * Just a lil state logger\n *\n * @param state\n * @param DEBUG\n */\n\nfunction useStateLogger(state, DEBUG) {\n  if (DEBUG === void 0) {\n    DEBUG = false;\n  }\n\n  if (true) {\n    var debugRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(DEBUG);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      debugRef.current = DEBUG;\n    }, [DEBUG]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      if (debugRef.current) {\n        console.group(\"State Updated\");\n        console.log(\"%c\" + state, \"font-weight: normal; font-size: 120%; font-style: italic;\");\n        console.groupEnd();\n      }\n    }, [state]);\n  }\n}\n/**\n * When in dev mode, checks that styles for a given `@reach` package are loaded.\n *\n * @param packageName Name of the package to check.\n * @example checkStyles(\"dialog\") will check for styles for @reach/dialog\n */\n\nfunction checkStyles(packageName) {\n  if (true) {\n    // In CJS files, process.env.NODE_ENV is stripped from our build, but we\n    // need it to prevent style checks from clogging up user logs while testing.\n    // This is a workaround until we can tweak the build a bit to accommodate.\n    var _ref = typeof process !== \"undefined\" ? process.env : {\n      NODE_ENV: \"development\"\n    },\n        environment = _ref.NODE_ENV; // only check once per package\n\n\n    if (checkedPkgs[packageName]) return;\n    checkedPkgs[packageName] = true;\n\n    if (environment === \"development\" && parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--reach-\" + packageName), 10) !== 1) {\n      console.warn(\"@reach/\" + packageName + \" styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\\n  \\n      import \\\"@reach/\" + packageName + \"/styles.css\\\";\\n  \\n    Otherwise you'll need to include them some other way:\\n  \\n      <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"node_modules/@reach/\" + packageName + \"/styles.css\\\" />\\n  \\n    For more information visit https://ui.reach.tech/styling.\\n    \");\n    }\n  }\n}\n/**\n * When in dev mode, checks that styles for a given `@reach` package are loaded.\n *\n * @param packageName Name of the package to check.\n * @example useCheckStyles(\"dialog\") will check for styles for @reach/dialog\n */\n\nfunction useCheckStyles(packageName) {\n  if (true) {\n    var name = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(packageName);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      return void (name.current = packageName);\n    }, [packageName]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      return checkStyles(name.current);\n    }, []);\n  }\n}\n/**\n * Logs a warning in dev mode when a component switches from controlled to\n * uncontrolled, or vice versa\n *\n * A single prop should typically be used to determine whether or not a\n * component is controlled or not.\n *\n * @param controlledValue\n * @param controlledPropName\n * @param componentName\n */\n\nfunction useControlledSwitchWarning(controlledValue, controlledPropName, componentName) {\n  if (true) {\n    var controlledRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(controlledValue != null);\n    var nameCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n      componentName: componentName,\n      controlledPropName: controlledPropName\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      nameCache.current = {\n        componentName: componentName,\n        controlledPropName: controlledPropName\n      };\n    }, [componentName, controlledPropName]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      var wasControlled = controlledRef.current;\n      var _nameCache$current = nameCache.current,\n          componentName = _nameCache$current.componentName,\n          controlledPropName = _nameCache$current.controlledPropName;\n      var isControlled = controlledValue != null;\n\n      if (wasControlled !== isControlled) {\n        console.error(\"A component is changing an \" + (wasControlled ? \"\" : \"un\") + \"controlled `\" + controlledPropName + \"` state of \" + componentName + \" to be \" + (wasControlled ? \"un\" : \"\") + \"controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled \" + componentName + \" element for the lifetime of the component.\\n      More info: https://fb.me/react-controlled-components\");\n      }\n    }, [controlledValue]);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL2Rldi11dGlscy9kaXN0L3JlYWNoLXV0aWxzLWRldi11dGlscy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDLG1CQUFtQiw2Q0FBTTtBQUN6QixJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQSx3REFBd0QsaUJBQWlCLG1CQUFtQjtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLG1CQUFtQixPQUFPO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMLHFDQUFxQzs7O0FBR3JDO0FBQ0E7O0FBRUE7QUFDQSx5UEFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQyxlQUFlLDZDQUFNO0FBQ3JCLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDLHdCQUF3Qiw2Q0FBTTtBQUM5QixvQkFBb0IsNkNBQU07QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvdXRpbHMvZGV2LXV0aWxzL2Rpc3QvcmVhY2gtdXRpbHMtZGV2LXV0aWxzLmVzbS5qcz80ZDYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcyAqL1xudmFyIGNoZWNrZWRQa2dzID0ge307XG4vKipcbiAqIEp1c3QgYSBsaWwgc3RhdGUgbG9nZ2VyXG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKiBAcGFyYW0gREVCVUdcbiAqL1xuXG5mdW5jdGlvbiB1c2VTdGF0ZUxvZ2dlcihzdGF0ZSwgREVCVUcpIHtcbiAgaWYgKERFQlVHID09PSB2b2lkIDApIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBkZWJ1Z1JlZiA9IHVzZVJlZihERUJVRyk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnUmVmLmN1cnJlbnQgPSBERUJVRztcbiAgICB9LCBbREVCVUddKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGRlYnVnUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS5ncm91cChcIlN0YXRlIFVwZGF0ZWRcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIHN0YXRlLCBcImZvbnQtd2VpZ2h0OiBub3JtYWw7IGZvbnQtc2l6ZTogMTIwJTsgZm9udC1zdHlsZTogaXRhbGljO1wiKTtcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgfVxuICAgIH0sIFtzdGF0ZV0pO1xuICB9XG59XG4vKipcbiAqIFdoZW4gaW4gZGV2IG1vZGUsIGNoZWNrcyB0aGF0IHN0eWxlcyBmb3IgYSBnaXZlbiBgQHJlYWNoYCBwYWNrYWdlIGFyZSBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHBhY2thZ2VOYW1lIE5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY2hlY2suXG4gKiBAZXhhbXBsZSBjaGVja1N0eWxlcyhcImRpYWxvZ1wiKSB3aWxsIGNoZWNrIGZvciBzdHlsZXMgZm9yIEByZWFjaC9kaWFsb2dcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1N0eWxlcyhwYWNrYWdlTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gSW4gQ0pTIGZpbGVzLCBwcm9jZXNzLmVudi5OT0RFX0VOViBpcyBzdHJpcHBlZCBmcm9tIG91ciBidWlsZCwgYnV0IHdlXG4gICAgLy8gbmVlZCBpdCB0byBwcmV2ZW50IHN0eWxlIGNoZWNrcyBmcm9tIGNsb2dnaW5nIHVwIHVzZXIgbG9ncyB3aGlsZSB0ZXN0aW5nLlxuICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHVudGlsIHdlIGNhbiB0d2VhayB0aGUgYnVpbGQgYSBiaXQgdG8gYWNjb21tb2RhdGUuXG4gICAgdmFyIF9yZWYgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MuZW52IDoge1xuICAgICAgTk9ERV9FTlY6IFwiZGV2ZWxvcG1lbnRcIlxuICAgIH0sXG4gICAgICAgIGVudmlyb25tZW50ID0gX3JlZi5OT0RFX0VOVjsgLy8gb25seSBjaGVjayBvbmNlIHBlciBwYWNrYWdlXG5cblxuICAgIGlmIChjaGVja2VkUGtnc1twYWNrYWdlTmFtZV0pIHJldHVybjtcbiAgICBjaGVja2VkUGtnc1twYWNrYWdlTmFtZV0gPSB0cnVlO1xuXG4gICAgaWYgKGVudmlyb25tZW50ID09PSBcImRldmVsb3BtZW50XCIgJiYgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tcmVhY2gtXCIgKyBwYWNrYWdlTmFtZSksIDEwKSAhPT0gMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiQHJlYWNoL1wiICsgcGFja2FnZU5hbWUgKyBcIiBzdHlsZXMgbm90IGZvdW5kLiBJZiB5b3UgYXJlIHVzaW5nIGEgYnVuZGxlciBsaWtlIHdlYnBhY2sgb3IgcGFyY2VsIGluY2x1ZGUgdGhpcyBpbiB0aGUgZW50cnkgZmlsZSBvZiB5b3VyIGFwcCBiZWZvcmUgYW55IG9mIHlvdXIgb3duIHN0eWxlczpcXG4gIFxcbiAgICAgIGltcG9ydCBcXFwiQHJlYWNoL1wiICsgcGFja2FnZU5hbWUgKyBcIi9zdHlsZXMuY3NzXFxcIjtcXG4gIFxcbiAgICBPdGhlcndpc2UgeW91J2xsIG5lZWQgdG8gaW5jbHVkZSB0aGVtIHNvbWUgb3RoZXIgd2F5OlxcbiAgXFxuICAgICAgPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCIgaHJlZj1cXFwibm9kZV9tb2R1bGVzL0ByZWFjaC9cIiArIHBhY2thZ2VOYW1lICsgXCIvc3R5bGVzLmNzc1xcXCIgLz5cXG4gIFxcbiAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiB2aXNpdCBodHRwczovL3VpLnJlYWNoLnRlY2gvc3R5bGluZy5cXG4gICAgXCIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBXaGVuIGluIGRldiBtb2RlLCBjaGVja3MgdGhhdCBzdHlsZXMgZm9yIGEgZ2l2ZW4gYEByZWFjaGAgcGFja2FnZSBhcmUgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBOYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNoZWNrLlxuICogQGV4YW1wbGUgdXNlQ2hlY2tTdHlsZXMoXCJkaWFsb2dcIikgd2lsbCBjaGVjayBmb3Igc3R5bGVzIGZvciBAcmVhY2gvZGlhbG9nXG4gKi9cblxuZnVuY3Rpb24gdXNlQ2hlY2tTdHlsZXMocGFja2FnZU5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBuYW1lID0gdXNlUmVmKHBhY2thZ2VOYW1lKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZvaWQgKG5hbWUuY3VycmVudCA9IHBhY2thZ2VOYW1lKTtcbiAgICB9LCBbcGFja2FnZU5hbWVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNoZWNrU3R5bGVzKG5hbWUuY3VycmVudCk7XG4gICAgfSwgW10pO1xuICB9XG59XG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGluIGRldiBtb2RlIHdoZW4gYSBjb21wb25lbnQgc3dpdGNoZXMgZnJvbSBjb250cm9sbGVkIHRvXG4gKiB1bmNvbnRyb2xsZWQsIG9yIHZpY2UgdmVyc2FcbiAqXG4gKiBBIHNpbmdsZSBwcm9wIHNob3VsZCB0eXBpY2FsbHkgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgYVxuICogY29tcG9uZW50IGlzIGNvbnRyb2xsZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBjb250cm9sbGVkVmFsdWVcbiAqIEBwYXJhbSBjb250cm9sbGVkUHJvcE5hbWVcbiAqIEBwYXJhbSBjb21wb25lbnROYW1lXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29udHJvbGxlZFN3aXRjaFdhcm5pbmcoY29udHJvbGxlZFZhbHVlLCBjb250cm9sbGVkUHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBjb250cm9sbGVkUmVmID0gdXNlUmVmKGNvbnRyb2xsZWRWYWx1ZSAhPSBudWxsKTtcbiAgICB2YXIgbmFtZUNhY2hlID0gdXNlUmVmKHtcbiAgICAgIGNvbXBvbmVudE5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICBjb250cm9sbGVkUHJvcE5hbWU6IGNvbnRyb2xsZWRQcm9wTmFtZVxuICAgIH0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBuYW1lQ2FjaGUuY3VycmVudCA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29udHJvbGxlZFByb3BOYW1lOiBjb250cm9sbGVkUHJvcE5hbWVcbiAgICAgIH07XG4gICAgfSwgW2NvbXBvbmVudE5hbWUsIGNvbnRyb2xsZWRQcm9wTmFtZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd2FzQ29udHJvbGxlZCA9IGNvbnRyb2xsZWRSZWYuY3VycmVudDtcbiAgICAgIHZhciBfbmFtZUNhY2hlJGN1cnJlbnQgPSBuYW1lQ2FjaGUuY3VycmVudCxcbiAgICAgICAgICBjb21wb25lbnROYW1lID0gX25hbWVDYWNoZSRjdXJyZW50LmNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgY29udHJvbGxlZFByb3BOYW1lID0gX25hbWVDYWNoZSRjdXJyZW50LmNvbnRyb2xsZWRQcm9wTmFtZTtcbiAgICAgIHZhciBpc0NvbnRyb2xsZWQgPSBjb250cm9sbGVkVmFsdWUgIT0gbnVsbDtcblxuICAgICAgaWYgKHdhc0NvbnRyb2xsZWQgIT09IGlzQ29udHJvbGxlZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gXCIgKyAod2FzQ29udHJvbGxlZCA/IFwiXCIgOiBcInVuXCIpICsgXCJjb250cm9sbGVkIGBcIiArIGNvbnRyb2xsZWRQcm9wTmFtZSArIFwiYCBzdGF0ZSBvZiBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiB0byBiZSBcIiArICh3YXNDb250cm9sbGVkID8gXCJ1blwiIDogXCJcIikgKyBcImNvbnRyb2xsZWQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSB1bmRlZmluZWQgdG8gYSBkZWZpbmVkIHZhbHVlLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC5cXG4gICAgICBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzXCIpO1xuICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVkVmFsdWVdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBjaGVja1N0eWxlcywgdXNlQ2hlY2tTdHlsZXMsIHVzZUNvbnRyb2xsZWRTd2l0Y2hXYXJuaW5nLCB1c2VTdGF0ZUxvZ2dlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/dev-utils/dist/reach-utils-dev-utils.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/make-id/dist/reach-utils-make-id.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@reach/utils/make-id/dist/reach-utils-make-id.esm.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeId\": function() { return /* binding */ makeId; }\n/* harmony export */ });\n/**\n * Joins strings to format IDs for compound components.\n *\n * @param args\n */\nfunction makeId() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.filter(function (val) {\n    return val != null;\n  }).join(\"--\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL21ha2UtaWQvZGlzdC9yZWFjaC11dGlscy1tYWtlLWlkLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL21ha2UtaWQvZGlzdC9yZWFjaC11dGlscy1tYWtlLWlkLmVzbS5qcz84YTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSm9pbnMgc3RyaW5ncyB0byBmb3JtYXQgSURzIGZvciBjb21wb3VuZCBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSBhcmdzXG4gKi9cbmZ1bmN0aW9uIG1ha2VJZCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBhcmdzLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuICB9KS5qb2luKFwiLS1cIik7XG59XG5cbmV4cG9ydCB7IG1ha2VJZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/make-id/dist/reach-utils-make-id.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/noop/dist/reach-utils-noop.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@reach/utils/noop/dist/reach-utils-noop.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"noop\": function() { return /* binding */ noop; }\n/* harmony export */ });\nfunction noop() {}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL25vb3AvZGlzdC9yZWFjaC11dGlscy1ub29wLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvdXRpbHMvbm9vcC9kaXN0L3JlYWNoLXV0aWxzLW5vb3AuZXNtLmpzP2RhZDAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCB7IG5vb3AgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/noop/dist/reach-utils-noop.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/owner-document/dist/reach-utils-owner-document.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@reach/utils/owner-document/dist/reach-utils-owner-document.esm.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOwnerDocument\": function() { return /* binding */ getOwnerDocument; },\n/* harmony export */   \"getOwnerWindow\": function() { return /* binding */ getOwnerWindow; }\n/* harmony export */ });\n/* harmony import */ var _can_use_dom_dist_reach_utils_can_use_dom_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../can-use-dom/dist/reach-utils-can-use-dom.esm.js */ \"./node_modules/@reach/utils/can-use-dom/dist/reach-utils-can-use-dom.esm.js\");\n\n\n/**\n * Get an element's owner document. Useful when components are used in iframes\n * or other environments like dev tools.\n *\n * @param element\n */\n\nfunction getOwnerDocument(element) {\n  return (0,_can_use_dom_dist_reach_utils_can_use_dom_esm_js__WEBPACK_IMPORTED_MODULE_0__.canUseDOM)() ? element ? element.ownerDocument : document : null;\n}\n/**\n * TODO: Remove in 1.0\n */\n\nfunction getOwnerWindow(element) {\n  var ownerDocument = getOwnerDocument(element);\n  return ownerDocument ? ownerDocument.defaultView || window : null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL293bmVyLWRvY3VtZW50L2Rpc3QvcmVhY2gtdXRpbHMtb3duZXItZG9jdW1lbnQuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywyRkFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy9vd25lci1kb2N1bWVudC9kaXN0L3JlYWNoLXV0aWxzLW93bmVyLWRvY3VtZW50LmVzbS5qcz83ZjI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNhblVzZURPTSB9IGZyb20gJy4uLy4uL2Nhbi11c2UtZG9tL2Rpc3QvcmVhY2gtdXRpbHMtY2FuLXVzZS1kb20uZXNtLmpzJztcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIG93bmVyIGRvY3VtZW50LiBVc2VmdWwgd2hlbiBjb21wb25lbnRzIGFyZSB1c2VkIGluIGlmcmFtZXNcbiAqIG9yIG90aGVyIGVudmlyb25tZW50cyBsaWtlIGRldiB0b29scy5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gY2FuVXNlRE9NKCkgPyBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQgOiBudWxsO1xufVxuLyoqXG4gKiBUT0RPOiBSZW1vdmUgaW4gMS4wXG4gKi9cblxuZnVuY3Rpb24gZ2V0T3duZXJXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCk7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRPd25lckRvY3VtZW50LCBnZXRPd25lcldpbmRvdyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/owner-document/dist/reach-utils-owner-document.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isBoolean\": function() { return /* binding */ isBoolean; },\n/* harmony export */   \"isFunction\": function() { return /* binding */ isFunction; },\n/* harmony export */   \"isNumber\": function() { return /* binding */ isNumber; },\n/* harmony export */   \"isString\": function() { return /* binding */ isString; }\n/* harmony export */ });\n/**\n * Checks whether or not a value is a boolean.\n *\n * @param value\n */\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n/**\n * Checks whether or not a value is a function.\n *\n * @param value\n */\n\nfunction isFunction(value) {\n  // eslint-disable-next-line eqeqeq\n  return !!(value && {}.toString.call(value) == \"[object Function]\");\n}\n/**\n * Checks whether or not a value is a number.\n *\n * @param value\n */\n\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\n/**\n * Checks whether or not a value is a string.\n *\n * @param value\n */\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3R5cGUtY2hlY2svZGlzdC9yZWFjaC11dGlscy10eXBlLWNoZWNrLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvdXRpbHMvdHlwZS1jaGVjay9kaXN0L3JlYWNoLXV0aWxzLXR5cGUtY2hlY2suZXNtLmpzP2MwMTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgcmV0dXJuICEhKHZhbHVlICYmIHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpID09IFwiW29iamVjdCBGdW5jdGlvbl1cIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IHsgaXNCb29sZWFuLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNTdHJpbmcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/type-check/dist/reach-utils-type-check.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/use-force-update/dist/reach-utils-use-force-update.esm.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@reach/utils/use-force-update/dist/reach-utils-use-force-update.esm.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useForceUpdate\": function() { return /* binding */ useForceUpdate; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Forces a re-render, similar to `forceUpdate` in class components.\n */\n\nfunction useForceUpdate() {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Object.create(null)),\n      dispatch = _useState[1];\n\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    dispatch(Object.create(null));\n  }, []);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUvZGlzdC9yZWFjaC11dGlscy11c2UtZm9yY2UtdXBkYXRlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwrQ0FBUTtBQUMxQjs7QUFFQSxTQUFTLGtEQUFXO0FBQ3BCO0FBQ0EsR0FBRztBQUNIOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUvZGlzdC9yZWFjaC11dGlscy11c2UtZm9yY2UtdXBkYXRlLmVzbS5qcz81MDMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBGb3JjZXMgYSByZS1yZW5kZXIsIHNpbWlsYXIgdG8gYGZvcmNlVXBkYXRlYCBpbiBjbGFzcyBjb21wb25lbnRzLlxuICovXG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoT2JqZWN0LmNyZWF0ZShudWxsKSksXG4gICAgICBkaXNwYXRjaCA9IF91c2VTdGF0ZVsxXTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGRpc3BhdGNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9LCBbXSk7XG59XG5cbmV4cG9ydCB7IHVzZUZvcmNlVXBkYXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/use-force-update/dist/reach-utils-use-force-update.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useIsomorphicLayoutEffect\": function() { return /* binding */ useIsomorphicLayoutEffect; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _can_use_dom_dist_reach_utils_can_use_dom_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../can-use-dom/dist/reach-utils-can-use-dom.esm.js */ \"./node_modules/@reach/utils/can-use-dom/dist/reach-utils-can-use-dom.esm.js\");\n\n\n\n/**\n * React currently throws a warning when using useLayoutEffect on the server. To\n * get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\n * ensure we don't get a render flash for certain operations, but we may also\n * need affected components to render on the server. One example is when setting\n * a component's descendants to retrieve their index values.\n *\n * Important to note that using this hook as an escape hatch will break the\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\n * any server/client mismatch.\n *\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\n * likely that the component in question shouldn't be rendered on the server at\n * all, so a better approach would be to lazily render those in a parent\n * component after client-side hydration.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n *\n * @param effect\n * @param deps\n */\n\nvar useIsomorphicLayoutEffect = /*#__PURE__*/(0,_can_use_dom_dist_reach_utils_can_use_dom_esm_js__WEBPACK_IMPORTED_MODULE_1__.canUseDOM)() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QvZGlzdC9yZWFjaC11dGlscy11c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0LmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBQytCOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLDJGQUFTLEtBQUssa0RBQWUsR0FBRyw0Q0FBUzs7QUFFakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0L2Rpc3QvcmVhY2gtdXRpbHMtdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdC5lc20uanM/OWQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNhblVzZURPTSB9IGZyb20gJy4uLy4uL2Nhbi11c2UtZG9tL2Rpc3QvcmVhY2gtdXRpbHMtY2FuLXVzZS1kb20uZXNtLmpzJztcblxuLyoqXG4gKiBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLiBUb1xuICogZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbiAqIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci4gV2Ugb2NjYXNpb25hbGx5IG5lZWQgdXNlTGF5b3V0RWZmZWN0IHRvXG4gKiBlbnN1cmUgd2UgZG9uJ3QgZ2V0IGEgcmVuZGVyIGZsYXNoIGZvciBjZXJ0YWluIG9wZXJhdGlvbnMsIGJ1dCB3ZSBtYXkgYWxzb1xuICogbmVlZCBhZmZlY3RlZCBjb21wb25lbnRzIHRvIHJlbmRlciBvbiB0aGUgc2VydmVyLiBPbmUgZXhhbXBsZSBpcyB3aGVuIHNldHRpbmdcbiAqIGEgY29tcG9uZW50J3MgZGVzY2VuZGFudHMgdG8gcmV0cmlldmUgdGhlaXIgaW5kZXggdmFsdWVzLlxuICpcbiAqIEltcG9ydGFudCB0byBub3RlIHRoYXQgdXNpbmcgdGhpcyBob29rIGFzIGFuIGVzY2FwZSBoYXRjaCB3aWxsIGJyZWFrIHRoZVxuICogZXNsaW50IGRlcGVuZGVuY3kgd2FybmluZ3MgdW5sZXNzIHlvdSByZW5hbWUgdGhlIGltcG9ydCB0byBgdXNlTGF5b3V0RWZmZWN0YC5cbiAqIFVzZSBzcGFyaW5nbHkgb25seSB3aGVuIHRoZSBlZmZlY3Qgd29uJ3QgZWZmZWN0IHRoZSByZW5kZXJlZCBIVE1MIHRvIGF2b2lkXG4gKiBhbnkgc2VydmVyL2NsaWVudCBtaXNtYXRjaC5cbiAqXG4gKiBJZiBhIHVzZUxheW91dEVmZmVjdCBpcyBuZWVkZWQgYW5kIHRoZSByZXN1bHQgd291bGQgY3JlYXRlIGEgbWlzbWF0Y2gsIGl0J3NcbiAqIGxpa2VseSB0aGF0IHRoZSBjb21wb25lbnQgaW4gcXVlc3Rpb24gc2hvdWxkbid0IGJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgYXRcbiAqIGFsbCwgc28gYSBiZXR0ZXIgYXBwcm9hY2ggd291bGQgYmUgdG8gbGF6aWx5IHJlbmRlciB0aG9zZSBpbiBhIHBhcmVudFxuICogY29tcG9uZW50IGFmdGVyIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi5cbiAqXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9nYWVhcm9uL2U3ZDk3Y2RmMzhhMjkwNzkyNGVhMTJlNGViZGYzYzg1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZWFjdC1yZWR1eC9ibG9iL21hc3Rlci9zcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC5qc1xuICpcbiAqIEBwYXJhbSBlZmZlY3RcbiAqIEBwYXJhbSBkZXBzXG4gKi9cblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiNfX1BVUkVfXyovY2FuVXNlRE9NKCkgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmV4cG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/use-isomorphic-layout-effect/dist/reach-utils-use-isomorphic-layout-effect.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/use-stateful-ref-value/dist/reach-utils-use-stateful-ref-value.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@reach/utils/use-stateful-ref-value/dist/reach-utils-use-stateful-ref-value.esm.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useStatefulRefValue\": function() { return /* binding */ useStatefulRefValue; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction useStatefulRefValue(ref, initialState) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (refValue) {\n    ref.current = refValue;\n    setState(refValue); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return [state, callbackRef];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS1zdGF0ZWZ1bC1yZWYtdmFsdWUvZGlzdC9yZWFjaC11dGlscy11c2Utc3RhdGVmdWwtcmVmLXZhbHVlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0Esa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7O0FBRUEsb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0Esd0JBQXdCO0FBQ3hCLEdBQUc7QUFDSDtBQUNBOztBQUUrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS1zdGF0ZWZ1bC1yZWYtdmFsdWUvZGlzdC9yZWFjaC11dGlscy11c2Utc3RhdGVmdWwtcmVmLXZhbHVlLmVzbS5qcz8xNjk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlU3RhdGVmdWxSZWZWYWx1ZShyZWYsIGluaXRpYWxTdGF0ZSkge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSxcbiAgICAgIHN0YXRlID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0U3RhdGUgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJlZlZhbHVlKSB7XG4gICAgcmVmLmN1cnJlbnQgPSByZWZWYWx1ZTtcbiAgICBzZXRTdGF0ZShyZWZWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gW3N0YXRlLCBjYWxsYmFja1JlZl07XG59XG5cbmV4cG9ydCB7IHVzZVN0YXRlZnVsUmVmVmFsdWUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/use-stateful-ref-value/dist/reach-utils-use-stateful-ref-value.esm.js\n");

/***/ }),

/***/ "./node_modules/@reach/utils/use-update-effect/dist/reach-utils-use-update-effect.esm.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@reach/utils/use-update-effect/dist/reach-utils-use-update-effect.esm.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useUpdateEffect\": function() { return /* binding */ useUpdateEffect; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Call an effect after a component update, skipping the initial mount.\n *\n * @param effect Effect to call\n * @param deps Effect dependency list\n */\nfunction useUpdateEffect(effect, deps) {\n  var mounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL3V0aWxzL3VzZS11cGRhdGUtZWZmZWN0L2Rpc3QvcmVhY2gtdXRpbHMtdXNlLXVwZGF0ZS1lZmZlY3QuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQU07QUFDdEIsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy91c2UtdXBkYXRlLWVmZmVjdC9kaXN0L3JlYWNoLXV0aWxzLXVzZS11cGRhdGUtZWZmZWN0LmVzbS5qcz8xNzJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENhbGwgYW4gZWZmZWN0IGFmdGVyIGEgY29tcG9uZW50IHVwZGF0ZSwgc2tpcHBpbmcgdGhlIGluaXRpYWwgbW91bnQuXG4gKlxuICogQHBhcmFtIGVmZmVjdCBFZmZlY3QgdG8gY2FsbFxuICogQHBhcmFtIGRlcHMgRWZmZWN0IGRlcGVuZGVuY3kgbGlzdFxuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVFZmZlY3QoZWZmZWN0LCBkZXBzKSB7XG4gIHZhciBtb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobW91bnRlZC5jdXJyZW50KSB7XG4gICAgICBlZmZlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB9LCBkZXBzKTtcbn1cblxuZXhwb3J0IHsgdXNlVXBkYXRlRWZmZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@reach/utils/use-update-effect/dist/reach-utils-use-update-effect.esm.js\n");

/***/ }),

/***/ "./node_modules/@react-google-maps/api/dist/esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-google-maps/api/dist/esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Autocomplete\": function() { return /* binding */ Autocomplete; },\n/* harmony export */   \"BicyclingLayer\": function() { return /* binding */ BicyclingLayer; },\n/* harmony export */   \"Circle\": function() { return /* binding */ Circle; },\n/* harmony export */   \"Data\": function() { return /* binding */ Data; },\n/* harmony export */   \"DirectionsRenderer\": function() { return /* binding */ DirectionsRenderer; },\n/* harmony export */   \"DirectionsService\": function() { return /* binding */ DirectionsService; },\n/* harmony export */   \"DistanceMatrixService\": function() { return /* binding */ DistanceMatrixService; },\n/* harmony export */   \"DrawingManager\": function() { return /* binding */ DrawingManager; },\n/* harmony export */   \"GoogleMap\": function() { return /* binding */ GoogleMap; },\n/* harmony export */   \"GoogleMapsMarkerClusterer\": function() { return /* binding */ index_esm; },\n/* harmony export */   \"GoogleMarkerClusterer\": function() { return /* binding */ GoogleMarkerClusterer; },\n/* harmony export */   \"GroundOverlay\": function() { return /* binding */ GroundOverlay; },\n/* harmony export */   \"HeatmapLayer\": function() { return /* binding */ HeatmapLayer; },\n/* harmony export */   \"InfoBox\": function() { return /* binding */ InfoBoxComponent; },\n/* harmony export */   \"InfoWindow\": function() { return /* binding */ InfoWindow; },\n/* harmony export */   \"KmlLayer\": function() { return /* binding */ KmlLayer; },\n/* harmony export */   \"LoadScript\": function() { return /* binding */ LoadScript; },\n/* harmony export */   \"LoadScriptNext\": function() { return /* binding */ LoadScriptNext$1; },\n/* harmony export */   \"MapContext\": function() { return /* binding */ MapContext; },\n/* harmony export */   \"Marker\": function() { return /* binding */ Marker; },\n/* harmony export */   \"MarkerClusterer\": function() { return /* binding */ ClustererComponent; },\n/* harmony export */   \"OverlayView\": function() { return /* binding */ OverlayView; },\n/* harmony export */   \"Polygon\": function() { return /* binding */ Polygon; },\n/* harmony export */   \"Polyline\": function() { return /* binding */ Polyline; },\n/* harmony export */   \"Rectangle\": function() { return /* binding */ Rectangle; },\n/* harmony export */   \"StandaloneSearchBox\": function() { return /* binding */ StandaloneSearchBox; },\n/* harmony export */   \"StreetViewPanorama\": function() { return /* binding */ StreetViewPanorama; },\n/* harmony export */   \"StreetViewService\": function() { return /* binding */ StreetViewService; },\n/* harmony export */   \"TrafficLayer\": function() { return /* binding */ TrafficLayer; },\n/* harmony export */   \"TransitLayer\": function() { return /* binding */ TransitLayer; },\n/* harmony export */   \"useGoogleMap\": function() { return /* binding */ useGoogleMap; },\n/* harmony export */   \"useJsApiLoader\": function() { return /* binding */ useJsApiLoader; },\n/* harmony export */   \"useLoadScript\": function() { return /* binding */ useLoadScript; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar NODE_ENV = \"development\";\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nvar invariant_1 = invariant;\n\nconst MapContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useGoogleMap() {\n    invariant_1(!!react__WEBPACK_IMPORTED_MODULE_0__.useContext, 'useGoogleMap is React hook and requires React version 16.8+');\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MapContext);\n    invariant_1(!!map, 'useGoogleMap needs a GoogleMap available up in the tree');\n    return map;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst reduce = (obj, fn, acc) => {\n    return Object.keys(obj).reduce(function reducer(newAcc, key) {\n        return fn(newAcc, obj[key], key);\n    }, acc);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction forEach(obj, fn) {\n    Object.keys(obj).forEach(function iterator(key) {\n        return fn(obj[key], key);\n    });\n}\n\n/* global google */\nconst applyUpdaterToNextProps = (\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nupdaterMap, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprevProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnextProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const map = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const iter = (fn, key) => {\n        const nextValue = nextProps[key];\n        if (nextValue !== prevProps[key]) {\n            map[key] = nextValue;\n            fn(instance, nextValue);\n        }\n    };\n    forEach(updaterMap, iter);\n    return map;\n};\nfunction registerEvents(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprops, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance, eventMap) {\n    const registeredList = reduce(eventMap, function reducer(acc, googleEventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onEventName) {\n        if (typeof props[onEventName] === 'function') {\n            acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));\n        }\n        return acc;\n    }, []);\n    return registeredList;\n}\nfunction unregisterEvent(registered) {\n    google.maps.event.removeListener(registered);\n}\nfunction unregisterEvents(events = []) {\n    events.forEach(unregisterEvent);\n}\nfunction applyUpdatersToPropsAndRegisterEvents({ updaterMap, eventMap, prevProps, nextProps, instance, }) {\n    const registeredEvents = registerEvents(nextProps, instance, eventMap);\n    applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);\n    return registeredEvents;\n}\n\nconst eventMap$i = {\n    onDblClick: 'dblclick',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMapTypeIdChanged: 'maptypeid_changed',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseDown: 'mousedown',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n    onTilesLoaded: 'tilesloaded',\n    onBoundsChanged: 'bounds_changed',\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onDrag: 'drag',\n    onHeadingChanged: 'heading_changed',\n    onIdle: 'idle',\n    onProjectionChanged: 'projection_changed',\n    onResize: 'resize',\n    onTiltChanged: 'tilt_changed',\n    onZoomChanged: 'zoom_changed',\n};\nconst updaterMap$i = {\n    extraMapTypes(map, extra) {\n        extra.forEach(function forEachExtra(it, i) {\n            map.mapTypes.set(String(i), it);\n        });\n    },\n    center(map, center) {\n        map.setCenter(center);\n    },\n    clickableIcons(map, clickable) {\n        map.setClickableIcons(clickable);\n    },\n    heading(map, heading) {\n        map.setHeading(heading);\n    },\n    mapTypeId(map, mapTypeId) {\n        map.setMapTypeId(mapTypeId);\n    },\n    options(map, options) {\n        map.setOptions(options);\n    },\n    streetView(map, streetView) {\n        map.setStreetView(streetView);\n    },\n    tilt(map, tilt) {\n        map.setTilt(tilt);\n    },\n    zoom(map, zoom) {\n        map.setZoom(zoom);\n    },\n};\n// function GoogleMapFunctional({ children, options, id, mapContainerStyle, center, clickableIcons, extraMapTypes, heading, mapContainerClassName, mapTypeId, onBoundsChanged, onCenterChanged, onClick, onDblClick, onDrag, onDragEnd, onDragStart, onHeadingChanged, onIdle, onProjectionChanged, onResize, onTiltChanged, onLoad }: GoogleMapProps): JSX.Element {\n//   const [map, setMap] = React.useState<google.maps.Map | null>(null)\n//   const ref = React.useRef<HTMLDivElement | null>(null)\n//   const getInstance = React.useCallback(() => {\n//     if (ref.current === null) {\n//       return null\n//     }\n//     return new google.maps.Map(ref.current, options)\n//   }, [options])\n//   React.useEffect(() => {\n//   }, [])\n//   const panTo = React.useCallback((latLng: google.maps.LatLng | google.maps.LatLngLiteral): void => {\n//     const map = getInstance()\n//     if (map) {\n//       map.panTo(latLng)\n//     }\n//   }, [])\n//   React.useEffect(() => {\n//     const map = getInstance()\n//   }, [])\n//   return (\n//     <div\n//         id={id}\n//         ref={ref}\n//         style={mapContainerStyle}\n//         className={mapContainerClassName}\n//       >\n//         <MapContext.Provider value={map}>\n//           {map !== null ? children : <></>}\n//         </MapContext.Provider>\n//       </div>\n//   )\n// }\nclass GoogleMap extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            map: null,\n        };\n        this.registeredEvents = [];\n        this.mapRef = null;\n        this.getInstance = () => {\n            if (this.mapRef === null) {\n                return null;\n            }\n            return new google.maps.Map(this.mapRef, this.props.options);\n        };\n        this.panTo = (latLng) => {\n            const map = this.getInstance();\n            if (map) {\n                map.panTo(latLng);\n            }\n        };\n        this.setMapCallback = () => {\n            if (this.state.map !== null) {\n                if (this.props.onLoad) {\n                    this.props.onLoad(this.state.map);\n                }\n            }\n        };\n        this.getRef = (ref) => {\n            this.mapRef = ref;\n        };\n    }\n    componentDidMount() {\n        const map = this.getInstance();\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$i,\n            eventMap: eventMap$i,\n            prevProps: {},\n            nextProps: this.props,\n            instance: map,\n        });\n        this.setState(function setMap() {\n            return {\n                map,\n            };\n        }, this.setMapCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.map !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$i,\n                eventMap: eventMap$i,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.map,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.map !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.map);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    }\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(MapContext.Provider, { value: this.state.map }, this.state.map !== null ? this.props.children : react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null))));\n    }\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest$1(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nconst isBrowser = typeof document !== 'undefined';\n\nconst injectScript = ({ url, id, nonce }) => {\n    if (!isBrowser) {\n        return Promise.reject(new Error('document is undefined'));\n    }\n    return new Promise(function injectScriptCallback(resolve, reject) {\n        const existingScript = document.getElementById(id);\n        const windowWithGoogleMap = window;\n        if (existingScript) {\n            // Same script id/url: keep same script\n            const dataStateAttribute = existingScript.getAttribute('data-state');\n            if (existingScript.src === url && dataStateAttribute !== 'error') {\n                if (dataStateAttribute === 'ready') {\n                    return resolve(id);\n                }\n                else {\n                    const originalInitMap = windowWithGoogleMap.initMap;\n                    const originalErrorCallback = existingScript.onerror;\n                    windowWithGoogleMap.initMap = function initMap() {\n                        if (originalInitMap) {\n                            originalInitMap();\n                        }\n                        resolve(id);\n                    };\n                    existingScript.onerror = function (err) {\n                        if (originalErrorCallback) {\n                            originalErrorCallback(err);\n                        }\n                        reject(err);\n                    };\n                    return;\n                }\n            }\n            // Same script id, but either\n            // 1. requested URL is different\n            // 2. script failed to load\n            else {\n                existingScript.remove();\n            }\n        }\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        script.id = id;\n        script.async = true;\n        script.nonce = nonce;\n        script.onerror = function onerror(err) {\n            script.setAttribute('data-state', 'error');\n            reject(err);\n        };\n        windowWithGoogleMap.initMap = function onload() {\n            script.setAttribute('data-state', 'ready');\n            resolve(id);\n        };\n        document.head.appendChild(script);\n    }).catch(err => {\n        console.error('injectScript error: ', err);\n        throw err;\n    });\n};\n\nconst isRobotoStyle = (element) => {\n    // roboto font download\n    if (element.href &&\n        element.href.indexOf('https://fonts.googleapis.com/css?family=Roboto') ===\n            0) {\n        return true;\n    }\n    // roboto style elements\n    if (element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        element.styleSheet &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        element.styleSheet.cssText &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        element.styleSheet.cssText.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        element.styleSheet.cssText = '';\n        return true;\n    }\n    // roboto style elements for other browsers\n    if (element.tagName.toLowerCase() === 'style' &&\n        element.innerHTML &&\n        element.innerHTML.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        element.innerHTML = '';\n        return true;\n    }\n    // when google tries to add empty style\n    if (element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        !element.styleSheet &&\n        !element.innerHTML) {\n        return true;\n    }\n    return false;\n};\n// Preventing the Google Maps library from downloading an extra font\nconst preventGoogleFonts = () => {\n    // we override these methods only for one particular head element\n    // default methods for other elements are not affected\n    const head = document.getElementsByTagName('head')[0];\n    const trueInsertBefore = head.insertBefore.bind(head);\n    // TODO: adding return before reflect solves the TS issue\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    head.insertBefore = function insertBefore(newElement, referenceElement) {\n        if (!isRobotoStyle(newElement)) {\n            Reflect.apply(trueInsertBefore, head, [newElement, referenceElement]);\n        }\n    };\n    const trueAppend = head.appendChild.bind(head);\n    // TODO: adding return before reflect solves the TS issue\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    head.appendChild = function appendChild(textNode) {\n        if (!isRobotoStyle(textNode)) {\n            Reflect.apply(trueAppend, head, [textNode]);\n        }\n    };\n};\n\nfunction makeLoadScriptUrl({ googleMapsApiKey, googleMapsClientId, version = 'weekly', language, region, libraries, channel, mapIds }) {\n    const params = [];\n    invariant_1((googleMapsApiKey && googleMapsClientId) || !(googleMapsApiKey && googleMapsClientId), 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.');\n    if (googleMapsApiKey) {\n        params.push(`key=${googleMapsApiKey}`);\n    }\n    else if (googleMapsClientId) {\n        params.push(`client=${googleMapsClientId}`);\n    }\n    if (version) {\n        params.push(`v=${version}`);\n    }\n    if (language) {\n        params.push(`language=${language}`);\n    }\n    if (region) {\n        params.push(`region=${region}`);\n    }\n    if (libraries && libraries.length) {\n        params.push(`libraries=${libraries.sort().join(',')}`);\n    }\n    if (channel) {\n        params.push(`channel=${channel}`);\n    }\n    if (mapIds && mapIds.length) {\n        params.push(`map_ids=${mapIds.join(',')}`);\n    }\n    params.push('callback=initMap');\n    return `https://maps.googleapis.com/maps/api/js?${params.join('&')}`;\n}\n\nlet cleaningUp = false;\nfunction DefaultLoadingElement() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, `Loading...`);\n}\nconst defaultLoadScriptProps = {\n    id: 'script-loader',\n    version: 'weekly',\n};\nclass LoadScript extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.check = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.state = {\n            loaded: false,\n        };\n        this.cleanupCallback = () => {\n            // @ts-ignore\n            delete window.google.maps;\n            this.injectScript();\n        };\n        this.isCleaningUp = () => __awaiter(this, void 0, void 0, function* () {\n            function promiseCallback(resolve) {\n                if (!cleaningUp) {\n                    resolve();\n                }\n                else {\n                    if (isBrowser) {\n                        const timer = window.setInterval(function interval() {\n                            if (!cleaningUp) {\n                                window.clearInterval(timer);\n                                resolve();\n                            }\n                        }, 1);\n                    }\n                }\n                return;\n            }\n            return new Promise(promiseCallback);\n        });\n        this.cleanup = () => {\n            cleaningUp = true;\n            const script = document.getElementById(this.props.id);\n            if (script && script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n            Array.prototype.slice\n                .call(document.getElementsByTagName('script'))\n                .filter(function filter(script) {\n                return typeof script.src === 'string' && script.src.includes('maps.googleapis');\n            })\n                .forEach(function forEach(script) {\n                if (script.parentNode) {\n                    script.parentNode.removeChild(script);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('link'))\n                .filter(function filter(link) {\n                return (link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans');\n            })\n                .forEach(function forEach(link) {\n                if (link.parentNode) {\n                    link.parentNode.removeChild(link);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('style'))\n                .filter(function filter(style) {\n                return (style.innerText !== undefined &&\n                    style.innerText.length > 0 &&\n                    style.innerText.includes('.gm-'));\n            })\n                .forEach(function forEach(style) {\n                if (style.parentNode) {\n                    style.parentNode.removeChild(style);\n                }\n            });\n        };\n        this.injectScript = () => {\n            if (this.props.preventGoogleFontsLoading) {\n                preventGoogleFonts();\n            }\n            invariant_1(!!this.props.id, 'LoadScript requires \"id\" prop to be a string: %s', this.props.id);\n            const injectScriptOptions = {\n                id: this.props.id,\n                nonce: this.props.nonce,\n                url: makeLoadScriptUrl(this.props),\n            };\n            injectScript(injectScriptOptions)\n                .then(() => {\n                if (this.props.onLoad) {\n                    this.props.onLoad();\n                }\n                this.setState(function setLoaded() {\n                    return {\n                        loaded: true,\n                    };\n                });\n                return;\n            })\n                .catch(err => {\n                if (this.props.onError) {\n                    this.props.onError(err);\n                }\n                console.error(`\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (${this\n                    .props.googleMapsApiKey || '-'}) or Client ID (${this.props.googleMapsClientId ||\n                    '-'}) to <LoadScript />\n          Otherwise it is a Network issue.\n        `);\n            });\n        };\n    }\n    componentDidMount() {\n        if (isBrowser) {\n            if (window.google && window.google.maps && !cleaningUp) {\n                console.error('google api is already presented');\n                return;\n            }\n            this.isCleaningUp()\n                .then(this.injectScript)\n                .catch(function error(err) {\n                console.error('Error at injecting script after cleaning up: ', err);\n            });\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (this.props.libraries !== prevProps.libraries) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        if (isBrowser && prevProps.language !== this.props.language) {\n            this.cleanup();\n            // TODO: refactor to use gDSFP maybe... wait for hooks refactoring.\n            // eslint-disable-next-line react/no-did-update-set-state\n            this.setState(function setLoaded() {\n                return {\n                    loaded: false,\n                };\n            }, this.cleanupCallback);\n        }\n    }\n    componentWillUnmount() {\n        if (isBrowser) {\n            this.cleanup();\n            const timeoutCallback = () => {\n                if (!this.check.current) {\n                    // @ts-ignore\n                    delete window.google;\n                    cleaningUp = false;\n                }\n            };\n            window.setTimeout(timeoutCallback, 1);\n            if (this.props.onUnmount) {\n                this.props.onUnmount();\n            }\n        }\n    }\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.check }),\n            this.state.loaded\n                ? this.props.children\n                : this.props.loadingElement || react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultLoadingElement, null)));\n    }\n}\nLoadScript.defaultProps = defaultLoadScriptProps;\n\n/* eslint-disable filenames/match-regex */\nlet previouslyLoadedUrl;\nfunction useLoadScript({ id = defaultLoadScriptProps.id, version = defaultLoadScriptProps.version, nonce, googleMapsApiKey, googleMapsClientId, language, region, libraries, preventGoogleFontsLoading, channel, mapIds, }) {\n    const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const [isLoaded, setLoaded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [loadError, setLoadError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function trackMountedState() {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function applyPreventGoogleFonts() {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function validateLoadedState() {\n        if (isLoaded) {\n            invariant_1(!!window.google, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.');\n        }\n    }, [isLoaded]);\n    const url = makeLoadScriptUrl({\n        version,\n        googleMapsApiKey,\n        googleMapsClientId,\n        language,\n        region,\n        libraries,\n        channel,\n        mapIds\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function loadScriptAndModifyLoadedState() {\n        if (!isBrowser) {\n            return;\n        }\n        function setLoadedIfMounted() {\n            if (isMounted.current) {\n                setLoaded(true);\n                previouslyLoadedUrl = url;\n            }\n        }\n        if (window.google && window.google.maps && previouslyLoadedUrl === url) {\n            setLoadedIfMounted();\n            return;\n        }\n        injectScript({ id, url, nonce })\n            .then(setLoadedIfMounted)\n            .catch(function handleInjectError(err) {\n            if (isMounted.current) {\n                setLoadError(err);\n            }\n            console.warn(`\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (${googleMapsApiKey ||\n                '-'}) or Client ID (${googleMapsClientId || '-'})\n        Otherwise it is a Network issue.\n      `);\n            console.error(err);\n        });\n    }, [id, url, nonce]);\n    const prevLibraries = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function checkPerformance() {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded, loadError, url };\n}\n\nconst defaultLoadingElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultLoadingElement, null);\nfunction LoadScriptNext(_a) {\n    var { loadingElement, onLoad, onError, onUnmount, children } = _a, hookOptions = __rest$1(_a, [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"]);\n    const { isLoaded, loadError } = useLoadScript(hookOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function handleOnLoad() {\n        if (isLoaded && typeof onLoad === 'function') {\n            onLoad();\n        }\n    }, [isLoaded, onLoad]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function handleOnError() {\n        if (loadError && typeof onError === 'function') {\n            onError(loadError);\n        }\n    }, [loadError, onError]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function handleOnUnmount() {\n        return () => {\n            if (onUnmount) {\n                onUnmount();\n            }\n        };\n    }, [onUnmount]);\n    return isLoaded ? children : loadingElement || defaultLoadingElement;\n}\nvar LoadScriptNext$1 = react__WEBPACK_IMPORTED_MODULE_0__.memo(LoadScriptNext);\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at.\r\n *\r\n *      Http://www.apache.org/licenses/LICENSE-2.0.\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ID = \"__googleMapsScriptId\";\r\n/**\r\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\r\n * dynamically using\r\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\r\n * It works by dynamically creating and appending a script node to the the\r\n * document head and wrapping the callback function so as to return a promise.\r\n *\r\n * ```\r\n * const loader = new Loader({\r\n *   apiKey: \"\",\r\n *   version: \"weekly\",\r\n *   libraries: [\"places\"]\r\n * });\r\n *\r\n * loader.load().then((google) => {\r\n *   const map = new google.maps.Map(...)\r\n * })\r\n * ```\r\n */\r\nclass Loader {\r\n    /**\r\n     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\r\n     * using this library, instead the defaults are set by the Google Maps\r\n     * JavaScript API server.\r\n     *\r\n     * ```\r\n     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\r\n     * ```\r\n     */\r\n    constructor({ apiKey, channel, client, id = DEFAULT_ID, libraries = [], language, region, version, mapIds, nonce, retries = 3, url = \"https://maps.googleapis.com/maps/api/js\", }) {\r\n        this.CALLBACK = \"__googleMapsCallback\";\r\n        this.callbacks = [];\r\n        this.done = false;\r\n        this.loading = false;\r\n        this.errors = [];\r\n        this.version = version;\r\n        this.apiKey = apiKey;\r\n        this.channel = channel;\r\n        this.client = client;\r\n        this.id = id || DEFAULT_ID; // Do not allow empty string\r\n        this.libraries = libraries;\r\n        this.language = language;\r\n        this.region = region;\r\n        this.mapIds = mapIds;\r\n        this.nonce = nonce;\r\n        this.retries = retries;\r\n        this.url = url;\r\n        if (Loader.instance) {\r\n            if (!fastDeepEqual(this.options, Loader.instance.options)) {\r\n                throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);\r\n            }\r\n            return Loader.instance;\r\n        }\r\n        Loader.instance = this;\r\n    }\r\n    get options() {\r\n        return {\r\n            version: this.version,\r\n            apiKey: this.apiKey,\r\n            channel: this.channel,\r\n            client: this.client,\r\n            id: this.id,\r\n            libraries: this.libraries,\r\n            language: this.language,\r\n            region: this.region,\r\n            mapIds: this.mapIds,\r\n            nonce: this.nonce,\r\n            url: this.url,\r\n        };\r\n    }\r\n    get failed() {\r\n        return this.done && !this.loading && this.errors.length >= this.retries + 1;\r\n    }\r\n    /**\r\n     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\r\n     *\r\n     * @ignore\r\n     */\r\n    createUrl() {\r\n        let url = this.url;\r\n        url += `?callback=${this.CALLBACK}`;\r\n        if (this.apiKey) {\r\n            url += `&key=${this.apiKey}`;\r\n        }\r\n        if (this.channel) {\r\n            url += `&channel=${this.channel}`;\r\n        }\r\n        if (this.client) {\r\n            url += `&client=${this.client}`;\r\n        }\r\n        if (this.libraries.length > 0) {\r\n            url += `&libraries=${this.libraries.join(\",\")}`;\r\n        }\r\n        if (this.language) {\r\n            url += `&language=${this.language}`;\r\n        }\r\n        if (this.region) {\r\n            url += `&region=${this.region}`;\r\n        }\r\n        if (this.version) {\r\n            url += `&v=${this.version}`;\r\n        }\r\n        if (this.mapIds) {\r\n            url += `&map_ids=${this.mapIds.join(\",\")}`;\r\n        }\r\n        return url;\r\n    }\r\n    deleteScript() {\r\n        const script = document.getElementById(this.id);\r\n        if (script) {\r\n            script.remove();\r\n        }\r\n    }\r\n    /**\r\n     * Load the Google Maps JavaScript API script and return a Promise.\r\n     */\r\n    load() {\r\n        return this.loadPromise();\r\n    }\r\n    /**\r\n     * Load the Google Maps JavaScript API script and return a Promise.\r\n     *\r\n     * @ignore\r\n     */\r\n    loadPromise() {\r\n        return new Promise((resolve, reject) => {\r\n            this.loadCallback((err) => {\r\n                if (!err) {\r\n                    resolve(window.google);\r\n                }\r\n                else {\r\n                    reject(err.error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Load the Google Maps JavaScript API script with a callback.\r\n     */\r\n    loadCallback(fn) {\r\n        this.callbacks.push(fn);\r\n        this.execute();\r\n    }\r\n    /**\r\n     * Set the script on document.\r\n     */\r\n    setScript() {\r\n        if (document.getElementById(this.id)) {\r\n            // TODO wrap onerror callback for cases where the script was loaded elsewhere\r\n            this.callback();\r\n            return;\r\n        }\r\n        const url = this.createUrl();\r\n        const script = document.createElement(\"script\");\r\n        script.id = this.id;\r\n        script.type = \"text/javascript\";\r\n        script.src = url;\r\n        script.onerror = this.loadErrorCallback.bind(this);\r\n        script.defer = true;\r\n        script.async = true;\r\n        if (this.nonce) {\r\n            script.nonce = this.nonce;\r\n        }\r\n        document.head.appendChild(script);\r\n    }\r\n    /**\r\n     * Reset the loader state.\r\n     */\r\n    reset() {\r\n        this.deleteScript();\r\n        this.done = false;\r\n        this.loading = false;\r\n        this.errors = [];\r\n        this.onerrorEvent = null;\r\n    }\r\n    resetIfRetryingFailed() {\r\n        if (this.failed) {\r\n            this.reset();\r\n        }\r\n    }\r\n    loadErrorCallback(e) {\r\n        this.errors.push(e);\r\n        if (this.errors.length <= this.retries) {\r\n            const delay = this.errors.length * Math.pow(2, this.errors.length);\r\n            console.log(`Failed to load Google Maps script, retrying in ${delay} ms.`);\r\n            setTimeout(() => {\r\n                this.deleteScript();\r\n                this.setScript();\r\n            }, delay);\r\n        }\r\n        else {\r\n            this.onerrorEvent = e;\r\n            this.callback();\r\n        }\r\n    }\r\n    setCallback() {\r\n        window.__googleMapsCallback = this.callback.bind(this);\r\n    }\r\n    callback() {\r\n        this.done = true;\r\n        this.loading = false;\r\n        this.callbacks.forEach((cb) => {\r\n            cb(this.onerrorEvent);\r\n        });\r\n        this.callbacks = [];\r\n    }\r\n    execute() {\r\n        this.resetIfRetryingFailed();\r\n        if (this.done) {\r\n            this.callback();\r\n        }\r\n        else {\r\n            // short circuit and warn if google.maps is already loaded\r\n            if (window.google && window.google.maps && window.google.maps.version) {\r\n                console.warn(\"Google Maps already loaded outside @googlemaps/js-api-loader.\" +\r\n                    \"This may result in undesirable behavior as options and script parameters may not match.\");\r\n                this.callback();\r\n                return;\r\n            }\r\n            if (this.loading) ;\r\n            else {\r\n                this.loading = true;\r\n                this.setCallback();\r\n                this.setScript();\r\n            }\r\n        }\r\n    }\r\n}\n\n/* eslint-disable filenames/match-regex */\nfunction useJsApiLoader({ id = defaultLoadScriptProps.id, version = defaultLoadScriptProps.version, nonce, googleMapsApiKey, \n// googleMapsClientId,\nlanguage, region, libraries, preventGoogleFontsLoading, \n// channel,\nmapIds, }) {\n    const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const [isLoaded, setLoaded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [loadError, setLoadError] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function trackMountedState() {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    const loader = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function memo() {\n        return new Loader({\n            id,\n            apiKey: googleMapsApiKey,\n            version,\n            libraries,\n            language,\n            region,\n            mapIds,\n            nonce,\n        });\n    }, [id, googleMapsApiKey, version, libraries, language, region, mapIds, nonce]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function effect() {\n        if (isLoaded) {\n            return;\n        }\n        else {\n            loader.load().then(function then() {\n                if (isMounted.current)\n                    setLoaded(true);\n            })\n                .catch(function onrejected(error) {\n                setLoadError(error);\n            });\n        }\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function applyPreventGoogleFonts() {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    const prevLibraries = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function effect() {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded, loadError };\n}\n\nconst eventMap$h = {};\nconst updaterMap$h = {\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n};\nclass TrafficLayer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            trafficLayer: null,\n        };\n        this.setTrafficLayerCallback = () => {\n            if (this.state.trafficLayer !== null) {\n                if (this.props.onLoad) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.props.onLoad(this.state.trafficLayer);\n                }\n            }\n        };\n        this.registeredEvents = [];\n    }\n    componentDidMount() {\n        const trafficLayer = new google.maps.TrafficLayer(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$h,\n            eventMap: eventMap$h,\n            prevProps: {},\n            nextProps: this.props,\n            instance: trafficLayer,\n        });\n        this.setState(function setTrafficLayer() {\n            return {\n                trafficLayer,\n            };\n        }, this.setTrafficLayerCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.trafficLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$h,\n                eventMap: eventMap$h,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.trafficLayer,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.trafficLayer !== null) {\n            if (this.props.onUnmount) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.props.onUnmount(this.state.trafficLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.state.trafficLayer.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nTrafficLayer.contextType = MapContext;\n\nclass BicyclingLayer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            bicyclingLayer: null,\n        };\n        this.setBicyclingLayerCallback = () => {\n            if (this.state.bicyclingLayer !== null) {\n                // TODO: how is this possibly null if we're doing a null check\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.state.bicyclingLayer.setMap(this.context);\n                if (this.props.onLoad) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.props.onLoad(this.state.bicyclingLayer);\n                }\n            }\n        };\n    }\n    componentDidMount() {\n        const bicyclingLayer = new google.maps.BicyclingLayer();\n        this.setState(function setBicyclingLayer() {\n            return {\n                bicyclingLayer,\n            };\n        }, this.setBicyclingLayerCallback);\n    }\n    componentWillUnmount() {\n        if (this.state.bicyclingLayer !== null) {\n            if (this.props.onUnmount) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.props.onUnmount(this.state.bicyclingLayer);\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.state.bicyclingLayer.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nBicyclingLayer.contextType = MapContext;\n\nclass TransitLayer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            transitLayer: null,\n        };\n        this.setTransitLayerCallback = () => {\n            if (this.state.transitLayer !== null) {\n                // TODO: how is this possibly null if we're doing a null check\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.state.transitLayer.setMap(this.context);\n                if (this.props.onLoad) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.props.onLoad(this.state.transitLayer);\n                }\n            }\n        };\n    }\n    componentDidMount() {\n        const transitLayer = new google.maps.TransitLayer();\n        this.setState(function setTransitLayer() {\n            return {\n                transitLayer,\n            };\n        }, this.setTransitLayerCallback);\n    }\n    componentWillUnmount() {\n        if (this.state.transitLayer !== null) {\n            if (this.props.onUnmount) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.props.onUnmount(this.state.transitLayer);\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.state.transitLayer.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nTransitLayer.contextType = MapContext;\n\n/* globals google */\nconst eventMap$g = {\n    onCircleComplete: 'circlecomplete',\n    onMarkerComplete: 'markercomplete',\n    onOverlayComplete: 'overlaycomplete',\n    onPolygonComplete: 'polygoncomplete',\n    onPolylineComplete: 'polylinecomplete',\n    onRectangleComplete: 'rectanglecomplete',\n};\nconst updaterMap$g = {\n    drawingMode(instance, drawingMode) {\n        instance.setDrawingMode(drawingMode);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n};\nclass DrawingManager extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor(props) {\n        super(props);\n        this.registeredEvents = [];\n        this.state = {\n            drawingManager: null,\n        };\n        this.setDrawingManagerCallback = () => {\n            if (this.state.drawingManager !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.drawingManager);\n            }\n        };\n        invariant_1(!!google.maps.drawing, `Did you include prop libraries={['drawing']} in the URL? %s`, google.maps.drawing);\n    }\n    componentDidMount() {\n        const drawingManager = new google.maps.drawing.DrawingManager(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$g,\n            eventMap: eventMap$g,\n            prevProps: {},\n            nextProps: this.props,\n            instance: drawingManager,\n        });\n        this.setState(function setDrawingManager() {\n            return {\n                drawingManager,\n            };\n        }, this.setDrawingManagerCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.drawingManager !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$g,\n                eventMap: eventMap$g,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.drawingManager,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.drawingManager !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.drawingManager);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.drawingManager.setMap(null);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\nDrawingManager.contextType = MapContext;\n\nconst eventMap$f = {\n    onAnimationChanged: 'animation_changed',\n    onClick: 'click',\n    onClickableChanged: 'clickable_changed',\n    onCursorChanged: 'cursor_changed',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDraggableChanged: 'draggable_changed',\n    onDragStart: 'dragstart',\n    onFlatChanged: 'flat_changed',\n    onIconChanged: 'icon_changed',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onPositionChanged: 'position_changed',\n    onRightClick: 'rightclick',\n    onShapeChanged: 'shape_changed',\n    onTitleChanged: 'title_changed',\n    onVisibleChanged: 'visible_changed',\n    onZindexChanged: 'zindex_changed',\n};\nconst updaterMap$f = {\n    animation(instance, animation) {\n        instance.setAnimation(animation);\n    },\n    clickable(instance, clickable) {\n        instance.setClickable(clickable);\n    },\n    cursor(instance, cursor) {\n        instance.setCursor(cursor);\n    },\n    draggable(instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    icon(instance, icon) {\n        instance.setIcon(icon);\n    },\n    label(instance, label) {\n        instance.setLabel(label);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    opacity(instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    position(instance, position) {\n        instance.setPosition(position);\n    },\n    shape(instance, shape) {\n        instance.setShape(shape);\n    },\n    title(instance, title) {\n        instance.setTitle(title);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex(instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nclass Marker extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n    }\n    componentDidMount() {\n        const markerOptions = Object.assign(Object.assign(Object.assign({}, (this.props.options || {})), (this.props.clusterer ? {} : { map: this.context })), { position: this.props.position });\n        // Unfortunately we can't just do this in the contstructor, because the\n        // `MapContext` might not be filled in yet.\n        this.marker = new google.maps.Marker(markerOptions);\n        if (this.props.clusterer) {\n            this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw);\n        }\n        else {\n            this.marker.setMap(this.context);\n        }\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$f,\n            eventMap: eventMap$f,\n            prevProps: {},\n            nextProps: this.props,\n            instance: this.marker,\n        });\n        if (this.props.onLoad) {\n            this.props.onLoad(this.marker);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (this.marker) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$f,\n                eventMap: eventMap$f,\n                prevProps,\n                nextProps: this.props,\n                instance: this.marker,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.marker) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.marker);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.props.clusterer) {\n                this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw);\n            }\n            else {\n                this.marker && this.marker.setMap(null);\n            }\n        }\n    }\n    render() {\n        let children = null;\n        if (this.props.children) {\n            children = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(this.props.children, child => {\n                if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child)) {\n                    return child;\n                }\n                let elementChild = child;\n                return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(elementChild, { anchor: this.marker });\n            });\n        }\n        return children || null;\n    }\n}\nMarker.contextType = MapContext;\n\nvar ClusterIcon = /** @class */ (function () {\n    function ClusterIcon(cluster, styles) {\n        cluster.getClusterer().extend(ClusterIcon, google.maps.OverlayView);\n        this.cluster = cluster;\n        this.clusterClassName = this.cluster.getClusterer().getClusterClass();\n        this.className = this.clusterClassName;\n        this.styles = styles;\n        this.center = undefined;\n        this.div = null;\n        this.sums = null;\n        this.visible = false;\n        this.boundsChangedListener = null;\n        this.url = '';\n        this.height = 0;\n        this.width = 0;\n        this.anchorText = [0, 0];\n        this.anchorIcon = [0, 0];\n        this.textColor = 'black';\n        this.textSize = 11;\n        this.textDecoration = 'none';\n        this.fontWeight = 'bold';\n        this.fontStyle = 'normal';\n        this.fontFamily = 'Arial,sans-serif';\n        this.backgroundPosition = '0 0';\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n    }\n    ClusterIcon.prototype.onAdd = function () {\n        var _this = this;\n        var cMouseDownInCluster;\n        var cDraggingMapByCluster;\n        this.div = document.createElement('div');\n        this.div.className = this.className;\n        if (this.visible) {\n            this.show();\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.getPanes().overlayMouseTarget.appendChild(this.div);\n        // Fix for Issue 157\n        this.boundsChangedListener = google.maps.event.addListener(\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.getMap(), 'boundschanged', function boundsChanged() {\n            cDraggingMapByCluster = cMouseDownInCluster;\n        });\n        google.maps.event.addDomListener(this.div, 'mousedown', function onMouseDown() {\n            cMouseDownInCluster = true;\n            cDraggingMapByCluster = false;\n        });\n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        google.maps.event.addDomListener(this.div, 'click', \n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        function (event) {\n            cMouseDownInCluster = false;\n            if (!cDraggingMapByCluster) {\n                var markerClusterer_1 = _this.cluster.getClusterer();\n                /**\n                 * This event is fired when a cluster marker is clicked.\n                 * @name MarkerClusterer#click\n                 * @param {Cluster} c The cluster that was clicked.\n                 * @event\n                 */\n                google.maps.event.trigger(markerClusterer_1, 'click', _this.cluster);\n                google.maps.event.trigger(markerClusterer_1, 'clusterclick', _this.cluster); // deprecated name\n                // The default click handler follows. Disable it by setting\n                // the zoomOnClick property to false.\n                if (markerClusterer_1.getZoomOnClick()) {\n                    // Zoom into the cluster.\n                    var maxZoom_1 = markerClusterer_1.getMaxZoom();\n                    var bounds_1 = _this.cluster.getBounds();\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    markerClusterer_1.getMap().fitBounds(bounds_1);\n                    // There is a fix for Issue 170 here:\n                    setTimeout(function timeout() {\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                        // @ts-ignore\n                        markerClusterer_1.getMap().fitBounds(bounds_1);\n                        // Don't zoom beyond the max zoom level\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                        // @ts-ignore\n                        if (maxZoom_1 !== null && markerClusterer_1.getMap().getZoom() > maxZoom_1) {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                            // @ts-ignore\n                            markerClusterer_1.getMap().setZoom(maxZoom_1 + 1);\n                        }\n                    }, 100);\n                }\n                // Prevent event propagation to the map:\n                event.cancelBubble = true;\n                if (event.stopPropagation) {\n                    event.stopPropagation();\n                }\n            }\n        });\n        google.maps.event.addDomListener(this.div, 'mouseover', \n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        function () {\n            /**\n             * This event is fired when the mouse moves over a cluster marker.\n             * @name MarkerClusterer#mouseover\n             * @param {Cluster} c The cluster that the mouse moved over.\n             * @event\n             */\n            google.maps.event.trigger(_this.cluster.getClusterer(), 'mouseover', _this.cluster);\n        });\n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        google.maps.event.addDomListener(this.div, 'mouseout', \n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        function () {\n            /**\n             * This event is fired when the mouse moves out of a cluster marker.\n             * @name MarkerClusterer#mouseout\n             * @param {Cluster} c The cluster that the mouse moved out of.\n             * @event\n             */\n            google.maps.event.trigger(_this.cluster.getClusterer(), 'mouseout', _this.cluster);\n        });\n    };\n    ClusterIcon.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.hide();\n            if (this.boundsChangedListener !== null) {\n                google.maps.event.removeListener(this.boundsChangedListener);\n            }\n            google.maps.event.clearInstanceListeners(this.div);\n            this.div.parentNode.removeChild(this.div);\n            this.div = null;\n        }\n    };\n    ClusterIcon.prototype.draw = function () {\n        if (this.visible && this.div !== null && this.center) {\n            var _a = this.getPosFromLatLng(this.center), x = _a.x, y = _a.y;\n            this.div.style.top = y + 'px';\n            this.div.style.left = x + 'px';\n        }\n    };\n    ClusterIcon.prototype.hide = function () {\n        if (this.div) {\n            this.div.style.display = 'none';\n        }\n        this.visible = false;\n    };\n    ClusterIcon.prototype.show = function () {\n        if (this.div && this.center) {\n            var img = '', divTitle = '';\n            // NOTE: values must be specified in px units\n            var bp = this.backgroundPosition.split(' ');\n            var spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, ''), 10);\n            var spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, ''), 10);\n            var pos = this.getPosFromLatLng(this.center);\n            if (this.sums === null || typeof this.sums.title === 'undefined' || this.sums.title === '') {\n                divTitle = this.cluster.getClusterer().getTitle();\n            }\n            else {\n                divTitle = this.sums.title;\n            }\n            this.div.style.cssText = this.createCss(pos);\n            img =\n                \"<img alt='\" +\n                    divTitle +\n                    \"' src='\" +\n                    this.url +\n                    \"' style='position: absolute; top: \" +\n                    spriteV +\n                    'px; left: ' +\n                    spriteH +\n                    'px; ';\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            //@ts-ignore\n            if (!this.cluster.getClusterer().enableRetinaIcons) {\n                img +=\n                    'clip: rect(' +\n                        -1 * spriteV +\n                        'px, ' +\n                        (-1 * spriteH + this.width) +\n                        'px, ' +\n                        (-1 * spriteV + this.height) +\n                        'px, ' +\n                        -1 * spriteH +\n                        'px);';\n            }\n            img += \"'>\";\n            this.div.innerHTML =\n                img +\n                    \"<div style='\" +\n                    'position: absolute;' +\n                    'top: ' +\n                    this.anchorText[0] +\n                    'px;' +\n                    'left: ' +\n                    this.anchorText[1] +\n                    'px;' +\n                    'color: ' +\n                    this.textColor +\n                    ';' +\n                    'font-size: ' +\n                    this.textSize +\n                    'px;' +\n                    'font-family: ' +\n                    this.fontFamily +\n                    ';' +\n                    'font-weight: ' +\n                    this.fontWeight +\n                    ';' +\n                    'font-style: ' +\n                    this.fontStyle +\n                    ';' +\n                    'text-decoration: ' +\n                    this.textDecoration +\n                    ';' +\n                    'text-align: center;' +\n                    'width: ' +\n                    this.width +\n                    'px;' +\n                    'line-height:' +\n                    this.height +\n                    'px;' +\n                    \"'>\" +\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.sums.text +\n                    '</div>';\n            this.div.title = divTitle;\n            this.div.style.display = '';\n        }\n        this.visible = true;\n    };\n    ClusterIcon.prototype.useStyle = function (sums) {\n        this.sums = sums;\n        var styles = this.cluster.getClusterer().getStyles();\n        var style = styles[Math.min(styles.length - 1, Math.max(0, sums.index - 1))];\n        this.url = style.url;\n        this.height = style.height;\n        this.width = style.width;\n        if (style.className)\n            this.className = this.clusterClassName + \" \" + style.className;\n        this.anchorText = style.anchorText || [0, 0];\n        this.anchorIcon = style.anchorIcon || [this.height / 2, this.width / 2];\n        this.textColor = style.textColor || 'black';\n        this.textSize = style.textSize || 11;\n        this.textDecoration = style.textDecoration || 'none';\n        this.fontWeight = style.fontWeight || 'bold';\n        this.fontStyle = style.fontStyle || 'normal';\n        this.fontFamily = style.fontFamily || 'Arial,sans-serif';\n        this.backgroundPosition = style.backgroundPosition || '0 0';\n    };\n    ClusterIcon.prototype.setCenter = function (center) {\n        this.center = center;\n    };\n    ClusterIcon.prototype.createCss = function (pos) {\n        var style = [];\n        style.push('cursor: pointer;');\n        style.push('position: absolute; top: ' + pos.y + 'px; left: ' + pos.x + 'px;');\n        style.push('width: ' + this.width + 'px; height: ' + this.height + 'px;');\n        return style.join('');\n    };\n    ClusterIcon.prototype.getPosFromLatLng = function (latlng) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n        pos.x -= this.anchorIcon[1];\n        pos.y -= this.anchorIcon[0];\n        // pos.x = pos.x\n        // pos.y = pos.y\n        return pos;\n    };\n    return ClusterIcon;\n}());\n\nvar Cluster$1 = /** @class */ (function () {\n    function Cluster(markerClusterer) {\n        this.markerClusterer = markerClusterer;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.map = this.markerClusterer.getMap();\n        this.gridSize = this.markerClusterer.getGridSize();\n        this.minClusterSize = this.markerClusterer.getMinimumClusterSize();\n        this.averageCenter = this.markerClusterer.getAverageCenter();\n        this.markers = [];\n        this.center = undefined;\n        this.bounds = null;\n        this.clusterIcon = new ClusterIcon(this, this.markerClusterer.getStyles());\n    }\n    Cluster.prototype.getSize = function () {\n        return this.markers.length;\n    };\n    Cluster.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Cluster.prototype.getCenter = function () {\n        return this.center;\n    };\n    Cluster.prototype.getMap = function () {\n        return this.map;\n    };\n    Cluster.prototype.getClusterer = function () {\n        return this.markerClusterer;\n    };\n    Cluster.prototype.getBounds = function () {\n        var bounds = new google.maps.LatLngBounds(this.center, this.center);\n        var markers = this.getMarkers();\n        for (var i = 0; i < markers.length; i++) {\n            var position = markers[i].getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        return bounds;\n    };\n    Cluster.prototype.remove = function () {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.clusterIcon.setMap(null);\n        this.markers = [];\n        // @ts-ignore\n        delete this.markers;\n    };\n    Cluster.prototype.addMarker = function (marker) {\n        if (this.isMarkerAlreadyAdded(marker)) {\n            return false;\n        }\n        if (!this.center) {\n            var position = marker.getPosition();\n            if (position) {\n                this.center = position;\n                this.calculateBounds();\n            }\n        }\n        else {\n            if (this.averageCenter) {\n                var position = marker.getPosition();\n                if (position) {\n                    var length_1 = this.markers.length + 1;\n                    this.center = new google.maps.LatLng((this.center.lat() * (length_1 - 1) + position.lat()) / length_1, (this.center.lng() * (length_1 - 1) + position.lng()) / length_1);\n                    this.calculateBounds();\n                }\n            }\n        }\n        marker.isAdded = true;\n        this.markers.push(marker);\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = this.map.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            // Zoomed in past max zoom, so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount < this.minClusterSize) {\n            // Min cluster size not reached so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount === this.minClusterSize) {\n            // Hide the markers that were showing.\n            for (var i = 0; i < mCount; i++) {\n                this.markers[i].setMap(null);\n            }\n        }\n        else {\n            marker.setMap(null);\n        }\n        return true;\n    };\n    Cluster.prototype.isMarkerInClusterBounds = function (marker) {\n        if (this.bounds !== null) {\n            var position = marker.getPosition();\n            if (position) {\n                return this.bounds.contains(position);\n            }\n        }\n        return false;\n    };\n    Cluster.prototype.calculateBounds = function () {\n        this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));\n    };\n    Cluster.prototype.updateIcon = function () {\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = this.map.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            this.clusterIcon.hide();\n            return;\n        }\n        if (mCount < this.minClusterSize) {\n            // Min cluster size not yet reached.\n            this.clusterIcon.hide();\n            return;\n        }\n        if (this.center) {\n            this.clusterIcon.setCenter(this.center);\n        }\n        this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length));\n        this.clusterIcon.show();\n    };\n    Cluster.prototype.isMarkerAlreadyAdded = function (marker) {\n        if (this.markers.includes) {\n            return this.markers.includes(marker);\n        }\n        else {\n            for (var i = 0; i < this.markers.length; i++) {\n                if (marker === this.markers[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    return Cluster;\n}());\n\n/* global google */\n/**\n * Supports up to 9007199254740991 (Number.MAX_SAFE_INTEGER) markers\n * which is not a problem as max array length is 4294967296 (2**32)\n */\nvar CALCULATOR = function CALCULATOR(markers, numStyles) {\n    var count = markers.length;\n    var numberOfDigits = count.toString().length;\n    var index = Math.min(numberOfDigits, numStyles);\n    return {\n        text: count.toString(),\n        index: index,\n        title: '',\n    };\n};\nvar BATCH_SIZE = 2000;\nvar BATCH_SIZE_IE = 500;\nvar IMAGE_PATH = 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m';\nvar IMAGE_EXTENSION = 'png';\nvar IMAGE_SIZES = [53, 56, 66, 78, 90];\nvar CLUSTERER_CLASS = 'cluster';\nvar Clusterer = /** @class */ (function () {\n    function Clusterer(map, optMarkers, optOptions) {\n        if (optMarkers === void 0) { optMarkers = []; }\n        if (optOptions === void 0) { optOptions = {}; }\n        this.extend(Clusterer, google.maps.OverlayView);\n        this.markers = [];\n        this.clusters = [];\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n        this.gridSize = optOptions.gridSize || 60;\n        this.minClusterSize = optOptions.minimumClusterSize || 2;\n        this.maxZoom = optOptions.maxZoom || null;\n        this.styles = optOptions.styles || [];\n        this.title = optOptions.title || '';\n        this.zoomOnClick = true;\n        if (optOptions.zoomOnClick !== undefined) {\n            this.zoomOnClick = optOptions.zoomOnClick;\n        }\n        this.averageCenter = false;\n        if (optOptions.averageCenter !== undefined) {\n            this.averageCenter = optOptions.averageCenter;\n        }\n        this.ignoreHidden = false;\n        if (optOptions.ignoreHidden !== undefined) {\n            this.ignoreHidden = optOptions.ignoreHidden;\n        }\n        this.enableRetinaIcons = false;\n        if (optOptions.enableRetinaIcons !== undefined) {\n            this.enableRetinaIcons = optOptions.enableRetinaIcons;\n        }\n        this.imagePath = optOptions.imagePath || IMAGE_PATH;\n        this.imageExtension = optOptions.imageExtension || IMAGE_EXTENSION;\n        this.imageSizes = optOptions.imageSizes || IMAGE_SIZES;\n        this.calculator = optOptions.calculator || CALCULATOR;\n        this.batchSize = optOptions.batchSize || BATCH_SIZE;\n        this.batchSizeIE = optOptions.batchSizeIE || BATCH_SIZE_IE;\n        this.clusterClass = optOptions.clusterClass || CLUSTERER_CLASS;\n        if (navigator.userAgent.toLowerCase().indexOf('msie') !== -1) {\n            // Try to avoid IE timeout when processing a huge number of markers:\n            this.batchSize = this.batchSizeIE;\n        }\n        this.timerRefStatic = null;\n        this.setupStyles();\n        this.addMarkers(optMarkers, true);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.setMap(map); // Note: this causes onAdd to be called\n    }\n    Clusterer.prototype.onAdd = function () {\n        var _this = this;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.activeMap = this.getMap();\n        this.ready = true;\n        this.repaint();\n        // Add the map event listeners\n        this.listeners = [\n            google.maps.event.addListener(\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.getMap(), 'zoom_changed', \n            // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n            function () {\n                _this.resetViewport(false);\n                // Workaround for this Google bug: when map is at level 0 and \"-\" of\n                // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n                // the map doesn't zoom out any further. In this situation, no \"idle\"\n                // event is triggered so the cluster markers that have been removed\n                // do not get redrawn. Same goes for a zoom in at maxZoom.\n                if (\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                _this.getMap().getZoom() === (_this.get('minZoom') || 0) ||\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    _this.getMap().getZoom() === _this.get('maxZoom')) {\n                    google.maps.event.trigger(_this, 'idle');\n                }\n            }),\n            google.maps.event.addListener(\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.getMap(), 'idle', \n            // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n            function () {\n                _this.redraw();\n            }),\n        ];\n    };\n    // eslint-disable-next-line @getify/proper-arrows/this\n    Clusterer.prototype.onRemove = function () {\n        // Put all the managed markers back on the map:\n        for (var i = 0; i < this.markers.length; i++) {\n            if (this.markers[i].getMap() !== this.activeMap) {\n                this.markers[i].setMap(this.activeMap);\n            }\n        }\n        // Remove all clusters:\n        for (var i = 0; i < this.clusters.length; i++) {\n            this.clusters[i].remove();\n        }\n        this.clusters = [];\n        // Remove map event listeners:\n        for (var i = 0; i < this.listeners.length; i++) {\n            google.maps.event.removeListener(this.listeners[i]);\n        }\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    Clusterer.prototype.draw = function () { };\n    Clusterer.prototype.setupStyles = function () {\n        if (this.styles.length > 0) {\n            return;\n        }\n        for (var i = 0; i < this.imageSizes.length; i++) {\n            this.styles.push({\n                url: this.imagePath + (i + 1) + '.' + this.imageExtension,\n                height: this.imageSizes[i],\n                width: this.imageSizes[i],\n            });\n        }\n    };\n    Clusterer.prototype.fitMapToMarkers = function () {\n        var markers = this.getMarkers();\n        var bounds = new google.maps.LatLngBounds();\n        for (var i = 0; i < markers.length; i++) {\n            var position = markers[i].getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.getMap().fitBounds(bounds);\n    };\n    Clusterer.prototype.getGridSize = function () {\n        return this.gridSize;\n    };\n    Clusterer.prototype.setGridSize = function (gridSize) {\n        this.gridSize = gridSize;\n    };\n    Clusterer.prototype.getMinimumClusterSize = function () {\n        return this.minClusterSize;\n    };\n    Clusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n        this.minClusterSize = minimumClusterSize;\n    };\n    Clusterer.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    Clusterer.prototype.setMaxZoom = function (maxZoom) {\n        this.maxZoom = maxZoom;\n    };\n    Clusterer.prototype.getStyles = function () {\n        return this.styles;\n    };\n    Clusterer.prototype.setStyles = function (styles) {\n        this.styles = styles;\n    };\n    Clusterer.prototype.getTitle = function () {\n        return this.title;\n    };\n    Clusterer.prototype.setTitle = function (title) {\n        this.title = title;\n    };\n    Clusterer.prototype.getZoomOnClick = function () {\n        return this.zoomOnClick;\n    };\n    Clusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n        this.zoomOnClick = zoomOnClick;\n    };\n    Clusterer.prototype.getAverageCenter = function () {\n        return this.averageCenter;\n    };\n    Clusterer.prototype.setAverageCenter = function (averageCenter) {\n        this.averageCenter = averageCenter;\n    };\n    Clusterer.prototype.getIgnoreHidden = function () {\n        return this.ignoreHidden;\n    };\n    Clusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n        this.ignoreHidden = ignoreHidden;\n    };\n    Clusterer.prototype.getEnableRetinaIcons = function () {\n        return this.enableRetinaIcons;\n    };\n    Clusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n        this.enableRetinaIcons = enableRetinaIcons;\n    };\n    Clusterer.prototype.getImageExtension = function () {\n        return this.imageExtension;\n    };\n    Clusterer.prototype.setImageExtension = function (imageExtension) {\n        this.imageExtension = imageExtension;\n    };\n    Clusterer.prototype.getImagePath = function () {\n        return this.imagePath;\n    };\n    Clusterer.prototype.setImagePath = function (imagePath) {\n        this.imagePath = imagePath;\n    };\n    Clusterer.prototype.getImageSizes = function () {\n        return this.imageSizes;\n    };\n    Clusterer.prototype.setImageSizes = function (imageSizes) {\n        this.imageSizes = imageSizes;\n    };\n    Clusterer.prototype.getCalculator = function () {\n        return this.calculator;\n    };\n    Clusterer.prototype.setCalculator = function (calculator) {\n        this.calculator = calculator;\n    };\n    Clusterer.prototype.getBatchSizeIE = function () {\n        return this.batchSizeIE;\n    };\n    Clusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n        this.batchSizeIE = batchSizeIE;\n    };\n    Clusterer.prototype.getClusterClass = function () {\n        return this.clusterClass;\n    };\n    Clusterer.prototype.setClusterClass = function (clusterClass) {\n        this.clusterClass = clusterClass;\n    };\n    Clusterer.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Clusterer.prototype.getTotalMarkers = function () {\n        return this.markers.length;\n    };\n    Clusterer.prototype.getClusters = function () {\n        return this.clusters;\n    };\n    Clusterer.prototype.getTotalClusters = function () {\n        return this.clusters.length;\n    };\n    Clusterer.prototype.addMarker = function (marker, optNoDraw) {\n        this.pushMarkerTo(marker);\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.addMarkers = function (markers, optNoDraw) {\n        for (var key in markers) {\n            if (markers.hasOwnProperty(key)) {\n                this.pushMarkerTo(markers[key]);\n            }\n        }\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.pushMarkerTo = function (marker) {\n        var _this = this;\n        // If the marker is draggable add a listener so we can update the clusters on the dragend:\n        if (marker.getDraggable()) {\n            // eslint-disable-next-line @getify/proper-arrows/name, @getify/proper-arrows/this\n            google.maps.event.addListener(marker, 'dragend', function () {\n                if (_this.ready) {\n                    marker.isAdded = false;\n                    _this.repaint();\n                }\n            });\n        }\n        marker.isAdded = false;\n        this.markers.push(marker);\n    };\n    Clusterer.prototype.removeMarker_ = function (marker) {\n        var index = -1;\n        if (this.markers.indexOf) {\n            index = this.markers.indexOf(marker);\n        }\n        else {\n            for (var i = 0; i < this.markers.length; i++) {\n                if (marker === this.markers[i]) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index === -1) {\n            // Marker is not in our list of markers, so do nothing:\n            return false;\n        }\n        marker.setMap(null);\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n        return true;\n    };\n    Clusterer.prototype.removeMarker = function (marker, optNoDraw) {\n        var removed = this.removeMarker_(marker);\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.removeMarkers = function (markers, optNoDraw) {\n        var removed = false;\n        for (var i = 0; i < markers.length; i++) {\n            removed = removed || this.removeMarker_(markers[i]);\n        }\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.clearMarkers = function () {\n        this.resetViewport(true);\n        this.markers = [];\n    };\n    Clusterer.prototype.repaint = function () {\n        var oldClusters = this.clusters.slice();\n        this.clusters = [];\n        this.resetViewport(false);\n        this.redraw();\n        // Remove the old clusters.\n        // Do it in a timeout to prevent blinking effect.\n        setTimeout(function timeout() {\n            for (var i = 0; i < oldClusters.length; i++) {\n                oldClusters[i].remove();\n            }\n        }, 0);\n    };\n    Clusterer.prototype.getExtendedBounds = function (bounds) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        var projection = this.getProjection();\n        // Convert the points to pixels and the extend out by the grid size.\n        var trPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()));\n        trPix.x += this.gridSize;\n        trPix.y -= this.gridSize;\n        var blPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()));\n        blPix.x -= this.gridSize;\n        blPix.y += this.gridSize;\n        // Extend the bounds to contain the new bounds.\n        bounds.extend(\n        // Convert the pixel points back to LatLng nw\n        projection.fromDivPixelToLatLng(trPix));\n        bounds.extend(\n        // Convert the pixel points back to LatLng sw\n        projection.fromDivPixelToLatLng(blPix));\n        return bounds;\n    };\n    Clusterer.prototype.redraw = function () {\n        // Redraws all the clusters.\n        this.createClusters(0);\n    };\n    Clusterer.prototype.resetViewport = function (optHide) {\n        // Remove all the clusters\n        for (var i = 0; i < this.clusters.length; i++) {\n            this.clusters[i].remove();\n        }\n        this.clusters = [];\n        // Reset the markers to not be added and to be removed from the map.\n        for (var i = 0; i < this.markers.length; i++) {\n            var marker = this.markers[i];\n            marker.isAdded = false;\n            if (optHide) {\n                marker.setMap(null);\n            }\n        }\n    };\n    Clusterer.prototype.distanceBetweenPoints = function (p1, p2) {\n        var R = 6371; // Radius of the Earth in km\n        var dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n        var dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos((p1.lat() * Math.PI) / 180) *\n                Math.cos((p2.lat() * Math.PI) / 180) *\n                Math.sin(dLon / 2) *\n                Math.sin(dLon / 2);\n        return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));\n    };\n    Clusterer.prototype.isMarkerInBounds = function (marker, bounds) {\n        var position = marker.getPosition();\n        if (position) {\n            return bounds.contains(position);\n        }\n        return false;\n    };\n    Clusterer.prototype.addToClosestCluster = function (marker) {\n        var cluster;\n        var distance = 40000; // Some large number\n        var clusterToAddTo = null;\n        for (var i = 0; i < this.clusters.length; i++) {\n            cluster = this.clusters[i];\n            var center = cluster.getCenter();\n            var position = marker.getPosition();\n            if (center && position) {\n                var d = this.distanceBetweenPoints(center, position);\n                if (d < distance) {\n                    distance = d;\n                    clusterToAddTo = cluster;\n                }\n            }\n        }\n        if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n            clusterToAddTo.addMarker(marker);\n        }\n        else {\n            cluster = new Cluster$1(this);\n            cluster.addMarker(marker);\n            this.clusters.push(cluster);\n        }\n    };\n    Clusterer.prototype.createClusters = function (iFirst) {\n        var _this = this;\n        if (!this.ready) {\n            return;\n        }\n        // Cancel previous batch processing if we're working on the first batch:\n        if (iFirst === 0) {\n            /**\n             * This event is fired when the <code>Clusterer</code> begins\n             *  clustering markers.\n             * @name Clusterer#clusteringbegin\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringbegin', this);\n            if (this.timerRefStatic !== null) {\n                window.clearTimeout(this.timerRefStatic);\n                // @ts-ignore\n                delete this.timerRefStatic;\n            }\n        }\n        // Get our current map view bounds.\n        // Create a new bounds object so we don't affect the map.\n        //\n        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n        var mapBounds = \n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.getMap().getZoom() > 3\n            ? new google.maps.LatLngBounds(\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.getMap()\n                .getBounds()\n                .getSouthWest(), \n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.getMap()\n                .getBounds()\n                .getNorthEast())\n            : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n        var bounds = this.getExtendedBounds(mapBounds);\n        var iLast = Math.min(iFirst + this.batchSize, this.markers.length);\n        for (var i = iFirst; i < iLast; i++) {\n            var marker = this.markers[i];\n            if (!marker.isAdded && this.isMarkerInBounds(marker, bounds)) {\n                if (!this.ignoreHidden || (this.ignoreHidden && marker.getVisible())) {\n                    this.addToClosestCluster(marker);\n                }\n            }\n        }\n        if (iLast < this.markers.length) {\n            this.timerRefStatic = window.setTimeout(\n            // eslint-disable-next-line @getify/proper-arrows/this, @getify/proper-arrows/name\n            function () {\n                _this.createClusters(iLast);\n            }, 0);\n        }\n        else {\n            this.timerRefStatic = null;\n            /**\n             * This event is fired when the <code>Clusterer</code> stops\n             *  clustering markers.\n             * @name Clusterer#clusteringend\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringend', this);\n            for (var i = 0; i < this.clusters.length; i++) {\n                this.clusters[i].updateIcon();\n            }\n        }\n    };\n    Clusterer.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            // eslint-disable-next-line guard-for-in\n            for (var property in object.prototype) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.prototype[property] = object.prototype[property];\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return Clusterer;\n}());\n\n/* eslint-disable filenames/match-exported */\nconst eventMap$e = {\n    onClick: 'click',\n    onClusteringBegin: 'clusteringbegin',\n    onClusteringEnd: 'clusteringend',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n};\nconst updaterMap$e = {\n    averageCenter(instance, averageCenter) {\n        instance.setAverageCenter(averageCenter);\n    },\n    batchSizeIE(instance, batchSizeIE) {\n        instance.setBatchSizeIE(batchSizeIE);\n    },\n    calculator(instance, calculator) {\n        instance.setCalculator(calculator);\n    },\n    clusterClass(instance, clusterClass) {\n        instance.setClusterClass(clusterClass);\n    },\n    enableRetinaIcons(instance, enableRetinaIcons) {\n        instance.setEnableRetinaIcons(enableRetinaIcons);\n    },\n    gridSize(instance, gridSize) {\n        instance.setGridSize(gridSize);\n    },\n    ignoreHidden(instance, ignoreHidden) {\n        instance.setIgnoreHidden(ignoreHidden);\n    },\n    imageExtension(instance, imageExtension) {\n        instance.setImageExtension(imageExtension);\n    },\n    imagePath(instance, imagePath) {\n        instance.setImagePath(imagePath);\n    },\n    imageSizes(instance, imageSizes) {\n        instance.setImageSizes(imageSizes);\n    },\n    maxZoom(instance, maxZoom) {\n        instance.setMaxZoom(maxZoom);\n    },\n    minimumClusterSize(instance, minimumClusterSize) {\n        instance.setMinimumClusterSize(minimumClusterSize);\n    },\n    styles(instance, styles) {\n        instance.setStyles(styles);\n    },\n    title(instance, title) {\n        instance.setTitle(title);\n    },\n    zoomOnClick(instance, zoomOnClick) {\n        instance.setZoomOnClick(zoomOnClick);\n    },\n};\nclass ClustererComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            markerClusterer: null,\n        };\n        this.setClustererCallback = () => {\n            if (this.state.markerClusterer !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.markerClusterer);\n            }\n        };\n    }\n    componentDidMount() {\n        if (this.context) {\n            const markerClusterer = new Clusterer(this.context, [], this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps: {},\n                nextProps: this.props,\n                instance: markerClusterer,\n            });\n            this.setState(function setClusterer() {\n                return {\n                    markerClusterer,\n                };\n            }, this.setClustererCallback);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.markerClusterer) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.markerClusterer,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.markerClusterer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.markerClusterer);\n            }\n            unregisterEvents(this.registeredEvents);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.state.markerClusterer.setMap(null);\n        }\n    }\n    render() {\n        return this.state.markerClusterer !== null\n            ? this.props.children(this.state.markerClusterer)\n            : null;\n    }\n}\nClustererComponent.contextType = MapContext;\n\nvar InfoBox = /** @class */ (function () {\n    function InfoBox(options) {\n        if (options === void 0) { options = {}; }\n        this.extend(InfoBox, google.maps.OverlayView);\n        // Standard options (in common with google.maps.InfoWindow):\n        this.content = options.content || '';\n        this.disableAutoPan = options.disableAutoPan || false;\n        this.maxWidth = options.maxWidth || 0;\n        this.pixelOffset = options.pixelOffset || new google.maps.Size(0, 0);\n        this.position = options.position || new google.maps.LatLng(0, 0);\n        this.zIndex = options.zIndex || null;\n        // Additional options (unique to InfoBox):\n        this.boxClass = options.boxClass || 'infoBox';\n        this.boxStyle = options.boxStyle || {};\n        this.closeBoxMargin = options.closeBoxMargin || '2px';\n        this.closeBoxURL = options.closeBoxURL || 'http://www.google.com/intl/en_us/mapfiles/close.gif';\n        if (options.closeBoxURL === '') {\n            this.closeBoxURL = '';\n        }\n        this.infoBoxClearance = options.infoBoxClearance || new google.maps.Size(1, 1);\n        if (typeof options.visible === 'undefined') {\n            if (typeof options.isHidden === 'undefined') {\n                options.visible = true;\n            }\n            else {\n                options.visible = !options.isHidden;\n            }\n        }\n        this.isHidden = !options.visible;\n        this.alignBottom = options.alignBottom || false;\n        this.pane = options.pane || 'floatPane';\n        this.enableEventPropagation = options.enableEventPropagation || false;\n        this.div = null;\n        this.closeListener = null;\n        this.moveListener = null;\n        this.mapListener = null;\n        this.contextListener = null;\n        this.eventListeners = null;\n        this.fixedWidthSet = null;\n    }\n    InfoBox.prototype.createInfoBoxDiv = function () {\n        var _this = this;\n        // This handler prevents an event in the InfoBox from being passed on to the map.\n        function cancelHandler(event) {\n            event.cancelBubble = true;\n            if (event.stopPropagation) {\n                event.stopPropagation();\n            }\n        }\n        // This handler ignores the current event in the InfoBox and conditionally prevents\n        // the event from being passed on to the map. It is used for the contextmenu event.\n        // eslint-disable-next-line  @getify/proper-arrows/this\n        var ignoreHandler = function (event) {\n            event.returnValue = false;\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            if (!_this.enableEventPropagation) {\n                cancelHandler(event);\n            }\n        };\n        if (!this.div) {\n            this.div = document.createElement('div');\n            this.setBoxStyle();\n            if (typeof this.content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + this.content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(this.content);\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            var panes = this.getPanes();\n            panes[this.pane].appendChild(this.div); // Add the InfoBox div to the DOM\n            this.addClickHandler();\n            if (this.div.style.width) {\n                this.fixedWidthSet = true;\n            }\n            else {\n                if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth) {\n                    this.div.style.width = this.maxWidth + 'px';\n                    this.fixedWidthSet = true;\n                }\n                else {\n                    // The following code is needed to overcome problems with MSIE\n                    var bw = this.getBoxWidths();\n                    this.div.style.width = this.div.offsetWidth - bw.left - bw.right + 'px';\n                    this.fixedWidthSet = false;\n                }\n            }\n            this.panBox(this.disableAutoPan);\n            if (!this.enableEventPropagation) {\n                this.eventListeners = [];\n                // Cancel event propagation.\n                // Note: mousemove not included (to resolve Issue 152)\n                var events = [\n                    'mousedown',\n                    'mouseover',\n                    'mouseout',\n                    'mouseup',\n                    'click',\n                    'dblclick',\n                    'touchstart',\n                    'touchend',\n                    'touchmove',\n                ];\n                for (var i = 0; i < events.length; i++) {\n                    this.eventListeners.push(google.maps.event.addDomListener(this.div, events[i], cancelHandler));\n                }\n                // Workaround for Google bug that causes the cursor to change to a pointer\n                // when the mouse moves over a marker underneath InfoBox.\n                this.eventListeners.push(google.maps.event.addDomListener(this.div, 'mouseover', \n                // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n                function () {\n                    if (_this.div) {\n                        _this.div.style.cursor = 'default';\n                    }\n                }));\n            }\n            this.contextListener = google.maps.event.addDomListener(this.div, 'contextmenu', ignoreHandler);\n            /**\n             * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.\n             * @name InfoBox#domready\n             * @event\n             */\n            google.maps.event.trigger(this, 'domready');\n        }\n    };\n    InfoBox.prototype.getCloseBoxImg = function () {\n        var img = '';\n        if (this.closeBoxURL !== '') {\n            img = '<img alt=\"\"';\n            img += ' aria-hidden=\"true\"';\n            img += \" src='\" + this.closeBoxURL + \"'\";\n            img += ' align=right'; // Do this because Opera chokes on style='float: right;'\n            img += \" style='\";\n            img += ' position: relative;'; // Required by MSIE\n            img += ' cursor: pointer;';\n            img += ' margin: ' + this.closeBoxMargin + ';';\n            img += \"'>\";\n        }\n        return img;\n    };\n    InfoBox.prototype.addClickHandler = function () {\n        if (this.div && this.div.firstChild && this.closeBoxURL !== '') {\n            var closeBox = this.div.firstChild;\n            this.closeListener = google.maps.event.addDomListener(closeBox, 'click', this.getCloseClickHandler());\n        }\n        else {\n            this.closeListener = null;\n        }\n    };\n    InfoBox.prototype.getCloseClickHandler = function () {\n        var _this = this;\n        // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n        return function (event) {\n            // 1.0.3 fix: Always prevent propagation of a close box click to the map:\n            event.cancelBubble = true;\n            if (event.stopPropagation) {\n                event.stopPropagation();\n            }\n            /**\n             * This event is fired when the InfoBox's close box is clicked.\n             * @name InfoBox#closeclick\n             * @event\n             */\n            google.maps.event.trigger(_this, 'closeclick');\n            _this.close();\n        };\n    };\n    InfoBox.prototype.panBox = function (disablePan) {\n        if (this.div && !disablePan) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            var map = this.getMap();\n            // Only pan if attached to map, not panorama\n            if (map instanceof google.maps.Map) {\n                var xOffset = 0;\n                var yOffset = 0;\n                var bounds = map.getBounds();\n                if (bounds && !bounds.contains(this.position)) {\n                    // Marker not in visible area of map, so set center\n                    // of map to the marker position first.\n                    map.setCenter(this.position);\n                }\n                var mapDiv = map.getDiv();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                var mapWidth = mapDiv.offsetWidth;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                var mapHeight = mapDiv.offsetHeight;\n                var iwOffsetX = this.pixelOffset.width;\n                var iwOffsetY = this.pixelOffset.height;\n                var iwWidth = this.div.offsetWidth;\n                var iwHeight = this.div.offsetHeight;\n                var padX = this.infoBoxClearance.width;\n                var padY = this.infoBoxClearance.height;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                var projection = this.getProjection();\n                var pixPosition = projection.fromLatLngToContainerPixel(this.position);\n                if (pixPosition !== null) {\n                    if (pixPosition.x < -iwOffsetX + padX) {\n                        xOffset = pixPosition.x + iwOffsetX - padX;\n                    }\n                    else if (pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth) {\n                        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;\n                    }\n                    if (this.alignBottom) {\n                        if (pixPosition.y < -iwOffsetY + padY + iwHeight) {\n                            yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;\n                        }\n                        else if (pixPosition.y + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                    else {\n                        if (pixPosition.y < -iwOffsetY + padY) {\n                            yOffset = pixPosition.y + iwOffsetY - padY;\n                        }\n                        else if (pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                }\n                if (!(xOffset === 0 && yOffset === 0)) {\n                    // Move the map to the shifted center.\n                    map.panBy(xOffset, yOffset);\n                }\n            }\n        }\n    };\n    InfoBox.prototype.setBoxStyle = function () {\n        if (this.div) {\n            // Apply style values from the style sheet defined in the boxClass parameter:\n            this.div.className = this.boxClass;\n            // Clear existing inline style values:\n            this.div.style.cssText = '';\n            // Apply style values defined in the boxStyle parameter:\n            var boxStyle = this.boxStyle;\n            for (var i in boxStyle) {\n                if (boxStyle.hasOwnProperty(i)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.div.style[i] = boxStyle[i];\n                }\n            }\n            // Fix for iOS disappearing InfoBox problem\n            // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad\n            this.div.style.webkitTransform = 'translateZ(0)';\n            // Fix up opacity style for benefit of MSIE\n            if (typeof this.div.style.opacity !== 'undefined' && this.div.style.opacity !== '') {\n                // See http://www.quirksmode.org/css/opacity.html\n                var opacity = parseFloat(this.div.style.opacity || '');\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                this.div.style.msFilter =\n                    '\"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + opacity * 100 + ')\"';\n                this.div.style.filter = 'alpha(opacity=' + opacity * 100 + ')';\n            }\n            // Apply required styles\n            this.div.style.position = 'absolute';\n            this.div.style.visibility = 'hidden';\n            if (this.zIndex !== null) {\n                this.div.style.zIndex = this.zIndex + '';\n            }\n            if (!this.div.style.overflow) {\n                this.div.style.overflow = 'auto';\n            }\n        }\n    };\n    InfoBox.prototype.getBoxWidths = function () {\n        var bw = { top: 0, bottom: 0, left: 0, right: 0 };\n        if (!this.div) {\n            return bw;\n        }\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n            var ownerDocument = this.div.ownerDocument;\n            var computedStyle = ownerDocument && ownerDocument.defaultView\n                ? ownerDocument.defaultView.getComputedStyle(this.div, '')\n                : null;\n            if (computedStyle) {\n                // The computed styles are always in pixel units (good!)\n                bw.top = parseInt(computedStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(computedStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(computedStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(computedStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        else if (\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        document.documentElement.currentStyle // MSIE\n        ) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            var currentStyle = this.div.currentStyle;\n            if (currentStyle) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // The current styles may not be in pixel units, but assume they are (bad!)\n                bw.top = parseInt(currentStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(currentStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(currentStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(currentStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        return bw;\n    };\n    InfoBox.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.div.parentNode.removeChild(this.div);\n            this.div = null;\n        }\n    };\n    InfoBox.prototype.draw = function () {\n        this.createInfoBoxDiv();\n        if (this.div) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            var projection = this.getProjection();\n            var pixPosition = projection.fromLatLngToDivPixel(this.position);\n            if (pixPosition !== null) {\n                this.div.style.left = pixPosition.x + this.pixelOffset.width + 'px';\n                if (this.alignBottom) {\n                    this.div.style.bottom = -(pixPosition.y + this.pixelOffset.height) + 'px';\n                }\n                else {\n                    this.div.style.top = pixPosition.y + this.pixelOffset.height + 'px';\n                }\n            }\n            if (this.isHidden) {\n                this.div.style.visibility = 'hidden';\n            }\n            else {\n                this.div.style.visibility = 'visible';\n            }\n        }\n    };\n    InfoBox.prototype.setOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        if (typeof options.boxClass !== 'undefined') {\n            // Must be first\n            this.boxClass = options.boxClass;\n            this.setBoxStyle();\n        }\n        if (typeof options.boxStyle !== 'undefined') {\n            // Must be second\n            this.boxStyle = options.boxStyle;\n            this.setBoxStyle();\n        }\n        if (typeof options.content !== 'undefined') {\n            this.setContent(options.content);\n        }\n        if (typeof options.disableAutoPan !== 'undefined') {\n            this.disableAutoPan = options.disableAutoPan;\n        }\n        if (typeof options.maxWidth !== 'undefined') {\n            this.maxWidth = options.maxWidth;\n        }\n        if (typeof options.pixelOffset !== 'undefined') {\n            this.pixelOffset = options.pixelOffset;\n        }\n        if (typeof options.alignBottom !== 'undefined') {\n            this.alignBottom = options.alignBottom;\n        }\n        if (typeof options.position !== 'undefined') {\n            this.setPosition(options.position);\n        }\n        if (typeof options.zIndex !== 'undefined') {\n            this.setZIndex(options.zIndex);\n        }\n        if (typeof options.closeBoxMargin !== 'undefined') {\n            this.closeBoxMargin = options.closeBoxMargin;\n        }\n        if (typeof options.closeBoxURL !== 'undefined') {\n            this.closeBoxURL = options.closeBoxURL;\n        }\n        if (typeof options.infoBoxClearance !== 'undefined') {\n            this.infoBoxClearance = options.infoBoxClearance;\n        }\n        if (typeof options.isHidden !== 'undefined') {\n            this.isHidden = options.isHidden;\n        }\n        if (typeof options.visible !== 'undefined') {\n            this.isHidden = !options.visible;\n        }\n        if (typeof options.enableEventPropagation !== 'undefined') {\n            this.enableEventPropagation = options.enableEventPropagation;\n        }\n        if (this.div) {\n            this.draw();\n        }\n    };\n    InfoBox.prototype.setContent = function (content) {\n        this.content = content;\n        if (this.div) {\n            if (this.closeListener) {\n                google.maps.event.removeListener(this.closeListener);\n                this.closeListener = null;\n            }\n            // Odd code required to make things work with MSIE.\n            if (!this.fixedWidthSet) {\n                this.div.style.width = '';\n            }\n            if (typeof content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(content);\n            }\n            // Perverse code required to make things work with MSIE.\n            // (Ensures the close box does, in fact, float to the right.)\n            if (!this.fixedWidthSet) {\n                this.div.style.width = this.div.offsetWidth + 'px';\n                if (typeof content === 'string') {\n                    this.div.innerHTML = this.getCloseBoxImg() + content;\n                }\n                else {\n                    this.div.innerHTML = this.getCloseBoxImg();\n                    this.div.appendChild(content);\n                }\n            }\n            this.addClickHandler();\n        }\n        /**\n         * This event is fired when the content of the InfoBox changes.\n         * @name InfoBox#content_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'content_changed');\n    };\n    InfoBox.prototype.setPosition = function (latLng) {\n        this.position = latLng;\n        if (this.div) {\n            this.draw();\n        }\n        /**\n         * This event is fired when the position of the InfoBox changes.\n         * @name InfoBox#position_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'position_changed');\n    };\n    InfoBox.prototype.setVisible = function (isVisible) {\n        this.isHidden = !isVisible;\n        if (this.div) {\n            this.div.style.visibility = this.isHidden ? 'hidden' : 'visible';\n        }\n    };\n    InfoBox.prototype.setZIndex = function (index) {\n        this.zIndex = index;\n        if (this.div) {\n            this.div.style.zIndex = index + '';\n        }\n        /**\n         * This event is fired when the zIndex of the InfoBox changes.\n         * @name InfoBox#zindex_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'zindex_changed');\n    };\n    InfoBox.prototype.getContent = function () {\n        return this.content;\n    };\n    InfoBox.prototype.getPosition = function () {\n        return this.position;\n    };\n    InfoBox.prototype.getZIndex = function () {\n        return this.zIndex;\n    };\n    InfoBox.prototype.getVisible = function () {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        var map = this.getMap();\n        var isVisible;\n        if (typeof map === 'undefined' || map === null) {\n            isVisible = false;\n        }\n        else {\n            isVisible = !this.isHidden;\n        }\n        return isVisible;\n    };\n    InfoBox.prototype.show = function () {\n        this.isHidden = false;\n        if (this.div) {\n            this.div.style.visibility = 'visible';\n        }\n    };\n    InfoBox.prototype.hide = function () {\n        this.isHidden = true;\n        if (this.div) {\n            this.div.style.visibility = 'hidden';\n        }\n    };\n    InfoBox.prototype.open = function (map, anchor) {\n        var _this = this;\n        if (anchor) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            this.position = anchor.getPosition();\n            this.moveListener = google.maps.event.addListener(anchor, 'position_changed', \n            // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n            function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                var position = anchor.getPosition();\n                _this.setPosition(position);\n            });\n            this.mapListener = google.maps.event.addListener(anchor, 'map_changed', \n            // eslint-disable-next-line  @getify/proper-arrows/this, @getify/proper-arrows/name\n            function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                _this.setMap(anchor.map);\n            });\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.setMap(map);\n        if (this.div) {\n            this.panBox();\n        }\n    };\n    InfoBox.prototype.close = function () {\n        if (this.closeListener) {\n            google.maps.event.removeListener(this.closeListener);\n            this.closeListener = null;\n        }\n        if (this.eventListeners) {\n            for (var i = 0; i < this.eventListeners.length; i++) {\n                google.maps.event.removeListener(this.eventListeners[i]);\n            }\n            this.eventListeners = null;\n        }\n        if (this.moveListener) {\n            google.maps.event.removeListener(this.moveListener);\n            this.moveListener = null;\n        }\n        if (this.mapListener) {\n            google.maps.event.removeListener(this.mapListener);\n            this.mapListener = null;\n        }\n        if (this.contextListener) {\n            google.maps.event.removeListener(this.contextListener);\n            this.contextListener = null;\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        this.setMap(null);\n    };\n    InfoBox.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            // eslint-disable-next-line guard-for-in\n            for (var property in object.prototype) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                // @ts-ignore\n                if (!this.prototype.hasOwnProperty(property)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    this.prototype[property] = object.prototype[property];\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n            // @ts-ignore\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return InfoBox;\n}());\n\nconst eventMap$d = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nconst updaterMap$d = {\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    position(instance, position) {\n        if (position instanceof google.maps.LatLng) {\n            instance.setPosition(position);\n        }\n        else {\n            instance.setPosition(new google.maps.LatLng(position.lat, position.lng));\n        }\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex(instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nclass InfoBoxComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.containerElement = null;\n        this.state = {\n            infoBox: null,\n        };\n        this.open = (infoBox, anchor) => {\n            if (anchor) {\n                infoBox.open(this.context, anchor);\n            }\n            else if (infoBox.getPosition()) {\n                infoBox.open(this.context);\n            }\n            else {\n                invariant_1(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n            }\n        };\n        this.setInfoBoxCallback = () => {\n            const { anchor, onLoad } = this.props;\n            const { infoBox } = this.state;\n            if (infoBox !== null && this.containerElement !== null) {\n                infoBox.setContent(this.containerElement);\n                this.open(infoBox, anchor);\n                if (onLoad) {\n                    onLoad(infoBox);\n                }\n            }\n        };\n    }\n    componentDidMount() {\n        const { options } = this.props;\n        const _a = options || {}, { position } = _a, infoBoxOptions = __rest$1(_a, [\"position\"]);\n        let positionLatLng;\n        if (position && !(position instanceof google.maps.LatLng)) {\n            positionLatLng = new google.maps.LatLng(position.lat, position.lng);\n        }\n        const infoBox = new InfoBox(Object.assign(Object.assign({}, infoBoxOptions), (positionLatLng ? { position: positionLatLng } : {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$d,\n            eventMap: eventMap$d,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoBox,\n        });\n        this.setState({ infoBox }, this.setInfoBoxCallback);\n    }\n    componentDidUpdate(prevProps) {\n        const { infoBox } = this.state;\n        if (infoBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$d,\n                eventMap: eventMap$d,\n                prevProps,\n                nextProps: this.props,\n                instance: infoBox,\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { onUnmount } = this.props;\n        const { infoBox } = this.state;\n        if (infoBox !== null) {\n            if (onUnmount) {\n                onUnmount(infoBox);\n            }\n            unregisterEvents(this.registeredEvents);\n            infoBox.close();\n        }\n    }\n    render() {\n        if (!this.containerElement) {\n            return null;\n        }\n        return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children), this.containerElement);\n    }\n}\nInfoBoxComponent.contextType = MapContext;\n\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nvar factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\nvar distance$1 = {\n\t/**\n  * Euclidean distance\n  */\n\teudist: function eudist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar d = (v1[i] || 0) - (v2[i] || 0);\n\t\t\tsum += d * d;\n\t\t}\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\tmandist: function mandist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tsum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n\t\t}\n\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\n\n\t/**\n  * Unidimensional distance\n  */\n\tdist: function dist(v1, v2, sqrt) {\n\t\tvar d = Math.abs(v1 - v2);\n\t\treturn sqrt ? d : d * d;\n\t}\n};\n\nvar Distance$1 = distance$1,\n    eudist$1 = Distance$1.eudist,\n    dist = Distance$1.dist;\n\nvar kinit = {\n\tkmrand: function kmrand(data, k) {\n\t\tvar map = {},\n\t\t    ks = [],\n\t\t    t = k << 2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length > 0;\n\n\t\twhile (ks.length < k && t-- > 0) {\n\t\t\tvar d = data[Math.floor(Math.random() * len)];\n\t\t\tvar key = multi ? d.join(\"_\") : \"\" + d;\n\t\t\tif (!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n\t},\n\n\n\t/**\n  * K-means++ initial centroid selection\n  */\n\tkmpp: function kmpp(data, k) {\n\t\tvar distance = data[0].length ? eudist$1 : dist;\n\t\tvar ks = [],\n\t\t    len = data.length;\n\t\tvar multi = data[0].length > 0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random() * len)];\n\t\tvar key = multi ? c.join(\"_\") : \"\" + c;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile (ks.length < k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tvar dists = [],\n\t\t\t    lk = ks.length;\n\t\t\tvar dsum = 0,\n\t\t\t    prs = [];\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar min = Infinity;\n\t\t\t\tfor (var j = 0; j < lk; j++) {\n\t\t\t\t\tvar _dist = distance(data[i], ks[j]);\n\t\t\t\t\tif (_dist <= min) min = _dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tdsum += dists[_i];\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\tprs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort(function (a, b) {\n\t\t\t\treturn a.pr - b.pr;\n\t\t\t});\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor (var _i3 = 1; _i3 < len; _i3++) {\n\t\t\t\tprs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tvar rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tvar idx = 0;\n\t\t\twhile (idx < len - 1 && prs[idx++].cs < rnd) {}\n\t\t\tks.push(prs[idx - 1].v);\n\t\t\t/*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */\n\t\t}\n\n\t\treturn ks;\n\t}\n};\n\n/*jshint esversion: 6 */\n\nvar Distance = distance$1,\n    ClusterInit = kinit,\n    eudist = Distance.eudist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n\tv = v || [];\n\tfor (var i = 0; i < len; i++) {\n\t\tv[i] = val;\n\t}return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n\tvar ks = [],\n\t    old = [],\n\t    idxs = [],\n\t    dist = [];\n\tvar conv = false,\n\t    it = maxit || MAX;\n\tvar len = data.length,\n\t    vlen = data[0].length,\n\t    multi = vlen > 0;\n\tvar count = [];\n\n\tif (!initial) {\n\t\tvar _idxs = {};\n\t\twhile (ks.length < k) {\n\t\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\tif (!_idxs[idx]) {\n\t\t\t\t_idxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t} else if (initial == \"kmrand\") {\n\t\tks = kmrand(data, k);\n\t} else if (initial == \"kmpp\") {\n\t\tks = kmpp(data, k);\n\t} else {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k, 0, count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar min = Infinity,\n\t\t\t    _idx = 0;\n\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\t\t\t\tif (dist <= min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\t_idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = _idx; // Index of the selected centroid for that value\n\t\t\tcount[_idx]++; // Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [],\n\t\t    old = [];\n\t\tfor (var _j = 0; _j < k; _j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n\t\t\told[_j] = ks[_j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif (multi) {\n\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\tks[_j2] = [];\n\t\t\t} // Sum values and count for each centroid\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tvar _idx2 = idxs[_i],\n\t\t\t\t    // Centroid for that item\n\t\t\t\tvsum = sum[_idx2],\n\t\t\t\t    // Sum values for this centroid\n\t\t\t\tvect = data[_i]; // Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor (var h = 0; h < vlen; h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor (var _j3 = 0; _j3 < k; _j3++) {\n\t\t\t\tvar ksj = ks[_j3],\n\t\t\t\t    // Current centroid\n\t\t\t\tsumj = sum[_j3],\n\t\t\t\t    // Accumulated centroid values\n\t\t\t\toldj = old[_j3],\n\t\t\t\t    // Old centroid value\n\t\t\t\tcj = count[_j3]; // Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor (var _h = 0; _h < vlen; _h++) {\n\t\t\t\t\tksj[_h] = sumj[_h] / cj || 0; // New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif (conv) {\n\t\t\t\t\tfor (var _h2 = 0; _h2 < vlen; _h2++) {\n\t\t\t\t\t\tif (oldj[_h2] != ksj[_h2]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t\t// Sum values and count for each centroid\n\t\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\t\tvar _idx3 = idxs[_i2];\n\t\t\t\t\tsum[_idx3] += data[_i2];\n\t\t\t\t}\n\t\t\t\t// Calculate the average for each centroid\n\t\t\t\tfor (var _j4 = 0; _j4 < k; _j4++) {\n\t\t\t\t\tks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n\t\t\t\t}\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tconv = true;\n\t\t\t\tfor (var _j5 = 0; _j5 < k; _j5++) {\n\t\t\t\t\tif (old[_j5] != ks[_j5]) {\n\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tconv = conv || --it <= 0;\n\t} while (!conv);\n\n\treturn {\n\t\tit: MAX - it,\n\t\tk: k,\n\t\tidxs: idxs,\n\t\tcentroids: ks\n\t};\n}\n\nvar main = skmeans;\n\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n    if (options === void 0) { options = {}; }\n    // Default Params\n    var count = points.features.length;\n    options.numberOfClusters =\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n    // numberOfClusters can't be greater than the number of points\n    // fallbacks to count\n    if (options.numberOfClusters > count)\n        options.numberOfClusters = count;\n    // Clone points to prevent any mutations (enabled by default)\n    if (options.mutate !== true)\n        points = clone(points);\n    // collect points coordinates\n    var data = coordAll(points);\n    // create seed to avoid skmeans to drift\n    var initialCentroids = data.slice(0, options.numberOfClusters);\n    // create skmeans clusters\n    var skmeansResult = main(data, options.numberOfClusters, initialCentroids);\n    // store centroids {clusterId: [number, number]}\n    var centroids = {};\n    skmeansResult.centroids.forEach(function (coord, idx) {\n        centroids[idx] = coord;\n    });\n    // add associated cluster number\n    featureEach(points, function (point, index) {\n        var clusterId = skmeansResult.idxs[index];\n        point.properties.cluster = clusterId;\n        point.properties.centroid = centroids[clusterId];\n    });\n    return points;\n}\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\n\nvar lib = {exports: {}};\n\nvar DBSCAN = {exports: {}};\n\n/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n(function (module) {\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\r\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {Array} */\r\n  this.dataset = [];\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 2;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n  /** @type {Array} */\r\n  this.clusters = [];\r\n  /** @type {Array} */\r\n  this.noise = [];\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._visited = [];\r\n  /** @type {Array} */\r\n  this._assigned = [];\r\n  /** @type {number} */\r\n  this._datasetLength = 0;\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n/******************************************************************************/\r\n// public functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nDBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\r\n    // if point is not visited, check if it forms a cluster\r\n    if (this._visited[pointId] !== 1) {\r\n      this._visited[pointId] = 1;\r\n\r\n      // if closest neighborhood is too small to form a cluster, mark as noise\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      if (neighbors.length < this.minPts) {\r\n        this.noise.push(pointId);\r\n      } else {\r\n        // create new cluster and add point\r\n        var clusterId = this.clusters.length;\r\n        this.clusters.push([]);\r\n        this._addToCluster(pointId, clusterId);\r\n\r\n        this._expandCluster(clusterId, neighbors);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this.noise = [];\r\n\r\n    this._datasetLength = dataset.length;\r\n    this._visited = new Array(this._datasetLength);\r\n    this._assigned = new Array(this._datasetLength);\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._expandCluster = function(clusterId, neighbors) {\r\n\r\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\r\n  for (var i = 0; i < neighbors.length; i++) {\r\n    var pointId2 = neighbors[i];\r\n\r\n    if (this._visited[pointId2] !== 1) {\r\n      this._visited[pointId2] = 1;\r\n      var neighbors2 = this._regionQuery(pointId2);\r\n\r\n      if (neighbors2.length >= this.minPts) {\r\n        neighbors = this._mergeArrays(neighbors, neighbors2);\r\n      }\r\n    }\r\n\r\n    // add to cluster\r\n    if (this._assigned[pointId2] !== 1) {\r\n      this._addToCluster(pointId2, clusterId);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\r\nDBSCAN.prototype._addToCluster = function(pointId, clusterId) {\r\n  this.clusters[clusterId].push(pointId);\r\n  this._assigned[pointId] = 1;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._regionQuery = function(pointId) {\r\n  var neighbors = [];\r\n\r\n  for (var id = 0; id < this._datasetLength; id++) {\r\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\r\n    if (dist < this.epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._mergeArrays = function(a, b) {\r\n  var len = b.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var P = b[i];\r\n    if (a.indexOf(P) < 0) {\r\n      a.push(P);\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (module.exports) {\r\n  module.exports = DBSCAN;\r\n}\n}(DBSCAN));\n\nvar KMEANS = {exports: {}};\n\n(function (module) {\n/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\r\n function KMEANS(dataset, k, distance) {\r\n  this.k = 3; // number of clusters\r\n  this.dataset = []; // set of feature vectors\r\n  this.assignments = []; // set of associated clusters for each feature vector\r\n  this.centroids = []; // vectors for our clusters\r\n\r\n  this.init(dataset, k, distance);\r\n}\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.init = function(dataset, k, distance) {\r\n  this.assignments = [];\r\n  this.centroids = [];\r\n\r\n  if (typeof dataset !== 'undefined') {\r\n    this.dataset = dataset;\r\n  }\r\n\r\n  if (typeof k !== 'undefined') {\r\n    this.k = k;\r\n  }\r\n\r\n  if (typeof distance !== 'undefined') {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.run = function(dataset, k) {\r\n  this.init(dataset, k);\r\n\r\n  var len = this.dataset.length;\r\n\r\n  // initialize centroids\r\n  for (var i = 0; i < this.k; i++) {\r\n    this.centroids[i] = this.randomCentroid();\r\n\t}\r\n\r\n  var change = true;\r\n  while(change) {\r\n\r\n    // assign feature vectors to clusters\r\n    change = this.assign();\r\n\r\n    // adjust location of centroids\r\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\r\n      var mean = new Array(maxDim);\r\n      var count = 0;\r\n\r\n      // init mean vector\r\n      for (var dim = 0; dim < maxDim; dim++) {\r\n        mean[dim] = 0;\r\n      }\r\n\r\n      for (var j = 0; j < len; j++) {\r\n        var maxDim = this.dataset[j].length;\r\n\r\n        // if current cluster id is assigned to point\r\n        if (centroidId === this.assignments[j]) {\r\n          for (var dim = 0; dim < maxDim; dim++) {\r\n            mean[dim] += this.dataset[j][dim];\r\n          }\r\n          count++;\r\n        }\r\n      }\r\n\r\n      if (count > 0) {\r\n        // if cluster contain points, adjust centroid position\r\n        for (var dim = 0; dim < maxDim; dim++) {\r\n          mean[dim] /= count;\r\n        }\r\n        this.centroids[centroidId] = mean;\r\n      } else {\r\n        // if cluster is empty, generate new random centroid\r\n        this.centroids[centroidId] = this.randomCentroid();\r\n        change = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.getClusters();\r\n};\r\n\r\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\r\nKMEANS.prototype.randomCentroid = function() {\r\n  var maxId = this.dataset.length -1;\r\n  var centroid;\r\n  var id;\r\n\r\n  do {\r\n    id = Math.round(Math.random() * maxId);\r\n    centroid = this.dataset[id];\r\n  } while (this.centroids.indexOf(centroid) >= 0);\r\n\r\n  return centroid;\r\n};\r\n\r\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\r\nKMEANS.prototype.assign = function() {\r\n  var change = false;\r\n  var len = this.dataset.length;\r\n  var closestCentroid;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\r\n\r\n    if (closestCentroid != this.assignments[i]) {\r\n      this.assignments[i] = closestCentroid;\r\n      change = true;\r\n    }\r\n  }\r\n\r\n  return change;\r\n};\r\n\r\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.getClusters = function() {\r\n  var clusters = new Array(this.k);\r\n  var centroidId;\r\n\r\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\r\n    centroidId = this.assignments[pointId];\r\n\r\n    // init empty cluster\r\n    if (typeof clusters[centroidId] === 'undefined') {\r\n      clusters[centroidId] = [];\r\n    }\r\n\r\n    clusters[centroidId].push(pointId);\r\n  }\r\n\r\n  return clusters;\r\n};\r\n\r\n// utils\r\n\r\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.argmin = function(point, set, f) {\r\n  var min = Number.MAX_VALUE;\r\n  var arg = 0;\r\n  var len = set.length;\r\n  var d;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    d = f(point, set[i]);\r\n    if (d < min) {\r\n      min = d;\r\n      arg = i;\r\n    }\r\n  }\r\n\r\n  return arg;\r\n};\r\n\r\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.distance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    var diff = p[i] - q[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (module.exports) {\r\n  module.exports = KMEANS;\r\n}\n}(KMEANS));\n\nvar OPTICS = {exports: {}};\n\nvar PriorityQueue = {exports: {}};\n\n/**\r\n * PriorityQueue\r\n * Elements in this queue are sorted according to their value\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n(function (module) {\n/**\r\n * PriorityQueue class construcotr\r\n * @constructor\r\n *\r\n * @example\r\n * queue: [1,2,3,4]\r\n * priorities: [4,1,2,3]\r\n * > result = [1,4,2,3]\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @param {string} sorting - asc / desc\r\n * @returns {PriorityQueue}\r\n */\r\nfunction PriorityQueue(elements, priorities, sorting) {\r\n  /** @type {Array} */\r\n  this._queue = [];\r\n  /** @type {Array} */\r\n  this._priorities = [];\r\n  /** @type {string} */\r\n  this._sorting = 'desc';\r\n\r\n  this._init(elements, priorities, sorting);\r\n}\r\n/**\r\n * Insert element\r\n *\r\n * @param {Object} ele\r\n * @param {Object} priority\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.insert = function(ele, priority) {\r\n  var indexToInsert = this._queue.length;\r\n  var index = indexToInsert;\r\n\r\n  while (index--) {\r\n    var priority2 = this._priorities[index];\r\n    if (this._sorting === 'desc') {\r\n      if (priority > priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    } else {\r\n      if (priority < priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    }\r\n  }\r\n\r\n  this._insertAt(ele, priority, indexToInsert);\r\n};\r\n\r\n/**\r\n * Remove element\r\n *\r\n * @param {Object} ele\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.remove = function(ele) {\r\n  var index = this._queue.length;\r\n\r\n  while (index--) {\r\n    var ele2 = this._queue[index];\r\n    if (ele === ele2) {\r\n      this._queue.splice(index, 1);\r\n      this._priorities.splice(index, 1);\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * For each loop wrapper\r\n *\r\n * @param {function} func\r\n * @returs {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.forEach = function(func) {\r\n  this._queue.forEach(func);\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElements = function() {\r\n  return this._queue;\r\n};\r\n\r\n/**\r\n * @param {number} index\r\n * @returns {Object}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementPriority = function(index) {\r\n  return this._priorities[index];\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getPriorities = function() {\r\n  return this._priorities;\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementsWithPriorities = function() {\r\n  var result = [];\r\n\r\n  for (var i = 0, l = this._queue.length; i < l; i++) {\r\n    result.push([this._queue[i], this._priorities[i]]);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._init = function(elements, priorities, sorting) {\r\n\r\n  if (elements && priorities) {\r\n    this._queue = [];\r\n    this._priorities = [];\r\n\r\n    if (elements.length !== priorities.length) {\r\n      throw new Error('Arrays must have the same length');\r\n    }\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n      this.insert(elements[i], priorities[i]);\r\n    }\r\n  }\r\n\r\n  if (sorting) {\r\n    this._sorting = sorting;\r\n  }\r\n};\r\n\r\n/**\r\n * Insert element at given position\r\n *\r\n * @param {Object} ele\r\n * @param {number} index\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._insertAt = function(ele, priority, index) {\r\n  if (this._queue.length === index) {\r\n    this._queue.push(ele);\r\n    this._priorities.push(priority);\r\n  } else {\r\n    this._queue.splice(index, 0, ele);\r\n    this._priorities.splice(index, 0, priority);\r\n  }\r\n};\r\n\r\nif (module.exports) {\r\n  module.exports = PriorityQueue;\r\n}\n}(PriorityQueue));\n\n(function (module) {\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (module.exports) {\r\n      var PriorityQueue$1 = PriorityQueue.exports;\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue$1(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (module.exports) {\r\n  module.exports = OPTICS;\r\n}\n}(OPTICS));\n\n(function (module) {\nif (module.exports) {\r\n    module.exports = {\r\n      DBSCAN: DBSCAN.exports,\r\n      KMEANS: KMEANS.exports,\r\n      OPTICS: OPTICS.exports,\r\n      PriorityQueue: PriorityQueue.exports\r\n    };\r\n}\n}(lib));\n\nvar clustering = lib.exports;\n\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n    // Input validation being handled by Typescript\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n    if (options === void 0) { options = {}; }\n    // Clone points to prevent any mutations\n    if (options.mutate !== true)\n        points = clone(points);\n    // Defaults\n    options.minPoints = options.minPoints || 3;\n    // create clustered ids\n    var dbscan = new clustering.DBSCAN();\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n    // Tag points to Clusters ID\n    var clusterId = -1;\n    clusteredIds.forEach(function (clusterIds) {\n        clusterId++;\n        // assign cluster ids to input points\n        clusterIds.forEach(function (idx) {\n            var clusterPoint = points.features[idx];\n            if (!clusterPoint.properties)\n                clusterPoint.properties = {};\n            clusterPoint.properties.cluster = clusterId;\n            clusterPoint.properties.dbscan = \"core\";\n        });\n    });\n    // handle noise points, if any\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n    dbscan.noise.forEach(function (noiseId) {\n        var noisePoint = points.features[noiseId];\n        if (!noisePoint.properties)\n            noisePoint.properties = {};\n        if (noisePoint.properties.cluster)\n            noisePoint.properties.dbscan = \"edge\";\n        else\n            noisePoint.properties.dbscan = \"noise\";\n    });\n    return points;\n}\n\nvar supercluster = {exports: {}};\n\n(function (module, exports) {\n(function (global, factory) {\nmodule.exports = factory() ;\n})(commonjsGlobal, (function () {\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) { return; }\n\n    var m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) { swapItem(ids, coords, left, right); }\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) { i++; }\n            while (coords[2 * j + inc] > t) { j--; }\n        }\n\n        if (coords[2 * left + inc] === t) { swapItem(ids, coords, left, j); }\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nvar defaultGetX = function (p) { return p[0]; };\nvar defaultGetY = function (p) { return p[1]; };\n\nvar KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if ( getX === void 0 ) getX = defaultGetX;\n    if ( getY === void 0 ) getY = defaultGetY;\n    if ( nodeSize === void 0 ) nodeSize = 64;\n    if ( ArrayType === void 0 ) ArrayType = Float64Array;\n\n    this.nodeSize = nodeSize;\n    this.points = points;\n\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        ids[i] = i;\n        coords[2 * i] = getX(points[i]);\n        coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n};\n\nKDBush.prototype.range = function range$1 (minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n};\n\nKDBush.prototype.within = function within$1 (x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n};\n\nvar defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: function (props) { return props; } // props => ({sum: props.my_value})\n};\n\nvar fround = Math.fround || (function (tmp) { return (function (x) { tmp[0] = +x; return tmp[0]; }); })(new Float32Array(1));\n\nvar Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n};\n\nSupercluster.prototype.load = function load (points) {\n    var ref = this.options;\n        var log = ref.log;\n        var minZoom = ref.minZoom;\n        var maxZoom = ref.maxZoom;\n        var nodeSize = ref.nodeSize;\n\n    if (log) { console.time('total time'); }\n\n    var timerId = \"prepare \" + (points.length) + \" points\";\n    if (log) { console.time(timerId); }\n\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    var clusters = [];\n    for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) { continue; }\n        clusters.push(createPointCluster(points[i], i));\n    }\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n    if (log) { console.timeEnd(timerId); }\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now();\n\n        // create a new set of clusters for the zoom and index them with a KD-tree\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) { console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now); }\n    }\n\n    if (log) { console.timeEnd('total time'); }\n\n    return this;\n};\n\nSupercluster.prototype.getClusters = function getClusters (bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n    } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n    }\n\n    var tree = this.trees[this._limitZoom(zoom)];\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = tree.points[id];\n        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n    return clusters;\n};\n\nSupercluster.prototype.getChildren = function getChildren (clusterId) {\n    var originId = this._getOriginId(clusterId);\n    var originZoom = this._getOriginZoom(clusterId);\n    var errorMsg = 'No cluster with the specified id.';\n\n    var index = this.trees[originZoom];\n    if (!index) { throw new Error(errorMsg); }\n\n    var origin = index.points[originId];\n    if (!origin) { throw new Error(errorMsg); }\n\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = index.points[id];\n        if (c.parentId === clusterId) {\n            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n    }\n\n    if (children.length === 0) { throw new Error(errorMsg); }\n\n    return children;\n};\n\nSupercluster.prototype.getLeaves = function getLeaves (clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n\n    var leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n};\n\nSupercluster.prototype.getTile = function getTile (z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n        var extent = ref.extent;\n        var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n\n    var tile = {\n        features: []\n    };\n\n    this._addTileFeatures(\n        tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n        tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n        this._addTileFeatures(\n            tree.range(1 - p / z2, top, 1, bottom),\n            tree.points, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n        this._addTileFeatures(\n            tree.range(0, top, p / z2, bottom),\n            tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n};\n\nSupercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom (clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) { break; }\n        clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n};\n\nSupercluster.prototype._appendLeaves = function _appendLeaves (result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n\n    for (var i = 0, list = children; i < list.length; i += 1) {\n        var child = list[i];\n\n            var props = child.properties;\n\n        if (props && props.cluster) {\n            if (skipped + props.point_count <= offset) {\n                // skip the whole cluster\n                skipped += props.point_count;\n            } else {\n                // enter the cluster\n                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                // exit the cluster\n            }\n        } else if (skipped < offset) {\n            // skip a single point\n            skipped++;\n        } else {\n            // add a single point\n            result.push(child);\n        }\n        if (result.length === limit) { break; }\n    }\n\n    return skipped;\n};\n\nSupercluster.prototype._addTileFeatures = function _addTileFeatures (ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n        var i = list[i$1];\n\n            var c = points[i];\n        var isCluster = c.numPoints;\n\n        var tags = (void 0), px = (void 0), py = (void 0);\n        if (isCluster) {\n            tags = getClusterProperties(c);\n            px = c.x;\n            py = c.y;\n        } else {\n            var p = this.points[c.index];\n            tags = p.properties;\n            px = lngX(p.geometry.coordinates[0]);\n            py = latY(p.geometry.coordinates[1]);\n        }\n\n        var f = {\n            type: 1,\n            geometry: [[\n                Math.round(this.options.extent * (px * z2 - x)),\n                Math.round(this.options.extent * (py * z2 - y))\n            ]],\n            tags: tags\n        };\n\n        // assign id\n        var id = (void 0);\n        if (isCluster) {\n            id = c.id;\n        } else if (this.options.generateId) {\n            // optionally generate id\n            id = c.index;\n        } else if (this.points[c.index].id) {\n            // keep id if already assigned\n            id = this.points[c.index].id;\n        }\n\n        if (id !== undefined) { f.id = id; }\n\n        tile.features.push(f);\n    }\n};\n\nSupercluster.prototype._limitZoom = function _limitZoom (z) {\n    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n};\n\nSupercluster.prototype._cluster = function _cluster (points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n        var radius = ref.radius;\n        var extent = ref.extent;\n        var reduce = ref.reduce;\n        var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom));\n\n    // loop through each point\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        // if we've already visited the point at this zoom level, skip it\n        if (p.zoom <= zoom) { continue; }\n        p.zoom = zoom;\n\n        // find all nearby points\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n\n        var numPointsOrigin = p.numPoints || 1;\n        var numPoints = numPointsOrigin;\n\n        // count the number of points in a potential cluster\n        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n            var neighborId = list[i$1];\n\n                var b = tree.points[neighborId];\n            // filter out neighbors that are already processed\n            if (b.zoom > zoom) { numPoints += b.numPoints || 1; }\n        }\n\n        // if there were neighbors to merge, and there are enough points to form a cluster\n        if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n            var wx = p.x * numPointsOrigin;\n            var wy = p.y * numPointsOrigin;\n\n            var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n            // encode both zoom and point index on which the cluster originated -- offset by total length of features\n            var id = (i << 5) + (zoom + 1) + this.points.length;\n\n            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n                var neighborId$1 = list$1[i$2];\n\n                    var b$1 = tree.points[neighborId$1];\n\n                if (b$1.zoom <= zoom) { continue; }\n                b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b$1.numPoints || 1;\n                wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b$1.y * numPoints2;\n\n                b$1.parentId = id;\n\n                if (reduce) {\n                    if (!clusterProperties) { clusterProperties = this._map(p, true); }\n                    reduce(clusterProperties, this._map(b$1));\n                }\n            }\n\n            p.parentId = id;\n            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n        } else { // left points as unclustered\n            clusters.push(p);\n\n            if (numPoints > 1) {\n                for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n                    var neighborId$2 = list$2[i$3];\n\n                        var b$2 = tree.points[neighborId$2];\n                    if (b$2.zoom <= zoom) { continue; }\n                    b$2.zoom = zoom;\n                    clusters.push(b$2);\n                }\n            }\n        }\n    }\n\n    return clusters;\n};\n\n// get index of the point from which the cluster originated\nSupercluster.prototype._getOriginId = function _getOriginId (clusterId) {\n    return (clusterId - this.points.length) >> 5;\n};\n\n// get zoom of the point from which the cluster originated\nSupercluster.prototype._getOriginZoom = function _getOriginZoom (clusterId) {\n    return (clusterId - this.points.length) % 32;\n};\n\nSupercluster.prototype._map = function _map (point, clone) {\n    if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n    }\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? ((Math.round(count / 1000)) + \"k\") :\n        count >= 1000 ? ((Math.round(count / 100) / 10) + \"k\") : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) { dest[id] = src[id]; }\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n\nreturn Supercluster;\n\n}));\n}(supercluster));\n\nvar SuperCluster = supercluster.exports;\n\nvar es6 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Cluster {\r\n    constructor({ markers, position }) {\r\n        this.markers = markers;\r\n        if (position) {\r\n            if (position instanceof google.maps.LatLng) {\r\n                this._position = position;\r\n            }\r\n            else {\r\n                this._position = new google.maps.LatLng(position);\r\n            }\r\n        }\r\n    }\r\n    get bounds() {\r\n        if (this.markers.length === 0 && !this._position) {\r\n            return undefined;\r\n        }\r\n        return this.markers.reduce((bounds, marker) => {\r\n            return bounds.extend(marker.getPosition());\r\n        }, new google.maps.LatLngBounds(this._position, this._position));\r\n    }\r\n    get position() {\r\n        return this._position || this.bounds.getCenter();\r\n    }\r\n    /**\r\n     * Get the count of **visible** markers.\r\n     */\r\n    get count() {\r\n        return this.markers.filter((m) => m.getVisible())\r\n            .length;\r\n    }\r\n    /**\r\n     * Add a marker to the cluster.\r\n     */\r\n    push(marker) {\r\n        this.markers.push(marker);\r\n    }\r\n    /**\r\n     * Cleanup references and remove marker from map.\r\n     */\r\n    delete() {\r\n        if (this.marker) {\r\n            this.marker.setMap(null);\r\n            delete this.marker;\r\n        }\r\n        this.markers.length = 0;\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst filterMarkersToPaddedViewport = (map, mapCanvasProjection, markers, viewportPadding) => {\r\n    const extendedMapBounds = extendBoundsToPaddedViewport(map.getBounds(), mapCanvasProjection, viewportPadding);\r\n    return markers.filter((marker) => extendedMapBounds.contains(marker.getPosition()));\r\n};\r\n/**\r\n * Extends a bounds by a number of pixels in each direction.\r\n */\r\nconst extendBoundsToPaddedViewport = (bounds, projection, pixels) => {\r\n    const { northEast, southWest } = latLngBoundsToPixelBounds(bounds, projection);\r\n    const extendedPixelBounds = extendPixelBounds({ northEast, southWest }, pixels);\r\n    return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\r\n};\r\n/**\r\n * @hidden\r\n */\r\nconst distanceBetweenPoints = (p1, p2) => {\r\n    const R = 6371; // Radius of the Earth in km\r\n    const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\r\n    const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\r\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n        Math.cos((p1.lat * Math.PI) / 180) *\r\n            Math.cos((p2.lat * Math.PI) / 180) *\r\n            Math.sin(dLon / 2) *\r\n            Math.sin(dLon / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n};\r\n/**\r\n * @hidden\r\n */\r\nconst latLngBoundsToPixelBounds = (bounds, projection) => {\r\n    return {\r\n        northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\r\n        southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\r\n    };\r\n};\r\n/**\r\n * @hidden\r\n */\r\nconst extendPixelBounds = ({ northEast, southWest }, pixels) => {\r\n    northEast.x += pixels;\r\n    northEast.y -= pixels;\r\n    southWest.x -= pixels;\r\n    southWest.y += pixels;\r\n    return { northEast, southWest };\r\n};\r\n/**\r\n * @hidden\r\n */\r\nconst pixelBoundsToLatLngBounds = ({ northEast, southWest }, projection) => {\r\n    const bounds = new google.maps.LatLngBounds();\r\n    bounds.extend(projection.fromDivPixelToLatLng(northEast));\r\n    bounds.extend(projection.fromDivPixelToLatLng(southWest));\r\n    return bounds;\r\n};\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @hidden\r\n */\r\nclass AbstractAlgorithm {\r\n    constructor({ maxZoom = 16 }) {\r\n        this.maxZoom = maxZoom;\r\n    }\r\n    /**\r\n     * Helper function to bypass clustering based upon some map state such as\r\n     * zoom, number of markers, etc.\r\n     *\r\n     * ```typescript\r\n     *  cluster({markers, map}: AlgorithmInput): Cluster[] {\r\n     *    if (shouldBypassClustering(map)) {\r\n     *      return this.noop({markers, map})\r\n     *    }\r\n     * }\r\n     * ```\r\n     */\r\n    noop({ markers }) {\r\n        return noop$1(markers);\r\n    }\r\n}\r\n/**\r\n * Abstract viewport algorithm proves a class to filter markers by a padded\r\n * viewport. This is a common optimization.\r\n *\r\n * @hidden\r\n */\r\nclass AbstractViewportAlgorithm extends AbstractAlgorithm {\r\n    constructor(_a) {\r\n        var { viewportPadding = 60 } = _a, options = __rest(_a, [\"viewportPadding\"]);\r\n        super(options);\r\n        this.viewportPadding = 60;\r\n        this.viewportPadding = viewportPadding;\r\n    }\r\n    calculate({ markers, map, mapCanvasProjection, }) {\r\n        if (map.getZoom() >= this.maxZoom) {\r\n            return {\r\n                clusters: this.noop({\r\n                    markers,\r\n                    map,\r\n                    mapCanvasProjection,\r\n                }),\r\n                changed: false,\r\n            };\r\n        }\r\n        return {\r\n            clusters: this.cluster({\r\n                markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\r\n                map,\r\n                mapCanvasProjection,\r\n            }),\r\n        };\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n */\r\nconst noop$1 = (markers) => {\r\n    const clusters = markers.map((marker) => new Cluster({\r\n        position: marker.getPosition(),\r\n        markers: [marker],\r\n    }));\r\n    return clusters;\r\n};\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The default Grid algorithm historically used in Google Maps marker\r\n * clustering.\r\n *\r\n * The Grid algorithm does not implement caching and markers may flash as the\r\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\r\n */\r\nclass GridAlgorithm extends AbstractViewportAlgorithm {\r\n    constructor(_a) {\r\n        var { maxDistance = 40000, gridSize = 40 } = _a, options = __rest(_a, [\"maxDistance\", \"gridSize\"]);\r\n        super(options);\r\n        this.clusters = [];\r\n        this.maxDistance = maxDistance;\r\n        this.gridSize = gridSize;\r\n    }\r\n    cluster({ markers, map, mapCanvasProjection, }) {\r\n        this.clusters = [];\r\n        markers.forEach((marker) => {\r\n            this.addToClosestCluster(marker, map, mapCanvasProjection);\r\n        });\r\n        return this.clusters;\r\n    }\r\n    addToClosestCluster(marker, map, projection) {\r\n        let maxDistance = this.maxDistance; // Some large number\r\n        let cluster = null;\r\n        for (let i = 0; i < this.clusters.length; i++) {\r\n            const candidate = this.clusters[i];\r\n            const distance = distanceBetweenPoints(candidate.bounds.getCenter().toJSON(), marker.getPosition().toJSON());\r\n            if (distance < maxDistance) {\r\n                maxDistance = distance;\r\n                cluster = candidate;\r\n            }\r\n        }\r\n        if (cluster &&\r\n            extendBoundsToPaddedViewport(cluster.bounds, projection, this.gridSize).contains(marker.getPosition())) {\r\n            cluster.push(marker);\r\n        }\r\n        else {\r\n            const cluster = new Cluster({ markers: [marker] });\r\n            this.clusters.push(cluster);\r\n        }\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\r\n */\r\nclass NoopAlgorithm extends AbstractAlgorithm {\r\n    constructor(_a) {\r\n        var options = __rest(_a, []);\r\n        super(options);\r\n    }\r\n    calculate({ markers, map, mapCanvasProjection, }) {\r\n        return {\r\n            clusters: this.cluster({ markers, map, mapCanvasProjection }),\r\n            changed: false,\r\n        };\r\n    }\r\n    cluster(input) {\r\n        return this.noop(input);\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Experimental algorithm using Kmeans.\r\n *\r\n * The Grid algorithm does not implement caching and markers may flash as the\r\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\r\n *\r\n * @see https://www.npmjs.com/package/@turf/clusters-kmeans\r\n */\r\nclass KmeansAlgorithm extends AbstractViewportAlgorithm {\r\n    constructor(_a) {\r\n        var { numberOfClusters } = _a, options = __rest(_a, [\"numberOfClusters\"]);\r\n        super(options);\r\n        this.numberOfClusters = numberOfClusters;\r\n    }\r\n    cluster({ markers, map }) {\r\n        const clusters = [];\r\n        if (markers.length === 0) {\r\n            return clusters;\r\n        }\r\n        const points = featureCollection(markers.map((marker) => {\r\n            return point([marker.getPosition().lng(), marker.getPosition().lat()]);\r\n        }));\r\n        let numberOfClusters;\r\n        if (this.numberOfClusters instanceof Function) {\r\n            numberOfClusters = this.numberOfClusters(markers.length, map.getZoom());\r\n        }\r\n        else {\r\n            numberOfClusters = this.numberOfClusters;\r\n        }\r\n        clustersKmeans(points, { numberOfClusters }).features.forEach((point, i) => {\r\n            if (!clusters[point.properties.cluster]) {\r\n                clusters[point.properties.cluster] = new Cluster({\r\n                    position: {\r\n                        lng: point.properties.centroid[0],\r\n                        lat: point.properties.centroid[1],\r\n                    },\r\n                    markers: [],\r\n                });\r\n            }\r\n            clusters[point.properties.cluster].push(markers[i]);\r\n        });\r\n        return clusters;\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_INTERNAL_DBSCAN_OPTION = {\r\n    units: \"kilometers\",\r\n    mutate: false,\r\n    minPoints: 1,\r\n};\r\n/**\r\n *\r\n * **This algorithm is not yet ready for use!**\r\n *\r\n * Experimental algorithm using DBScan.\r\n *\r\n * The Grid algorithm does not implement caching and markers may flash as the\r\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\r\n *\r\n * @see https://www.npmjs.com/package/@turf/clusters-dbscan\r\n */\r\nclass DBScanAlgorithm extends AbstractViewportAlgorithm {\r\n    constructor(_a) {\r\n        var { maxDistance = 200, minPoints = DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints } = _a, options = __rest(_a, [\"maxDistance\", \"minPoints\"]);\r\n        super(options);\r\n        this.maxDistance = maxDistance;\r\n        this.options = Object.assign(Object.assign({}, DEFAULT_INTERNAL_DBSCAN_OPTION), { minPoints });\r\n    }\r\n    cluster({ markers, mapCanvasProjection, }) {\r\n        const points = featureCollection(markers.map((marker) => {\r\n            const projectedPoint = mapCanvasProjection.fromLatLngToContainerPixel(marker.getPosition());\r\n            return point([projectedPoint.x, projectedPoint.y]);\r\n        }));\r\n        const grouped = [];\r\n        clustersDbscan(points, this.maxDistance, this.options).features.forEach((point, i) => {\r\n            if (!grouped[point.properties.cluster]) {\r\n                grouped[point.properties.cluster] = [];\r\n            }\r\n            grouped[point.properties.cluster].push(markers[i]);\r\n        });\r\n        return grouped.map((markers) => new Cluster({ markers }));\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\r\n *\r\n * @see https://www.npmjs.com/package/supercluster for more information on options.\r\n */\r\nclass SuperClusterAlgorithm extends AbstractAlgorithm {\r\n    constructor(_a) {\r\n        var { maxZoom, radius = 60 } = _a, options = __rest(_a, [\"maxZoom\", \"radius\"]);\r\n        super({ maxZoom });\r\n        this.superCluster = new SuperCluster(Object.assign({ maxZoom: this.maxZoom, radius }, options));\r\n        this.state = { zoom: null };\r\n    }\r\n    calculate(input) {\r\n        let changed = false;\r\n        if (!es6(input.markers, this.markers)) {\r\n            changed = true;\r\n            // TODO use proxy to avoid copy?\r\n            this.markers = [...input.markers];\r\n            const points = this.markers.map((marker) => {\r\n                return {\r\n                    type: \"Feature\",\r\n                    geometry: {\r\n                        type: \"Point\",\r\n                        coordinates: [\r\n                            marker.getPosition().lng(),\r\n                            marker.getPosition().lat(),\r\n                        ],\r\n                    },\r\n                    properties: { marker },\r\n                };\r\n            });\r\n            this.superCluster.load(points);\r\n        }\r\n        const state = { zoom: input.map.getZoom() };\r\n        if (!changed) {\r\n            if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) ;\r\n            else {\r\n                changed = changed || !es6(this.state, state);\r\n            }\r\n        }\r\n        this.state = state;\r\n        if (changed) {\r\n            this.clusters = this.cluster(input);\r\n        }\r\n        return { clusters: this.clusters, changed };\r\n    }\r\n    cluster({ map }) {\r\n        return this.superCluster\r\n            .getClusters([-180, -90, 180, 90], map.getZoom())\r\n            .map(this.transformCluster.bind(this));\r\n    }\r\n    transformCluster({ geometry: { coordinates: [lng, lat], }, properties, }) {\r\n        if (properties.cluster) {\r\n            return new Cluster({\r\n                markers: this.superCluster\r\n                    .getLeaves(properties.cluster_id, Infinity)\r\n                    .map((leaf) => leaf.properties.marker),\r\n                position: new google.maps.LatLng({ lat, lng }),\r\n            });\r\n        }\r\n        else {\r\n            const marker = properties.marker;\r\n            return new Cluster({\r\n                markers: [marker],\r\n                position: marker.getPosition(),\r\n            });\r\n        }\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\r\n */\r\nclass ClusterStats {\r\n    constructor(markers, clusters) {\r\n        this.markers = { sum: markers.length };\r\n        const clusterMarkerCounts = clusters.map((a) => a.count);\r\n        const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\r\n        this.clusters = {\r\n            count: clusters.length,\r\n            markers: {\r\n                mean: clusterMarkerSum / clusters.length,\r\n                sum: clusterMarkerSum,\r\n                min: Math.min(...clusterMarkerCounts),\r\n                max: Math.max(...clusterMarkerCounts),\r\n            },\r\n        };\r\n    }\r\n}\r\nclass DefaultRenderer {\r\n    /**\r\n     * The default render function for the library used by {@link MarkerClusterer}.\r\n     *\r\n     * Currently set to use the following:\r\n     *\r\n     * ```typescript\r\n     * // change color if this cluster has more markers than the mean cluster\r\n     * const color =\r\n     *   count > Math.max(10, stats.clusters.markers.mean)\r\n     *     ? \"#ff0000\"\r\n     *     : \"#0000ff\";\r\n     *\r\n     * // create svg url with fill color\r\n     * const svg = window.btoa(`\r\n     * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\r\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\r\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\r\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\r\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\r\n     * </svg>`);\r\n     *\r\n     * // create marker using svg icon\r\n     * return new google.maps.Marker({\r\n     *   position,\r\n     *   icon: {\r\n     *     url: `data:image/svg+xml;base64,${svg}`,\r\n     *     scaledSize: new google.maps.Size(45, 45),\r\n     *   },\r\n     *   label: {\r\n     *     text: String(count),\r\n     *     color: \"rgba(255,255,255,0.9)\",\r\n     *     fontSize: \"12px\",\r\n     *   },\r\n     *   // adjust zIndex to be above other markers\r\n     *   zIndex: 1000 + count,\r\n     * });\r\n     * ```\r\n     */\r\n    render({ count, position }, stats) {\r\n        // change color if this cluster has more markers than the mean cluster\r\n        const color = count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\r\n        // create svg url with fill color\r\n        const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>`);\r\n        // create marker using svg icon\r\n        return new google.maps.Marker({\r\n            position,\r\n            icon: {\r\n                url: `data:image/svg+xml;base64,${svg}`,\r\n                scaledSize: new google.maps.Size(45, 45),\r\n            },\r\n            label: {\r\n                text: String(count),\r\n                color: \"rgba(255,255,255,0.9)\",\r\n                fontSize: \"12px\",\r\n            },\r\n            // adjust zIndex to be above other markers\r\n            zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\r\n        });\r\n    }\r\n}\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Extends an object's prototype by another's.\r\n *\r\n * @param type1 The Type to be extended.\r\n * @param type2 The Type to extend with.\r\n * @ignore\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction extend(type1, type2) {\r\n    /* istanbul ignore next */\r\n    // eslint-disable-next-line prefer-const\r\n    for (let property in type2.prototype) {\r\n        type1.prototype[property] = type2.prototype[property];\r\n    }\r\n}\r\n/**\r\n * @ignore\r\n */\r\nclass OverlayViewSafe {\r\n    constructor() {\r\n        // MarkerClusterer implements google.maps.OverlayView interface. We use the\r\n        // extend function to extend MarkerClusterer with google.maps.OverlayView\r\n        // because it might not always be available when the code is defined so we\r\n        // look for it at the last possible moment. If it doesn't exist now then\r\n        // there is no point going ahead :)\r\n        extend(OverlayViewSafe, google.maps.OverlayView);\r\n    }\r\n}\n\n/**\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar MarkerClustererEvents;\r\n(function (MarkerClustererEvents) {\r\n    MarkerClustererEvents[\"CLUSTERING_BEGIN\"] = \"clusteringbegin\";\r\n    MarkerClustererEvents[\"CLUSTERING_END\"] = \"clusteringend\";\r\n    MarkerClustererEvents[\"CLUSTER_CLICK\"] = \"click\";\r\n})(MarkerClustererEvents || (MarkerClustererEvents = {}));\r\nconst defaultOnClusterClickHandler = (_, cluster, map) => {\r\n    map.fitBounds(cluster.bounds);\r\n};\r\n/**\r\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\r\n * of markers. See {@link MarkerClustererOptions} for more details.\r\n *\r\n * <iframe src=\"https://googlemaps.github.io/js-three/public/anchor/index.html\"></iframe>\r\n */\r\nclass MarkerClusterer extends OverlayViewSafe {\r\n    constructor({ map, markers = [], algorithm = new SuperClusterAlgorithm({}), renderer = new DefaultRenderer(), onClusterClick = defaultOnClusterClickHandler, }) {\r\n        super();\r\n        this.markers = [...markers];\r\n        this.clusters = [];\r\n        this.algorithm = algorithm;\r\n        this.renderer = renderer;\r\n        this.onClusterClick = onClusterClick;\r\n        if (map) {\r\n            this.setMap(map);\r\n        }\r\n    }\r\n    addMarker(marker, noDraw) {\r\n        if (this.markers.includes(marker)) {\r\n            return;\r\n        }\r\n        this.markers.push(marker);\r\n        if (!noDraw) {\r\n            this.render();\r\n        }\r\n    }\r\n    addMarkers(markers, noDraw) {\r\n        markers.forEach((marker) => {\r\n            this.addMarker(marker, true);\r\n        });\r\n        if (!noDraw) {\r\n            this.render();\r\n        }\r\n    }\r\n    removeMarker(marker, noDraw) {\r\n        const index = this.markers.indexOf(marker);\r\n        if (index === -1) {\r\n            // Marker is not in our list of markers, so do nothing:\r\n            return false;\r\n        }\r\n        marker.setMap(null);\r\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\r\n        if (!noDraw) {\r\n            this.render();\r\n        }\r\n        return true;\r\n    }\r\n    removeMarkers(markers, noDraw) {\r\n        let removed = false;\r\n        markers.forEach((marker) => {\r\n            removed = this.removeMarker(marker, true) || removed;\r\n        });\r\n        if (removed && !noDraw) {\r\n            this.render();\r\n        }\r\n        return removed;\r\n    }\r\n    clearMarkers(noDraw) {\r\n        this.markers.length = 0;\r\n        if (!noDraw) {\r\n            this.render();\r\n        }\r\n    }\r\n    /**\r\n     * Recalculates and draws all the marker clusters.\r\n     */\r\n    render() {\r\n        const map = this.getMap();\r\n        if (map instanceof google.maps.Map && this.getProjection()) {\r\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);\r\n            const { clusters, changed } = this.algorithm.calculate({\r\n                markers: this.markers,\r\n                map,\r\n                mapCanvasProjection: this.getProjection(),\r\n            });\r\n            // allow algorithms to return flag on whether the clusters/markers have changed\r\n            if (changed || changed == undefined) {\r\n                // reset visibility of markers and clusters\r\n                this.reset();\r\n                // store new clusters\r\n                this.clusters = clusters;\r\n                this.renderClusters();\r\n            }\r\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);\r\n        }\r\n    }\r\n    onAdd() {\r\n        this.idleListener = this.getMap().addListener(\"idle\", this.render.bind(this));\r\n        this.render();\r\n    }\r\n    onRemove() {\r\n        google.maps.event.removeListener(this.idleListener);\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.markers.forEach((marker) => marker.setMap(null));\r\n        this.clusters.forEach((cluster) => cluster.delete());\r\n        this.clusters = [];\r\n    }\r\n    renderClusters() {\r\n        // generate stats to pass to renderers\r\n        const stats = new ClusterStats(this.markers, this.clusters);\r\n        const map = this.getMap();\r\n        this.clusters.forEach((cluster) => {\r\n            if (cluster.markers.length === 1) {\r\n                cluster.marker = cluster.markers[0];\r\n            }\r\n            else {\r\n                cluster.marker = this.renderer.render(cluster, stats);\r\n                if (this.onClusterClick) {\r\n                    cluster.marker.addListener(\"click\", \r\n                    /* istanbul ignore next */\r\n                    (event) => {\r\n                        google.maps.event.trigger(this, MarkerClustererEvents.CLUSTER_CLICK, cluster);\r\n                        this.onClusterClick(event, cluster, map);\r\n                    });\r\n                }\r\n            }\r\n            cluster.marker.setMap(map);\r\n        });\r\n    }\r\n}\n\nvar index_esm = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tAbstractAlgorithm: AbstractAlgorithm,\n\tAbstractViewportAlgorithm: AbstractViewportAlgorithm,\n\tCluster: Cluster,\n\tClusterStats: ClusterStats,\n\tDBScanAlgorithm: DBScanAlgorithm,\n\tDefaultRenderer: DefaultRenderer,\n\tGridAlgorithm: GridAlgorithm,\n\tKmeansAlgorithm: KmeansAlgorithm,\n\tMarkerClusterer: MarkerClusterer,\n\tget MarkerClustererEvents () { return MarkerClustererEvents; },\n\tNoopAlgorithm: NoopAlgorithm,\n\tSuperClusterAlgorithm: SuperClusterAlgorithm,\n\tdefaultOnClusterClickHandler: defaultOnClusterClickHandler,\n\tdistanceBetweenPoints: distanceBetweenPoints,\n\textendBoundsToPaddedViewport: extendBoundsToPaddedViewport,\n\textendPixelBounds: extendPixelBounds,\n\tfilterMarkersToPaddedViewport: filterMarkersToPaddedViewport,\n\tnoop: noop$1,\n\tpixelBoundsToLatLngBounds: pixelBoundsToLatLngBounds\n});\n\nconst useGoogleMarkerClusterer = (options) => {\n    const map = useGoogleMap();\n    const [markerClusterer, setMarkerClusterer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (map && markerClusterer === null) {\n            const markerCluster = new MarkerClusterer(Object.assign(Object.assign({}, options), { map }));\n            setMarkerClusterer(markerCluster);\n        }\n    }, [map]);\n    return markerClusterer;\n};\n/** Wrapper around [@googlemaps/markerclusterer](https://github.com/googlemaps/js-markerclusterer)\n *\n * Accepts {@link  MarkerClustererOptionsSubset} which is a subset of  {@link MarkerClustererOptions}\n */\nconst GoogleMarkerClusterer = ({ children, options }) => {\n    const markerClusterer = useGoogleMarkerClusterer(options);\n    return markerClusterer !== null ? children(markerClusterer) : null;\n};\n\n/* global google */\nconst eventMap$c = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nconst updaterMap$c = {\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    position(instance, position) {\n        instance.setPosition(position);\n    },\n    zIndex(instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nclass InfoWindow extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.containerElement = null;\n        this.state = {\n            infoWindow: null,\n        };\n        this.open = (infoWindow, anchor) => {\n            if (anchor) {\n                infoWindow.open(this.context, anchor);\n            }\n            else if (infoWindow.getPosition()) {\n                infoWindow.open(this.context);\n            }\n            else {\n                invariant_1(false, `You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.`);\n            }\n        };\n        this.setInfoWindowCallback = () => {\n            if (this.state.infoWindow !== null && this.containerElement !== null) {\n                this.state.infoWindow.setContent(this.containerElement);\n                this.open(this.state.infoWindow, this.props.anchor);\n                if (this.props.onLoad) {\n                    this.props.onLoad(this.state.infoWindow);\n                }\n            }\n        };\n    }\n    componentDidMount() {\n        const infoWindow = new google.maps.InfoWindow(Object.assign({}, (this.props.options || {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$c,\n            eventMap: eventMap$c,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoWindow,\n        });\n        this.setState(function setInfoWindow() {\n            return {\n                infoWindow,\n            };\n        }, this.setInfoWindowCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$c,\n                eventMap: eventMap$c,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.infoWindow,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.state.infoWindow.close();\n        }\n    }\n    render() {\n        return this.containerElement ? (react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children), this.containerElement)) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null));\n    }\n}\nInfoWindow.contextType = MapContext;\n\nconst eventMap$b = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nconst updaterMap$b = {\n    draggable(instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable(instance, editable) {\n        instance.setEditable(editable);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    path(instance, path) {\n        instance.setPath(path);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nclass Polyline extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            polyline: null,\n        };\n        this.setPolylineCallback = () => {\n            if (this.state.polyline !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.polyline);\n            }\n        };\n    }\n    componentDidMount() {\n        const polyline = new google.maps.Polyline(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$b,\n            eventMap: eventMap$b,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polyline,\n        });\n        this.setState(function setPolyline() {\n            return {\n                polyline,\n            };\n        }, this.setPolylineCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.polyline !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$b,\n                eventMap: eventMap$b,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.polyline,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.polyline !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polyline);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polyline.setMap(null);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\nPolyline.contextType = MapContext;\n\n/* global google */\nconst eventMap$a = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nconst updaterMap$a = {\n    draggable(instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable(instance, editable) {\n        instance.setEditable(editable);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    path(instance, path) {\n        instance.setPath(path);\n    },\n    paths(instance, paths) {\n        instance.setPaths(paths);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nclass Polygon extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            polygon: null,\n        };\n        this.setPolygonCallback = () => {\n            if (this.state.polygon !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.polygon);\n            }\n        };\n    }\n    componentDidMount() {\n        const polygon = new google.maps.Polygon(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$a,\n            eventMap: eventMap$a,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polygon,\n        });\n        this.setState(function setPolygon() {\n            return {\n                polygon,\n            };\n        }, this.setPolygonCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.polygon !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$a,\n                eventMap: eventMap$a,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.polygon,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.polygon !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polygon);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polygon && this.state.polygon.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nPolygon.contextType = MapContext;\n\nconst eventMap$9 = {\n    onBoundsChanged: 'bounds_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nconst updaterMap$9 = {\n    bounds(instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    draggable(instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable(instance, editable) {\n        instance.setEditable(editable);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nclass Rectangle extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            rectangle: null,\n        };\n        this.setRectangleCallback = () => {\n            if (this.state.rectangle !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.rectangle);\n            }\n        };\n    }\n    componentDidMount() {\n        const rectangle = new google.maps.Rectangle(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$9,\n            eventMap: eventMap$9,\n            prevProps: {},\n            nextProps: this.props,\n            instance: rectangle,\n        });\n        this.setState(function setRectangle() {\n            return {\n                rectangle,\n            };\n        }, this.setRectangleCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.rectangle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$9,\n                eventMap: eventMap$9,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.rectangle,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.rectangle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.rectangle);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.rectangle.setMap(null);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\nRectangle.contextType = MapContext;\n\nconst eventMap$8 = {\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRadiusChanged: 'radius_changed',\n    onRightClick: 'rightclick',\n};\nconst updaterMap$8 = {\n    center(instance, center) {\n        instance.setCenter(center);\n    },\n    draggable(instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable(instance, editable) {\n        instance.setEditable(editable);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    radius(instance, radius) {\n        instance.setRadius(radius);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nclass Circle extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            circle: null,\n        };\n        this.setCircleCallback = () => {\n            if (this.state.circle !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.circle);\n            }\n        };\n    }\n    componentDidMount() {\n        const circle = new google.maps.Circle(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$8,\n            eventMap: eventMap$8,\n            prevProps: {},\n            nextProps: this.props,\n            instance: circle,\n        });\n        this.setState(function setCircle() {\n            return {\n                circle,\n            };\n        }, this.setCircleCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.circle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$8,\n                eventMap: eventMap$8,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.circle,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.circle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.circle);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.circle && this.state.circle.setMap(null);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\nCircle.contextType = MapContext;\n\nconst eventMap$7 = {\n    onAddFeature: 'addfeature',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRemoveFeature: 'removefeature',\n    onRemoveProperty: 'removeproperty',\n    onRightClick: 'rightclick',\n    onSetGeometry: 'setgeometry',\n    onSetProperty: 'setproperty',\n};\nconst updaterMap$7 = {\n    add(instance, features) {\n        instance.add(features);\n    },\n    addgeojson(instance, geojson, options) {\n        instance.addGeoJson(geojson, options);\n    },\n    contains(instance, feature) {\n        instance.contains(feature);\n    },\n    foreach(instance, callback) {\n        instance.forEach(callback);\n    },\n    loadgeojson(instance, url, options, callback) {\n        instance.loadGeoJson(url, options, callback);\n    },\n    overridestyle(instance, feature, style) {\n        instance.overrideStyle(feature, style);\n    },\n    remove(instance, feature) {\n        instance.remove(feature);\n    },\n    revertstyle(instance, feature) {\n        instance.revertStyle(feature);\n    },\n    controlposition(instance, controlPosition) {\n        instance.setControlPosition(controlPosition);\n    },\n    controls(instance, controls) {\n        instance.setControls(controls);\n    },\n    drawingmode(instance, mode) {\n        instance.setDrawingMode(mode);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    style(instance, style) {\n        instance.setStyle(style);\n    },\n    togeojson(instance, callback) {\n        instance.toGeoJson(callback);\n    },\n};\nclass Data extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            data: null,\n        };\n        this.setDataCallback = () => {\n            if (this.state.data !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.data);\n            }\n        };\n    }\n    componentDidMount() {\n        const data = new google.maps.Data(Object.assign(Object.assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$7,\n            eventMap: eventMap$7,\n            prevProps: {},\n            nextProps: this.props,\n            instance: data,\n        });\n        this.setState(function setData() {\n            return {\n                data,\n            };\n        }, this.setDataCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.data !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$7,\n                eventMap: eventMap$7,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.data,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.data !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.data);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.data) {\n                this.state.data.setMap(null);\n            }\n        }\n    }\n    render() {\n        return null;\n    }\n}\nData.contextType = MapContext;\n\nconst eventMap$6 = {\n    onClick: 'click',\n    onDefaultViewportChanged: 'defaultviewport_changed',\n    onStatusChanged: 'status_changed',\n};\nconst updaterMap$6 = {\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    url(instance, url) {\n        instance.setUrl(url);\n    },\n    zIndex(instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nclass KmlLayer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            kmlLayer: null,\n        };\n        this.setKmlLayerCallback = () => {\n            if (this.state.kmlLayer !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.kmlLayer);\n            }\n        };\n    }\n    componentDidMount() {\n        const kmlLayer = new google.maps.KmlLayer(Object.assign(Object.assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$6,\n            eventMap: eventMap$6,\n            prevProps: {},\n            nextProps: this.props,\n            instance: kmlLayer,\n        });\n        this.setState(function setLmlLayer() {\n            return {\n                kmlLayer,\n            };\n        }, this.setKmlLayerCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.kmlLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$6,\n                eventMap: eventMap$6,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.kmlLayer,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.kmlLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.kmlLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.kmlLayer.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nKmlLayer.contextType = MapContext;\n\n/* eslint-disable filenames/match-regex */\nfunction getOffsetOverride(containerElement, getPixelPositionOffset) {\n    return typeof getPixelPositionOffset === 'function'\n        ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight)\n        : {};\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst createLatLng = (inst, Type) => new Type(inst.lat, inst.lng);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst createLatLngBounds = (inst, Type) => new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ensureOfType = (inst, type, factory) => {\n    return inst instanceof type ? inst : factory(inst, type);\n};\nconst getLayoutStylesByBounds = (mapCanvasProjection, offset, bounds) => {\n    const ne = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n    const sw = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n    if (ne && sw) {\n        return {\n            left: `${sw.x + offset.x}px`,\n            top: `${ne.y + offset.y}px`,\n            width: `${ne.x - sw.x - offset.x}px`,\n            height: `${sw.y - ne.y - offset.y}px`,\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n};\nconst getLayoutStylesByPosition = (mapCanvasProjection, offset, position) => {\n    const point = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(position);\n    if (point) {\n        const { x, y } = point;\n        return {\n            left: `${x + offset.x}px`,\n            top: `${y + offset.y}px`,\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n};\nconst getLayoutStyles = (mapCanvasProjection, offset, bounds, position) => {\n    return bounds !== undefined\n        ? getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfType(bounds, google.maps.LatLngBounds, createLatLngBounds))\n        : getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));\n};\nconst arePositionsEqual = (currentPosition, previousPosition) => {\n    return currentPosition.left === previousPosition.left\n        && currentPosition.top === previousPosition.top\n        && currentPosition.width === previousPosition.height\n        && currentPosition.height === previousPosition.height;\n};\n\nfunction convertToLatLngString(latLngLike) {\n    if (!latLngLike) {\n        return '';\n    }\n    const latLng = latLngLike instanceof google.maps.LatLng\n        ? latLngLike\n        : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);\n    return latLng + '';\n}\nfunction convertToLatLngBoundsString(latLngBoundsLike) {\n    if (!latLngBoundsLike) {\n        return '';\n    }\n    const latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds\n        ? latLngBoundsLike\n        : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));\n    return latLngBounds + '';\n}\nclass OverlayView extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            paneEl: null,\n            containerStyle: {\n                // set initial position\n                position: 'absolute'\n            },\n        };\n        this.updatePane = () => {\n            const mapPaneName = this.props.mapPaneName;\n            // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes\n            const mapPanes = this.overlayView.getPanes();\n            invariant_1(!!mapPaneName, `OverlayView requires props.mapPaneName but got %s`, mapPaneName);\n            if (mapPanes) {\n                this.setState({\n                    paneEl: mapPanes[mapPaneName]\n                });\n            }\n            else {\n                this.setState({\n                    paneEl: null\n                });\n            }\n        };\n        this.onAdd = () => {\n            var _a, _b;\n            this.updatePane();\n            (_b = (_a = this.props).onLoad) === null || _b === void 0 ? void 0 : _b.call(_a, this.overlayView);\n        };\n        this.onPositionElement = () => {\n            const mapCanvasProjection = this.overlayView.getProjection();\n            const offset = Object.assign({ x: 0, y: 0 }, (this.containerRef.current\n                ? getOffsetOverride(this.containerRef.current, this.props.getPixelPositionOffset)\n                : {}));\n            const layoutStyles = getLayoutStyles(mapCanvasProjection, offset, this.props.bounds, this.props.position);\n            const { left, top, width, height } = this.state.containerStyle;\n            if (!arePositionsEqual(layoutStyles, { left, top, width, height })) {\n                this.setState({\n                    containerStyle: Object.assign(Object.assign({}, layoutStyles), { position: 'absolute' }),\n                });\n            }\n        };\n        this.draw = () => {\n            this.onPositionElement();\n        };\n        this.onRemove = () => {\n            var _a, _b;\n            this.setState(() => ({\n                paneEl: null\n            }));\n            // this.mapPaneEl = null\n            (_b = (_a = this.props).onUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, this.overlayView);\n        };\n        this.containerRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        // You must implement three methods: onAdd(), draw(), and onRemove().\n        const overlayView = new google.maps.OverlayView();\n        overlayView.onAdd = this.onAdd;\n        overlayView.draw = this.draw;\n        overlayView.onRemove = this.onRemove;\n        this.overlayView = overlayView;\n    }\n    componentDidMount() {\n        // You must call setMap() with a valid Map object to trigger the call to\n        // the onAdd() method and setMap(null) in order to trigger the onRemove() method.\n        this.overlayView.setMap(this.context);\n    }\n    componentDidUpdate(prevProps) {\n        const prevPositionString = convertToLatLngString(prevProps.position);\n        const positionString = convertToLatLngString(this.props.position);\n        const prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);\n        const boundsString = convertToLatLngBoundsString(this.props.bounds);\n        if (prevPositionString !== positionString || prevBoundsString !== boundsString) {\n            this.overlayView.draw();\n        }\n        if (prevProps.mapPaneName !== this.props.mapPaneName) {\n            this.updatePane();\n        }\n    }\n    componentWillUnmount() {\n        this.overlayView.setMap(null);\n    }\n    render() {\n        const paneEl = this.state.paneEl;\n        if (paneEl) {\n            return react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.containerRef, style: this.state.containerStyle }, react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children)), paneEl);\n        }\n        else {\n            return null;\n        }\n    }\n}\nOverlayView.FLOAT_PANE = `floatPane`;\nOverlayView.MAP_PANE = `mapPane`;\nOverlayView.MARKER_LAYER = `markerLayer`;\nOverlayView.OVERLAY_LAYER = `overlayLayer`;\nOverlayView.OVERLAY_MOUSE_TARGET = `overlayMouseTarget`;\nOverlayView.contextType = MapContext;\n\nfunction noop() { }\n\nconst eventMap$5 = {\n    onDblClick: 'dblclick',\n    onClick: 'click',\n};\nconst updaterMap$5 = {\n    opacity(instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n};\nclass GroundOverlay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            groundOverlay: null,\n        };\n        this.setGroundOverlayCallback = () => {\n            if (this.state.groundOverlay !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.groundOverlay);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!this.props.url || !!this.props.bounds, `For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by \\`react-google-maps-api\\`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just \\`key={url}\\` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655`);\n        const groundOverlay = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Object.assign(Object.assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$5,\n            eventMap: eventMap$5,\n            prevProps: {},\n            nextProps: this.props,\n            instance: groundOverlay,\n        });\n        this.setState(function setGroundOverlay() {\n            return {\n                groundOverlay,\n            };\n        }, this.setGroundOverlayCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.groundOverlay !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$5,\n                eventMap: eventMap$5,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.groundOverlay,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.groundOverlay) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.groundOverlay);\n            }\n            this.state.groundOverlay.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nGroundOverlay.defaultProps = {\n    onLoad: noop,\n};\nGroundOverlay.contextType = MapContext;\n\nconst eventMap$4 = {};\nconst updaterMap$4 = {\n    data(instance, data) {\n        instance.setData(data);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n};\nclass HeatmapLayer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            heatmapLayer: null,\n        };\n        this.setHeatmapLayerCallback = () => {\n            if (this.state.heatmapLayer !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.heatmapLayer);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} to <LoadScript />? %s', google.maps.visualization);\n        invariant_1(!!this.props.data, 'data property is required in HeatmapLayer %s', this.props.data);\n        const heatmapLayer = new google.maps.visualization.HeatmapLayer(Object.assign(Object.assign({}, (this.props.options || {})), { data: this.props.data, map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps: {},\n            nextProps: this.props,\n            instance: heatmapLayer,\n        });\n        this.setState(function setHeatmapLayer() {\n            return {\n                heatmapLayer,\n            };\n        }, this.setHeatmapLayerCallback);\n    }\n    componentDidUpdate(prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps,\n            nextProps: this.props,\n            instance: this.state.heatmapLayer,\n        });\n    }\n    componentWillUnmount() {\n        if (this.state.heatmapLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.heatmapLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.heatmapLayer.setMap(null);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nHeatmapLayer.contextType = MapContext;\n\nconst eventMap$3 = {\n    onCloseClick: 'closeclick',\n    onPanoChanged: 'pano_changed',\n    onPositionChanged: 'position_changed',\n    onPovChanged: 'pov_changed',\n    onResize: 'resize',\n    onStatusChanged: 'status_changed',\n    onVisibleChanged: 'visible_changed',\n    onZoomChanged: 'zoom_changed',\n};\nconst updaterMap$3 = {\n    register(instance, provider, options) {\n        instance.registerPanoProvider(provider, options);\n    },\n    links(instance, links) {\n        instance.setLinks(links);\n    },\n    motionTracking(instance, motionTracking) {\n        instance.setMotionTracking(motionTracking);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    pano(instance, pano) {\n        instance.setPano(pano);\n    },\n    position(instance, position) {\n        instance.setPosition(position);\n    },\n    pov(instance, pov) {\n        instance.setPov(pov);\n    },\n    visible(instance, visible) {\n        instance.setVisible(visible);\n    },\n    zoom(instance, zoom) {\n        instance.setZoom(zoom);\n    },\n};\nclass StreetViewPanorama extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            streetViewPanorama: null,\n        };\n        this.setStreetViewPanoramaCallback = () => {\n            if (this.state.streetViewPanorama !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.streetViewPanorama);\n            }\n        };\n    }\n    componentDidMount() {\n        const streetViewPanorama = this.context.getStreetView();\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$3,\n            eventMap: eventMap$3,\n            prevProps: {},\n            nextProps: this.props,\n            instance: streetViewPanorama,\n        });\n        this.setState(function setStreetViewPanorama() {\n            return {\n                streetViewPanorama,\n            };\n        }, this.setStreetViewPanoramaCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.streetViewPanorama !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$3,\n                eventMap: eventMap$3,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.streetViewPanorama,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.streetViewPanorama !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.streetViewPanorama);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.streetViewPanorama.setVisible(false);\n        }\n    }\n    render() {\n        return null;\n    }\n}\nStreetViewPanorama.contextType = MapContext;\n\nclass StreetViewService extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            streetViewService: null,\n        };\n        this.setStreetViewServiceCallback = () => {\n            if (this.state.streetViewService !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.streetViewService);\n            }\n        };\n    }\n    componentDidMount() {\n        const streetViewService = new google.maps.StreetViewService();\n        this.setState(function setStreetViewService() {\n            return {\n                streetViewService,\n            };\n        }, this.setStreetViewServiceCallback);\n    }\n    componentWillUnmount() {\n        if (this.state.streetViewService !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.streetViewService);\n            }\n        }\n    }\n    render() {\n        return null;\n    }\n}\nStreetViewService.contextType = MapContext;\n\nclass DirectionsService extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            directionsService: null,\n        };\n        this.setDirectionsServiceCallback = () => {\n            if (this.state.directionsService !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.directionsService);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!this.props.options, 'DirectionsService expected options object as parameter, but got %s', this.props.options);\n        const directionsService = new google.maps.DirectionsService();\n        this.setState(function setDirectionsService() {\n            return {\n                directionsService,\n            };\n        }, this.setDirectionsServiceCallback);\n    }\n    componentDidUpdate() {\n        if (this.state.directionsService !== null) {\n            this.state.directionsService.route(this.props.options, this.props.callback);\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.directionsService !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsService);\n            }\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\n\nconst eventMap$2 = {\n    onDirectionsChanged: 'directions_changed',\n};\nconst updaterMap$2 = {\n    directions(instance, directions) {\n        instance.setDirections(directions);\n    },\n    map(instance, map) {\n        instance.setMap(map);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    panel(instance, panel) {\n        instance.setPanel(panel);\n    },\n    routeIndex(instance, routeIndex) {\n        instance.setRouteIndex(routeIndex);\n    },\n};\nclass DirectionsRenderer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.state = {\n            directionsRenderer: null,\n        };\n        this.setDirectionsRendererCallback = () => {\n            if (this.state.directionsRenderer !== null) {\n                this.state.directionsRenderer.setMap(this.context);\n                if (this.props.onLoad) {\n                    this.props.onLoad(this.state.directionsRenderer);\n                }\n            }\n        };\n    }\n    componentDidMount() {\n        const directionsRenderer = new google.maps.DirectionsRenderer(this.props.options);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$2,\n            eventMap: eventMap$2,\n            prevProps: {},\n            nextProps: this.props,\n            instance: directionsRenderer,\n        });\n        this.setState(function setDirectionsRenderer() {\n            return {\n                directionsRenderer,\n            };\n        }, this.setDirectionsRendererCallback);\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.directionsRenderer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$2,\n                eventMap: eventMap$2,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.directionsRenderer,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.directionsRenderer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsRenderer);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.directionsRenderer) {\n                this.state.directionsRenderer.setMap(null);\n            }\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\nDirectionsRenderer.contextType = MapContext;\n\nclass DistanceMatrixService extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            distanceMatrixService: null,\n        };\n        this.setDistanceMatrixServiceCallback = () => {\n            if (this.state.distanceMatrixService !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.distanceMatrixService);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!this.props.options, 'DistanceMatrixService expected options object as parameter, but go %s', this.props.options);\n        const distanceMatrixService = new google.maps.DistanceMatrixService();\n        this.setState(function setDistanceMatrixService() {\n            return {\n                distanceMatrixService,\n            };\n        }, this.setDistanceMatrixServiceCallback);\n    }\n    componentDidUpdate() {\n        if (this.state.distanceMatrixService !== null) {\n            this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.distanceMatrixService !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.distanceMatrixService);\n            }\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n    }\n}\n\nconst eventMap$1 = {\n    onPlacesChanged: 'places_changed',\n};\nconst updaterMap$1 = {\n    bounds(instance, bounds) {\n        instance.setBounds(bounds);\n    },\n};\nclass StandaloneSearchBox extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.containerElement = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.state = {\n            searchBox: null,\n        };\n        this.setSearchBoxCallback = () => {\n            if (this.state.searchBox !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.searchBox);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        if (this.containerElement !== null && this.containerElement.current !== null) {\n            const input = this.containerElement.current.querySelector('input');\n            if (input !== null) {\n                const searchBox = new google.maps.places.SearchBox(input, this.props.options);\n                this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                    updaterMap: updaterMap$1,\n                    eventMap: eventMap$1,\n                    prevProps: {},\n                    nextProps: this.props,\n                    instance: searchBox,\n                });\n                this.setState(function setSearchBox() {\n                    return {\n                        searchBox,\n                    };\n                }, this.setSearchBoxCallback);\n            }\n        }\n    }\n    componentDidUpdate(prevProps) {\n        if (this.state.searchBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$1,\n                eventMap: eventMap$1,\n                prevProps,\n                nextProps: this.props,\n                instance: this.state.searchBox,\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.searchBox !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.searchBox);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.containerElement }, react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children));\n    }\n}\nStandaloneSearchBox.contextType = MapContext;\n\nconst eventMap = {\n    onPlaceChanged: 'place_changed',\n};\nconst updaterMap = {\n    bounds(instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    restrictions(instance, restrictions) {\n        instance.setComponentRestrictions(restrictions);\n    },\n    fields(instance, fields) {\n        instance.setFields(fields);\n    },\n    options(instance, options) {\n        instance.setOptions(options);\n    },\n    types(instance, types) {\n        instance.setTypes(types);\n    },\n};\nclass Autocomplete extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.registeredEvents = [];\n        this.containerElement = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.state = {\n            autocomplete: null,\n        };\n        this.setAutocompleteCallback = () => {\n            if (this.state.autocomplete !== null && this.props.onLoad) {\n                this.props.onLoad(this.state.autocomplete);\n            }\n        };\n    }\n    componentDidMount() {\n        invariant_1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        // TODO: why current could be equal null?\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        const input = this.containerElement.current.querySelector('input');\n        if (input) {\n            const autocomplete = new google.maps.places.Autocomplete(input, this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap,\n                eventMap,\n                prevProps: {},\n                nextProps: this.props,\n                instance: autocomplete,\n            });\n            this.setState(function setAutocomplete() {\n                return {\n                    autocomplete,\n                };\n            }, this.setAutocompleteCallback);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap,\n            eventMap,\n            prevProps,\n            nextProps: this.props,\n            instance: this.state.autocomplete,\n        });\n    }\n    componentWillUnmount() {\n        if (this.state.autocomplete !== null) {\n            unregisterEvents(this.registeredEvents);\n        }\n    }\n    render() {\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.containerElement, className: this.props.className || '' }, react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children));\n    }\n}\nAutocomplete.contextType = MapContext;\n\n\n//# sourceMappingURL=esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWN0LWdvb2dsZS1tYXBzL2FwaS9kaXN0L2VzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3VEO0FBQ2hEOztBQUV0QyxzSEFBc0gscUJBQU0sbUJBQW1CLHFCQUFNOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxhQUFvQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0RBQWE7QUFDaEM7QUFDQSxrQkFBa0IsNkNBQVU7QUFDNUIsZ0JBQWdCLGlEQUFVO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVEQUF1RDtBQUN4RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxtU0FBbVM7QUFDclU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEI7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFtQixVQUFVLHVIQUF1SDtBQUNwSyxZQUFZLGdEQUFtQix3QkFBd0IsdUJBQXVCLGtEQUFrRCxnREFBbUIsQ0FBQywyQ0FBYztBQUNsSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qix3R0FBd0c7QUFDckk7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW1CO0FBQzVDO0FBQ0E7QUFDQSxxQkFBcUIsNENBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEksbURBQW1ELGtCQUFrQjtBQUNyRSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsQ0FBQywyQ0FBYztBQUNsRCxZQUFZLGdEQUFtQixVQUFVLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0EsK0NBQStDLGdEQUFtQjtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixpTUFBaU07QUFDMU4sc0JBQXNCLHlDQUFZO0FBQ2xDLGtDQUFrQywyQ0FBYztBQUNoRCxzQ0FBc0MsMkNBQWM7QUFDcEQsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlILG9CQUFvQixrQkFBa0IsMEJBQTBCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsMEJBQTBCLHlDQUFZO0FBQ3RDLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiOztBQUVBLDhCQUE4QixnREFBbUI7QUFDakQ7QUFDQSxVQUFVLHVEQUF1RDtBQUNqRSxZQUFZLHNCQUFzQjtBQUNsQyxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBVTs7QUFFakM7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBLGtCQUFrQixtS0FBbUs7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw4QkFBOEIsTUFBTSx3Q0FBd0M7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IseUNBQVk7QUFDbEMsa0NBQWtDLDJDQUFjO0FBQ2hELHNDQUFzQywyQ0FBYztBQUNwRCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQiwwQ0FBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEIseUNBQVk7QUFDdEMsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsZ0RBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RiwyQkFBMkIsTUFBTSxtQkFBbUI7QUFDNUk7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsZ0RBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsZ0RBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixnREFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQSxvR0FBb0csMkJBQTJCLE1BQU0sbUJBQW1CO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLENBQUMsMkNBQWM7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixnREFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSwyQkFBMkIsK0JBQStCLElBQUksbUJBQW1CLE1BQU0sK0JBQStCO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFrQjtBQUN6QyxxQkFBcUIsaURBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBa0IsaUJBQWlCLHFCQUFxQjtBQUMvRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHdDQUF3QyxzQkFBc0Isc0JBQXNCO0FBQ3BGLGlEQUFpRCw4QkFBOEI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUMsZ0RBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0MscUNBQXFDO0FBQ3JDLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsZ0RBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBbUIsVUFBVSxtRUFBbUUsRUFBRSxnREFBbUI7QUFDcEk7QUFDQTtBQUNBOztBQUV5akI7QUFDempCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtZ29vZ2xlLW1hcHMvYXBpL2Rpc3QvZXNtLmpzPzg1MjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgUHVyZUNvbXBvbmVudCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBOT0RFX0VOViA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG52YXIgaW52YXJpYW50XzEgPSBpbnZhcmlhbnQ7XG5cbmNvbnN0IE1hcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlR29vZ2xlTWFwKCkge1xuICAgIGludmFyaWFudF8xKCEhdXNlQ29udGV4dCwgJ3VzZUdvb2dsZU1hcCBpcyBSZWFjdCBob29rIGFuZCByZXF1aXJlcyBSZWFjdCB2ZXJzaW9uIDE2LjgrJyk7XG4gICAgY29uc3QgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICBpbnZhcmlhbnRfMSghIW1hcCwgJ3VzZUdvb2dsZU1hcCBuZWVkcyBhIEdvb2dsZU1hcCBhdmFpbGFibGUgdXAgaW4gdGhlIHRyZWUnKTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgcmVkdWNlID0gKG9iaiwgZm4sIGFjYykgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiByZWR1Y2VyKG5ld0FjYywga2V5KSB7XG4gICAgICAgIHJldHVybiBmbihuZXdBY2MsIG9ialtrZXldLCBrZXkpO1xuICAgIH0sIGFjYyk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIGl0ZXJhdG9yKGtleSkge1xuICAgICAgICByZXR1cm4gZm4ob2JqW2tleV0sIGtleSk7XG4gICAgfSk7XG59XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbmNvbnN0IGFwcGx5VXBkYXRlclRvTmV4dFByb3BzID0gKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnVwZGF0ZXJNYXAsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByZXZQcm9wcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubmV4dFByb3BzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5pbnN0YW5jZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBpdGVyID0gKGZuLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZQcm9wc1trZXldKSB7XG4gICAgICAgICAgICBtYXBba2V5XSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGZuKGluc3RhbmNlLCBuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JFYWNoKHVwZGF0ZXJNYXAsIGl0ZXIpO1xuICAgIHJldHVybiBtYXA7XG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucHJvcHMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmluc3RhbmNlLCBldmVudE1hcCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRMaXN0ID0gcmVkdWNlKGV2ZW50TWFwLCBmdW5jdGlvbiByZWR1Y2VyKGFjYywgZ29vZ2xlRXZlbnROYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uRXZlbnROYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHNbb25FdmVudE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY2MucHVzaChnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZ29vZ2xlRXZlbnROYW1lLCBwcm9wc1tvbkV2ZW50TmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZExpc3Q7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnQocmVnaXN0ZXJlZCkge1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlZ2lzdGVyZWQpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50cyhldmVudHMgPSBbXSkge1xuICAgIGV2ZW50cy5mb3JFYWNoKHVucmVnaXN0ZXJFdmVudCk7XG59XG5mdW5jdGlvbiBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHsgdXBkYXRlck1hcCwgZXZlbnRNYXAsIHByZXZQcm9wcywgbmV4dFByb3BzLCBpbnN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRFdmVudHMgPSByZWdpc3RlckV2ZW50cyhuZXh0UHJvcHMsIGluc3RhbmNlLCBldmVudE1hcCk7XG4gICAgYXBwbHlVcGRhdGVyVG9OZXh0UHJvcHModXBkYXRlck1hcCwgcHJldlByb3BzLCBuZXh0UHJvcHMsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZEV2ZW50cztcbn1cblxuY29uc3QgZXZlbnRNYXAkaSA9IHtcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICAgIG9uQm91bmRzQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICBvbkNlbnRlckNoYW5nZWQ6ICdjZW50ZXJfY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkhlYWRpbmdDaGFuZ2VkOiAnaGVhZGluZ19jaGFuZ2VkJyxcbiAgICBvbklkbGU6ICdpZGxlJyxcbiAgICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJlc2l6ZTogJ3Jlc2l6ZScsXG4gICAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gICAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCcsXG59O1xuY29uc3QgdXBkYXRlck1hcCRpID0ge1xuICAgIGV4dHJhTWFwVHlwZXMobWFwLCBleHRyYSkge1xuICAgICAgICBleHRyYS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hFeHRyYShpdCwgaSkge1xuICAgICAgICAgICAgbWFwLm1hcFR5cGVzLnNldChTdHJpbmcoaSksIGl0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjZW50ZXIobWFwLCBjZW50ZXIpIHtcbiAgICAgICAgbWFwLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH0sXG4gICAgY2xpY2thYmxlSWNvbnMobWFwLCBjbGlja2FibGUpIHtcbiAgICAgICAgbWFwLnNldENsaWNrYWJsZUljb25zKGNsaWNrYWJsZSk7XG4gICAgfSxcbiAgICBoZWFkaW5nKG1hcCwgaGVhZGluZykge1xuICAgICAgICBtYXAuc2V0SGVhZGluZyhoZWFkaW5nKTtcbiAgICB9LFxuICAgIG1hcFR5cGVJZChtYXAsIG1hcFR5cGVJZCkge1xuICAgICAgICBtYXAuc2V0TWFwVHlwZUlkKG1hcFR5cGVJZCk7XG4gICAgfSxcbiAgICBvcHRpb25zKG1hcCwgb3B0aW9ucykge1xuICAgICAgICBtYXAuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHN0cmVldFZpZXcobWFwLCBzdHJlZXRWaWV3KSB7XG4gICAgICAgIG1hcC5zZXRTdHJlZXRWaWV3KHN0cmVldFZpZXcpO1xuICAgIH0sXG4gICAgdGlsdChtYXAsIHRpbHQpIHtcbiAgICAgICAgbWFwLnNldFRpbHQodGlsdCk7XG4gICAgfSxcbiAgICB6b29tKG1hcCwgem9vbSkge1xuICAgICAgICBtYXAuc2V0Wm9vbSh6b29tKTtcbiAgICB9LFxufTtcbi8vIGZ1bmN0aW9uIEdvb2dsZU1hcEZ1bmN0aW9uYWwoeyBjaGlsZHJlbiwgb3B0aW9ucywgaWQsIG1hcENvbnRhaW5lclN0eWxlLCBjZW50ZXIsIGNsaWNrYWJsZUljb25zLCBleHRyYU1hcFR5cGVzLCBoZWFkaW5nLCBtYXBDb250YWluZXJDbGFzc05hbWUsIG1hcFR5cGVJZCwgb25Cb3VuZHNDaGFuZ2VkLCBvbkNlbnRlckNoYW5nZWQsIG9uQ2xpY2ssIG9uRGJsQ2xpY2ssIG9uRHJhZywgb25EcmFnRW5kLCBvbkRyYWdTdGFydCwgb25IZWFkaW5nQ2hhbmdlZCwgb25JZGxlLCBvblByb2plY3Rpb25DaGFuZ2VkLCBvblJlc2l6ZSwgb25UaWx0Q2hhbmdlZCwgb25Mb2FkIH06IEdvb2dsZU1hcFByb3BzKTogSlNYLkVsZW1lbnQge1xuLy8gICBjb25zdCBbbWFwLCBzZXRNYXBdID0gUmVhY3QudXNlU3RhdGU8Z29vZ2xlLm1hcHMuTWFwIHwgbnVsbD4obnVsbClcbi8vICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbClcbi8vICAgY29uc3QgZ2V0SW5zdGFuY2UgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4vLyAgICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4vLyAgICAgICByZXR1cm4gbnVsbFxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcChyZWYuY3VycmVudCwgb3B0aW9ucylcbi8vICAgfSwgW29wdGlvbnNdKVxuLy8gICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuLy8gICB9LCBbXSlcbi8vICAgY29uc3QgcGFuVG8gPSBSZWFjdC51c2VDYWxsYmFjaygobGF0TG5nOiBnb29nbGUubWFwcy5MYXRMbmcgfCBnb29nbGUubWFwcy5MYXRMbmdMaXRlcmFsKTogdm9pZCA9PiB7XG4vLyAgICAgY29uc3QgbWFwID0gZ2V0SW5zdGFuY2UoKVxuLy8gICAgIGlmIChtYXApIHtcbi8vICAgICAgIG1hcC5wYW5UbyhsYXRMbmcpXG4vLyAgICAgfVxuLy8gICB9LCBbXSlcbi8vICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbi8vICAgICBjb25zdCBtYXAgPSBnZXRJbnN0YW5jZSgpXG4vLyAgIH0sIFtdKVxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXZcbi8vICAgICAgICAgaWQ9e2lkfVxuLy8gICAgICAgICByZWY9e3JlZn1cbi8vICAgICAgICAgc3R5bGU9e21hcENvbnRhaW5lclN0eWxlfVxuLy8gICAgICAgICBjbGFzc05hbWU9e21hcENvbnRhaW5lckNsYXNzTmFtZX1cbi8vICAgICAgID5cbi8vICAgICAgICAgPE1hcENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e21hcH0+XG4vLyAgICAgICAgICAge21hcCAhPT0gbnVsbCA/IGNoaWxkcmVuIDogPD48Lz59XG4vLyAgICAgICAgIDwvTWFwQ29udGV4dC5Qcm92aWRlcj5cbi8vICAgICAgIDwvZGl2PlxuLy8gICApXG4vLyB9XG5jbGFzcyBHb29nbGVNYXAgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMubWFwUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZXRJbnN0YW5jZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcFJlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXAodGhpcy5tYXBSZWYsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFuVG8gPSAobGF0TG5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwLnBhblRvKGxhdExuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0TWFwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5tYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZWYgPSAocmVmKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hcFJlZiA9IHJlZjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGksXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkaSxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogbWFwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRNYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0TWFwQ2FsbGJhY2spO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRpLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRpLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUubWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IHRoaXMucHJvcHMuaWQsIHJlZjogdGhpcy5nZXRSZWYsIHN0eWxlOiB0aGlzLnByb3BzLm1hcENvbnRhaW5lclN0eWxlLCBjbGFzc05hbWU6IHRoaXMucHJvcHMubWFwQ29udGFpbmVyQ2xhc3NOYW1lIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuc3RhdGUubWFwIH0sIHRoaXMuc3RhdGUubWFwICE9PSBudWxsID8gdGhpcy5wcm9wcy5jaGlsZHJlbiA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpKSkpO1xuICAgIH1cbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdCQxKHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IGluamVjdFNjcmlwdCA9ICh7IHVybCwgaWQsIG5vbmNlIH0pID0+IHtcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdkb2N1bWVudCBpcyB1bmRlZmluZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBpbmplY3RTY3JpcHRDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGNvbnN0IHdpbmRvd1dpdGhHb29nbGVNYXAgPSB3aW5kb3c7XG4gICAgICAgIGlmIChleGlzdGluZ1NjcmlwdCkge1xuICAgICAgICAgICAgLy8gU2FtZSBzY3JpcHQgaWQvdXJsOiBrZWVwIHNhbWUgc2NyaXB0XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RhdGVBdHRyaWJ1dGUgPSBleGlzdGluZ1NjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1NjcmlwdC5zcmMgPT09IHVybCAmJiBkYXRhU3RhdGVBdHRyaWJ1dGUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVN0YXRlQXR0cmlidXRlID09PSAncmVhZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW5pdE1hcCA9IHdpbmRvd1dpdGhHb29nbGVNYXAuaW5pdE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFcnJvckNhbGxiYWNrID0gZXhpc3RpbmdTY3JpcHQub25lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93V2l0aEdvb2dsZU1hcC5pbml0TWFwID0gZnVuY3Rpb24gaW5pdE1hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluaXRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluaXRNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1NjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYW1lIHNjcmlwdCBpZCwgYnV0IGVpdGhlclxuICAgICAgICAgICAgLy8gMS4gcmVxdWVzdGVkIFVSTCBpcyBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIDIuIHNjcmlwdCBmYWlsZWQgdG8gbG9hZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdTY3JpcHQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHNjcmlwdC5pZCA9IGlkO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQubm9uY2UgPSBub25jZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdlcnJvcicpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvd1dpdGhHb29nbGVNYXAuaW5pdE1hcCA9IGZ1bmN0aW9uIG9ubG9hZCgpIHtcbiAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAncmVhZHknKTtcbiAgICAgICAgICAgIHJlc29sdmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignaW5qZWN0U2NyaXB0IGVycm9yOiAnLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG59O1xuXG5jb25zdCBpc1JvYm90b1N0eWxlID0gKGVsZW1lbnQpID0+IHtcbiAgICAvLyByb2JvdG8gZm9udCBkb3dubG9hZFxuICAgIGlmIChlbGVtZW50LmhyZWYgJiZcbiAgICAgICAgZWxlbWVudC5ocmVmLmluZGV4T2YoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG8nKSA9PT1cbiAgICAgICAgICAgIDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHJvYm90byBzdHlsZSBlbGVtZW50c1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0eWxlJyAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQucmVwbGFjZSgnXFxyXFxuJywgJycpLmluZGV4T2YoJy5nbS1zdHlsZScpID09PSAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gJyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyByb2JvdG8gc3R5bGUgZWxlbWVudHMgZm9yIG90aGVyIGJyb3dzZXJzXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MICYmXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoJ1xcclxcbicsICcnKS5pbmRleE9mKCcuZ20tc3R5bGUnKSA9PT0gMCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gd2hlbiBnb29nbGUgdHJpZXMgdG8gYWRkIGVtcHR5IHN0eWxlXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICFlbGVtZW50LnN0eWxlU2hlZXQgJiZcbiAgICAgICAgIWVsZW1lbnQuaW5uZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLy8gUHJldmVudGluZyB0aGUgR29vZ2xlIE1hcHMgbGlicmFyeSBmcm9tIGRvd25sb2FkaW5nIGFuIGV4dHJhIGZvbnRcbmNvbnN0IHByZXZlbnRHb29nbGVGb250cyA9ICgpID0+IHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGVzZSBtZXRob2RzIG9ubHkgZm9yIG9uZSBwYXJ0aWN1bGFyIGhlYWQgZWxlbWVudFxuICAgIC8vIGRlZmF1bHQgbWV0aG9kcyBmb3Igb3RoZXIgZWxlbWVudHMgYXJlIG5vdCBhZmZlY3RlZFxuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGNvbnN0IHRydWVJbnNlcnRCZWZvcmUgPSBoZWFkLmluc2VydEJlZm9yZS5iaW5kKGhlYWQpO1xuICAgIC8vIFRPRE86IGFkZGluZyByZXR1cm4gYmVmb3JlIHJlZmxlY3Qgc29sdmVzIHRoZSBUUyBpc3N1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBoZWFkLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgIGlmICghaXNSb2JvdG9TdHlsZShuZXdFbGVtZW50KSkge1xuICAgICAgICAgICAgUmVmbGVjdC5hcHBseSh0cnVlSW5zZXJ0QmVmb3JlLCBoZWFkLCBbbmV3RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cnVlQXBwZW5kID0gaGVhZC5hcHBlbmRDaGlsZC5iaW5kKGhlYWQpO1xuICAgIC8vIFRPRE86IGFkZGluZyByZXR1cm4gYmVmb3JlIHJlZmxlY3Qgc29sdmVzIHRoZSBUUyBpc3N1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBoZWFkLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKCFpc1JvYm90b1N0eWxlKHRleHROb2RlKSkge1xuICAgICAgICAgICAgUmVmbGVjdC5hcHBseSh0cnVlQXBwZW5kLCBoZWFkLCBbdGV4dE5vZGVdKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBtYWtlTG9hZFNjcmlwdFVybCh7IGdvb2dsZU1hcHNBcGlLZXksIGdvb2dsZU1hcHNDbGllbnRJZCwgdmVyc2lvbiA9ICd3ZWVrbHknLCBsYW5ndWFnZSwgcmVnaW9uLCBsaWJyYXJpZXMsIGNoYW5uZWwsIG1hcElkcyB9KSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgaW52YXJpYW50XzEoKGdvb2dsZU1hcHNBcGlLZXkgJiYgZ29vZ2xlTWFwc0NsaWVudElkKSB8fCAhKGdvb2dsZU1hcHNBcGlLZXkgJiYgZ29vZ2xlTWFwc0NsaWVudElkKSwgJ1lvdSBuZWVkIHRvIHNwZWNpZnkgZWl0aGVyIGdvb2dsZU1hcHNBcGlLZXkgb3IgZ29vZ2xlTWFwc0NsaWVudElkIGZvciBAcmVhY3QtZ29vZ2xlLW1hcHMvYXBpIGxvYWQgc2NyaXB0IHRvIHdvcmsuIFlvdSBjYW5ub3QgdXNlIGJvdGggYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICBpZiAoZ29vZ2xlTWFwc0FwaUtleSkge1xuICAgICAgICBwYXJhbXMucHVzaChga2V5PSR7Z29vZ2xlTWFwc0FwaUtleX1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ29vZ2xlTWFwc0NsaWVudElkKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGBjbGllbnQ9JHtnb29nbGVNYXBzQ2xpZW50SWR9YCk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGB2PSR7dmVyc2lvbn1gKTtcbiAgICB9XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGBsYW5ndWFnZT0ke2xhbmd1YWdlfWApO1xuICAgIH1cbiAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGByZWdpb249JHtyZWdpb259YCk7XG4gICAgfVxuICAgIGlmIChsaWJyYXJpZXMgJiYgbGlicmFyaWVzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMucHVzaChgbGlicmFyaWVzPSR7bGlicmFyaWVzLnNvcnQoKS5qb2luKCcsJyl9YCk7XG4gICAgfVxuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGBjaGFubmVsPSR7Y2hhbm5lbH1gKTtcbiAgICB9XG4gICAgaWYgKG1hcElkcyAmJiBtYXBJZHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGBtYXBfaWRzPSR7bWFwSWRzLmpvaW4oJywnKX1gKTtcbiAgICB9XG4gICAgcGFyYW1zLnB1c2goJ2NhbGxiYWNrPWluaXRNYXAnKTtcbiAgICByZXR1cm4gYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz8ke3BhcmFtcy5qb2luKCcmJyl9YDtcbn1cblxubGV0IGNsZWFuaW5nVXAgPSBmYWxzZTtcbmZ1bmN0aW9uIERlZmF1bHRMb2FkaW5nRWxlbWVudCgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBgTG9hZGluZy4uLmApO1xufVxuY29uc3QgZGVmYXVsdExvYWRTY3JpcHRQcm9wcyA9IHtcbiAgICBpZDogJ3NjcmlwdC1sb2FkZXInLFxuICAgIHZlcnNpb246ICd3ZWVrbHknLFxufTtcbmNsYXNzIExvYWRTY3JpcHQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGVjayA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkZWxldGUgd2luZG93Lmdvb2dsZS5tYXBzO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RTY3JpcHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0NsZWFuaW5nVXAgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbGJhY2socmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghY2xlYW5pbmdVcCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiBpbnRlcnZhbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsZWFuaW5nVXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHByb21pc2VDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbmluZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMucHJvcHMuaWQpO1xuICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzY3JpcHQuc3JjID09PSAnc3RyaW5nJyAmJiBzY3JpcHQuc3JjLmluY2x1ZGVzKCdtYXBzLmdvb2dsZWFwaXMnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgICAgIC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIobGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobGluay5ocmVmID09PSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bzozMDAsNDAwLDUwMCw3MDB8R29vZ2xlK1NhbnMnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChsaW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlcihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc3R5bGUuaW5uZXJUZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5uZXJUZXh0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5uZXJUZXh0LmluY2x1ZGVzKCcuZ20tJykpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5qZWN0U2NyaXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMucHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIHByZXZlbnRHb29nbGVGb250cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW52YXJpYW50XzEoISF0aGlzLnByb3BzLmlkLCAnTG9hZFNjcmlwdCByZXF1aXJlcyBcImlkXCIgcHJvcCB0byBiZSBhIHN0cmluZzogJXMnLCB0aGlzLnByb3BzLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGluamVjdFNjcmlwdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvcHMubm9uY2UsXG4gICAgICAgICAgICAgICAgdXJsOiBtYWtlTG9hZFNjcmlwdFVybCh0aGlzLnByb3BzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbmplY3RTY3JpcHQoaW5qZWN0U2NyaXB0T3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG9hZGVkKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgXG4gICAgICAgICAgVGhlcmUgaGFzIGJlZW4gYW4gRXJyb3Igd2l0aCBsb2FkaW5nIEdvb2dsZSBNYXBzIEFQSSBzY3JpcHQsIHBsZWFzZSBjaGVjayB0aGF0IHlvdSBwcm92aWRlZCBjb3JyZWN0IGdvb2dsZSBBUEkga2V5ICgke3RoaXNcbiAgICAgICAgICAgICAgICAgICAgLnByb3BzLmdvb2dsZU1hcHNBcGlLZXkgfHwgJy0nfSkgb3IgQ2xpZW50IElEICgke3RoaXMucHJvcHMuZ29vZ2xlTWFwc0NsaWVudElkIHx8XG4gICAgICAgICAgICAgICAgICAgICctJ30pIHRvIDxMb2FkU2NyaXB0IC8+XG4gICAgICAgICAgT3RoZXJ3aXNlIGl0IGlzIGEgTmV0d29yayBpc3N1ZS5cbiAgICAgICAgYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcyAmJiAhY2xlYW5pbmdVcCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dvb2dsZSBhcGkgaXMgYWxyZWFkeSBwcmVzZW50ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzQ2xlYW5pbmdVcCgpXG4gICAgICAgICAgICAgICAgLnRoZW4odGhpcy5pbmplY3RTY3JpcHQpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF0IGluamVjdGluZyBzY3JpcHQgYWZ0ZXIgY2xlYW5pbmcgdXA6ICcsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmxpYnJhcmllcyAhPT0gcHJldlByb3BzLmxpYnJhcmllcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQZXJmb3JtYW5jZSB3YXJuaW5nISBMb2FkU2NyaXB0IGhhcyBiZWVuIHJlbG9hZGVkIHVuaW50ZW50aW9uYWxseSEgWW91IHNob3VsZCBub3QgcGFzcyBgbGlicmFyaWVzYCBwcm9wIGFzIG5ldyBhcnJheS4gUGxlYXNlIGtlZXAgYW4gYXJyYXkgb2YgbGlicmFyaWVzIGFzIHN0YXRpYyBjbGFzcyBwcm9wZXJ0eSBmb3IgQ29tcG9uZW50cyBhbmQgUHVyZUNvbXBvbmVudHMsIG9yIGp1c3QgYSBjb25zdCB2YXJpYWJsZSBvdXRzaWRlIG9mIGNvbXBvbmVudCwgb3Igc29tZXdoZXJlIGluIGNvbmZpZyBmaWxlcyBvciBFTlYgdmFyaWFibGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnJvd3NlciAmJiBwcmV2UHJvcHMubGFuZ3VhZ2UgIT09IHRoaXMucHJvcHMubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gdXNlIGdEU0ZQIG1heWJlLi4uIHdhaXQgZm9yIGhvb2tzIHJlZmFjdG9yaW5nLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWRpZC11cGRhdGUtc2V0LXN0YXRlXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldExvYWRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzLmNsZWFudXBDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVjay5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5nb29nbGU7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuaW5nVXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNoZWNrIH0pLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sb2FkZWRcbiAgICAgICAgICAgICAgICA/IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMubG9hZGluZ0VsZW1lbnQgfHwgUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0TG9hZGluZ0VsZW1lbnQsIG51bGwpKSk7XG4gICAgfVxufVxuTG9hZFNjcmlwdC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0TG9hZFNjcmlwdFByb3BzO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtcmVnZXggKi9cbmxldCBwcmV2aW91c2x5TG9hZGVkVXJsO1xuZnVuY3Rpb24gdXNlTG9hZFNjcmlwdCh7IGlkID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy5pZCwgdmVyc2lvbiA9IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMudmVyc2lvbiwgbm9uY2UsIGdvb2dsZU1hcHNBcGlLZXksIGdvb2dsZU1hcHNDbGllbnRJZCwgbGFuZ3VhZ2UsIHJlZ2lvbiwgbGlicmFyaWVzLCBwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nLCBjaGFubmVsLCBtYXBJZHMsIH0pIHtcbiAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0xvYWRlZCwgc2V0TG9hZGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbG9hZEVycm9yLCBzZXRMb2FkRXJyb3JdID0gUmVhY3QudXNlU3RhdGUodW5kZWZpbmVkKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gdHJhY2tNb3VudGVkU3RhdGUoKSB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiBhcHBseVByZXZlbnRHb29nbGVGb250cygpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlciAmJiBwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nKSB7XG4gICAgICAgICAgICBwcmV2ZW50R29vZ2xlRm9udHMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIHZhbGlkYXRlTG9hZGVkU3RhdGUoKSB7XG4gICAgICAgIGlmIChpc0xvYWRlZCkge1xuICAgICAgICAgICAgaW52YXJpYW50XzEoISF3aW5kb3cuZ29vZ2xlLCAndXNlTG9hZFNjcmlwdCB3YXMgbWFya2VkIGFzIGxvYWRlZCwgYnV0IHdpbmRvdy5nb29nbGUgaXMgbm90IHByZXNlbnQuIFNvbWV0aGluZyB3ZW50IHdyb25nLicpO1xuICAgICAgICB9XG4gICAgfSwgW2lzTG9hZGVkXSk7XG4gICAgY29uc3QgdXJsID0gbWFrZUxvYWRTY3JpcHRVcmwoe1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBnb29nbGVNYXBzQXBpS2V5LFxuICAgICAgICBnb29nbGVNYXBzQ2xpZW50SWQsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICByZWdpb24sXG4gICAgICAgIGxpYnJhcmllcyxcbiAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgbWFwSWRzXG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIGxvYWRTY3JpcHRBbmRNb2RpZnlMb2FkZWRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRMb2FkZWRJZk1vdW50ZWQoKSB7XG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNseUxvYWRlZFVybCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgcHJldmlvdXNseUxvYWRlZFVybCA9PT0gdXJsKSB7XG4gICAgICAgICAgICBzZXRMb2FkZWRJZk1vdW50ZWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbmplY3RTY3JpcHQoeyBpZCwgdXJsLCBub25jZSB9KVxuICAgICAgICAgICAgLnRoZW4oc2V0TG9hZGVkSWZNb3VudGVkKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIGhhbmRsZUluamVjdEVycm9yKGVycikge1xuICAgICAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZEVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFxuICAgICAgICBUaGVyZSBoYXMgYmVlbiBhbiBFcnJvciB3aXRoIGxvYWRpbmcgR29vZ2xlIE1hcHMgQVBJIHNjcmlwdCwgcGxlYXNlIGNoZWNrIHRoYXQgeW91IHByb3ZpZGVkIGNvcnJlY3QgZ29vZ2xlIEFQSSBrZXkgKCR7Z29vZ2xlTWFwc0FwaUtleSB8fFxuICAgICAgICAgICAgICAgICctJ30pIG9yIENsaWVudCBJRCAoJHtnb29nbGVNYXBzQ2xpZW50SWQgfHwgJy0nfSlcbiAgICAgICAgT3RoZXJ3aXNlIGl0IGlzIGEgTmV0d29yayBpc3N1ZS5cbiAgICAgIGApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBbaWQsIHVybCwgbm9uY2VdKTtcbiAgICBjb25zdCBwcmV2TGlicmFyaWVzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIGNoZWNrUGVyZm9ybWFuY2UoKSB7XG4gICAgICAgIGlmIChwcmV2TGlicmFyaWVzLmN1cnJlbnQgJiYgbGlicmFyaWVzICE9PSBwcmV2TGlicmFyaWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGVyZm9ybWFuY2Ugd2FybmluZyEgTG9hZFNjcmlwdCBoYXMgYmVlbiByZWxvYWRlZCB1bmludGVudGlvbmFsbHkhIFlvdSBzaG91bGQgbm90IHBhc3MgYGxpYnJhcmllc2AgcHJvcCBhcyBuZXcgYXJyYXkuIFBsZWFzZSBrZWVwIGFuIGFycmF5IG9mIGxpYnJhcmllcyBhcyBzdGF0aWMgY2xhc3MgcHJvcGVydHkgZm9yIENvbXBvbmVudHMgYW5kIFB1cmVDb21wb25lbnRzLCBvciBqdXN0IGEgY29uc3QgdmFyaWFibGUgb3V0c2lkZSBvZiBjb21wb25lbnQsIG9yIHNvbWV3aGVyZSBpbiBjb25maWcgZmlsZXMgb3IgRU5WIHZhcmlhYmxlcycpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZMaWJyYXJpZXMuY3VycmVudCA9IGxpYnJhcmllcztcbiAgICB9LCBbbGlicmFyaWVzXSk7XG4gICAgcmV0dXJuIHsgaXNMb2FkZWQsIGxvYWRFcnJvciwgdXJsIH07XG59XG5cbmNvbnN0IGRlZmF1bHRMb2FkaW5nRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdExvYWRpbmdFbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIExvYWRTY3JpcHROZXh0KF9hKSB7XG4gICAgdmFyIHsgbG9hZGluZ0VsZW1lbnQsIG9uTG9hZCwgb25FcnJvciwgb25Vbm1vdW50LCBjaGlsZHJlbiB9ID0gX2EsIGhvb2tPcHRpb25zID0gX19yZXN0JDEoX2EsIFtcImxvYWRpbmdFbGVtZW50XCIsIFwib25Mb2FkXCIsIFwib25FcnJvclwiLCBcIm9uVW5tb3VudFwiLCBcImNoaWxkcmVuXCJdKTtcbiAgICBjb25zdCB7IGlzTG9hZGVkLCBsb2FkRXJyb3IgfSA9IHVzZUxvYWRTY3JpcHQoaG9va09wdGlvbnMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiBoYW5kbGVPbkxvYWQoKSB7XG4gICAgICAgIGlmIChpc0xvYWRlZCAmJiB0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0xvYWRlZCwgb25Mb2FkXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIGhhbmRsZU9uRXJyb3IoKSB7XG4gICAgICAgIGlmIChsb2FkRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uRXJyb3IobG9hZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtsb2FkRXJyb3IsIG9uRXJyb3JdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gaGFuZGxlT25Vbm1vdW50KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtvblVubW91bnRdKTtcbiAgICByZXR1cm4gaXNMb2FkZWQgPyBjaGlsZHJlbiA6IGxvYWRpbmdFbGVtZW50IHx8IGRlZmF1bHRMb2FkaW5nRWxlbWVudDtcbn1cbnZhciBMb2FkU2NyaXB0TmV4dCQxID0gUmVhY3QubWVtbyhMb2FkU2NyaXB0TmV4dCk7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0LlxyXG4gKlxyXG4gKiAgICAgIEh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5cclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JRCA9IFwiX19nb29nbGVNYXBzU2NyaXB0SWRcIjtcclxuLyoqXHJcbiAqIFtbTG9hZGVyXV0gbWFrZXMgaXQgZWFzaWVyIHRvIGFkZCBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSB0byB5b3VyIGFwcGxpY2F0aW9uXHJcbiAqIGR5bmFtaWNhbGx5IHVzaW5nXHJcbiAqIFtQcm9taXNlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZSkuXHJcbiAqIEl0IHdvcmtzIGJ5IGR5bmFtaWNhbGx5IGNyZWF0aW5nIGFuZCBhcHBlbmRpbmcgYSBzY3JpcHQgbm9kZSB0byB0aGUgdGhlXHJcbiAqIGRvY3VtZW50IGhlYWQgYW5kIHdyYXBwaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBzbyBhcyB0byByZXR1cm4gYSBwcm9taXNlLlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgbG9hZGVyID0gbmV3IExvYWRlcih7XHJcbiAqICAgYXBpS2V5OiBcIlwiLFxyXG4gKiAgIHZlcnNpb246IFwid2Vla2x5XCIsXHJcbiAqICAgbGlicmFyaWVzOiBbXCJwbGFjZXNcIl1cclxuICogfSk7XHJcbiAqXHJcbiAqIGxvYWRlci5sb2FkKCkudGhlbigoZ29vZ2xlKSA9PiB7XHJcbiAqICAgY29uc3QgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcCguLi4pXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgTG9hZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMb2FkZXIgdXNpbmcgW1tMb2FkZXJPcHRpb25zXV0uIE5vIGRlZmF1bHRzIGFyZSBzZXRcclxuICAgICAqIHVzaW5nIHRoaXMgbGlicmFyeSwgaW5zdGVhZCB0aGUgZGVmYXVsdHMgYXJlIHNldCBieSB0aGUgR29vZ2xlIE1hcHNcclxuICAgICAqIEphdmFTY3JpcHQgQVBJIHNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIGNvbnN0IGxvYWRlciA9IExvYWRlcih7YXBpS2V5LCB2ZXJzaW9uOiAnd2Vla2x5JywgbGlicmFyaWVzOiBbJ3BsYWNlcyddfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeyBhcGlLZXksIGNoYW5uZWwsIGNsaWVudCwgaWQgPSBERUZBVUxUX0lELCBsaWJyYXJpZXMgPSBbXSwgbGFuZ3VhZ2UsIHJlZ2lvbiwgdmVyc2lvbiwgbWFwSWRzLCBub25jZSwgcmV0cmllcyA9IDMsIHVybCA9IFwiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzXCIsIH0pIHtcclxuICAgICAgICB0aGlzLkNBTExCQUNLID0gXCJfX2dvb2dsZU1hcHNDYWxsYmFja1wiO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkIHx8IERFRkFVTFRfSUQ7IC8vIERvIG5vdCBhbGxvdyBlbXB0eSBzdHJpbmdcclxuICAgICAgICB0aGlzLmxpYnJhcmllcyA9IGxpYnJhcmllcztcclxuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XHJcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgdGhpcy5tYXBJZHMgPSBtYXBJZHM7XHJcbiAgICAgICAgdGhpcy5ub25jZSA9IG5vbmNlO1xyXG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XHJcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgaWYgKExvYWRlci5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIWZhc3REZWVwRXF1YWwodGhpcy5vcHRpb25zLCBMb2FkZXIuaW5zdGFuY2Uub3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9hZGVyIG11c3Qgbm90IGJlIGNhbGxlZCBhZ2FpbiB3aXRoIGRpZmZlcmVudCBvcHRpb25zLiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9ICE9PSAke0pTT04uc3RyaW5naWZ5KExvYWRlci5pbnN0YW5jZS5vcHRpb25zKX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyLmluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBMb2FkZXIuaW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxyXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWwsXHJcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXHJcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxyXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMubGlicmFyaWVzLFxyXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcclxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcclxuICAgICAgICAgICAgbWFwSWRzOiB0aGlzLm1hcElkcyxcclxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXHJcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldCBmYWlsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSAmJiAhdGhpcy5sb2FkaW5nICYmIHRoaXMuZXJyb3JzLmxlbmd0aCA+PSB0aGlzLnJldHJpZXMgKyAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVVcmwgcmV0dXJucyB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgc2NyaXB0IHVybCBnaXZlbiB0aGUgW1tMb2FkZXJPcHRpb25zXV0uXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVVcmwoKSB7XHJcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsO1xyXG4gICAgICAgIHVybCArPSBgP2NhbGxiYWNrPSR7dGhpcy5DQUxMQkFDS31gO1xyXG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xyXG4gICAgICAgICAgICB1cmwgKz0gYCZrZXk9JHt0aGlzLmFwaUtleX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHVybCArPSBgJmNoYW5uZWw9JHt0aGlzLmNoYW5uZWx9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50KSB7XHJcbiAgICAgICAgICAgIHVybCArPSBgJmNsaWVudD0ke3RoaXMuY2xpZW50fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxpYnJhcmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHVybCArPSBgJmxpYnJhcmllcz0ke3RoaXMubGlicmFyaWVzLmpvaW4oXCIsXCIpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgIHVybCArPSBgJmxhbmd1YWdlPSR7dGhpcy5sYW5ndWFnZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZWdpb24pIHtcclxuICAgICAgICAgICAgdXJsICs9IGAmcmVnaW9uPSR7dGhpcy5yZWdpb259YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbikge1xyXG4gICAgICAgICAgICB1cmwgKz0gYCZ2PSR7dGhpcy52ZXJzaW9ufWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1hcElkcykge1xyXG4gICAgICAgICAgICB1cmwgKz0gYCZtYXBfaWRzPSR7dGhpcy5tYXBJZHMuam9pbihcIixcIil9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuICAgIGRlbGV0ZVNjcmlwdCgpIHtcclxuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcclxuICAgICAgICBpZiAoc2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkUHJvbWlzZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgYW5kIHJldHVybiBhIFByb21pc2UuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBsb2FkUHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRDYWxsYmFjaygoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93Lmdvb2dsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyLmVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCB3aXRoIGEgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIGxvYWRDYWxsYmFjayhmbikge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goZm4pO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNjcmlwdCBvbiBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgc2V0U2NyaXB0KCkge1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHdyYXAgb25lcnJvciBjYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlIHNjcmlwdCB3YXMgbG9hZGVkIGVsc2V3aGVyZVxyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jcmVhdGVVcmwoKTtcclxuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgIHNjcmlwdC5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XHJcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLmxvYWRFcnJvckNhbGxiYWNrLmJpbmQodGhpcyk7XHJcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcclxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLm5vbmNlKSB7XHJcbiAgICAgICAgICAgIHNjcmlwdC5ub25jZSA9IHRoaXMubm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGxvYWRlciBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVTY3JpcHQoKTtcclxuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25lcnJvckV2ZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJlc2V0SWZSZXRyeWluZ0ZhaWxlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5mYWlsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvYWRFcnJvckNhbGxiYWNrKGUpIHtcclxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPD0gdGhpcy5yZXRyaWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5lcnJvcnMubGVuZ3RoICogTWF0aC5wb3coMiwgdGhpcy5lcnJvcnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBsb2FkIEdvb2dsZSBNYXBzIHNjcmlwdCwgcmV0cnlpbmcgaW4gJHtkZWxheX0gbXMuYCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVTY3JpcHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2NyaXB0KCk7XHJcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25lcnJvckV2ZW50ID0gZTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldENhbGxiYWNrKCkge1xyXG4gICAgICAgIHdpbmRvdy5fX2dvb2dsZU1hcHNDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2suYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKCkge1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IHtcclxuICAgICAgICAgICAgY2IodGhpcy5vbmVycm9yRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKCkge1xyXG4gICAgICAgIHRoaXMucmVzZXRJZlJldHJ5aW5nRmFpbGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzaG9ydCBjaXJjdWl0IGFuZCB3YXJuIGlmIGdvb2dsZS5tYXBzIGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcyAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMudmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiR29vZ2xlIE1hcHMgYWxyZWFkeSBsb2FkZWQgb3V0c2lkZSBAZ29vZ2xlbWFwcy9qcy1hcGktbG9hZGVyLlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgbWF5IHJlc3VsdCBpbiB1bmRlc2lyYWJsZSBiZWhhdmlvciBhcyBvcHRpb25zIGFuZCBzY3JpcHQgcGFyYW1ldGVycyBtYXkgbm90IG1hdGNoLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nKSA7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2NyaXB0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyogZXNsaW50LWRpc2FibGUgZmlsZW5hbWVzL21hdGNoLXJlZ2V4ICovXG5mdW5jdGlvbiB1c2VKc0FwaUxvYWRlcih7IGlkID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy5pZCwgdmVyc2lvbiA9IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMudmVyc2lvbiwgbm9uY2UsIGdvb2dsZU1hcHNBcGlLZXksIFxuLy8gZ29vZ2xlTWFwc0NsaWVudElkLFxubGFuZ3VhZ2UsIHJlZ2lvbiwgbGlicmFyaWVzLCBwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nLCBcbi8vIGNoYW5uZWwsXG5tYXBJZHMsIH0pIHtcbiAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0xvYWRlZCwgc2V0TG9hZGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbG9hZEVycm9yLCBzZXRMb2FkRXJyb3JdID0gUmVhY3QudXNlU3RhdGUodW5kZWZpbmVkKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gdHJhY2tNb3VudGVkU3RhdGUoKSB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGxvYWRlciA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gbWVtbygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2FkZXIoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhcGlLZXk6IGdvb2dsZU1hcHNBcGlLZXksXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgbGlicmFyaWVzLFxuICAgICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgICByZWdpb24sXG4gICAgICAgICAgICBtYXBJZHMsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2lkLCBnb29nbGVNYXBzQXBpS2V5LCB2ZXJzaW9uLCBsaWJyYXJpZXMsIGxhbmd1YWdlLCByZWdpb24sIG1hcElkcywgbm9uY2VdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gZWZmZWN0KCkge1xuICAgICAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCkudGhlbihmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgc2V0TG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gb25yZWplY3RlZChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNldExvYWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gYXBwbHlQcmV2ZW50R29vZ2xlRm9udHMoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZ10pO1xuICAgIGNvbnN0IHByZXZMaWJyYXJpZXMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gZWZmZWN0KCkge1xuICAgICAgICBpZiAocHJldkxpYnJhcmllcy5jdXJyZW50ICYmIGxpYnJhcmllcyAhPT0gcHJldkxpYnJhcmllcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIHdhcm5pbmchIExvYWRTY3JpcHQgaGFzIGJlZW4gcmVsb2FkZWQgdW5pbnRlbnRpb25hbGx5ISBZb3Ugc2hvdWxkIG5vdCBwYXNzIGBsaWJyYXJpZXNgIHByb3AgYXMgbmV3IGFycmF5LiBQbGVhc2Uga2VlcCBhbiBhcnJheSBvZiBsaWJyYXJpZXMgYXMgc3RhdGljIGNsYXNzIHByb3BlcnR5IGZvciBDb21wb25lbnRzIGFuZCBQdXJlQ29tcG9uZW50cywgb3IganVzdCBhIGNvbnN0IHZhcmlhYmxlIG91dHNpZGUgb2YgY29tcG9uZW50LCBvciBzb21ld2hlcmUgaW4gY29uZmlnIGZpbGVzIG9yIEVOViB2YXJpYWJsZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2TGlicmFyaWVzLmN1cnJlbnQgPSBsaWJyYXJpZXM7XG4gICAgfSwgW2xpYnJhcmllc10pO1xuICAgIHJldHVybiB7IGlzTG9hZGVkLCBsb2FkRXJyb3IgfTtcbn1cblxuY29uc3QgZXZlbnRNYXAkaCA9IHt9O1xuY29uc3QgdXBkYXRlck1hcCRoID0ge1xuICAgIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxufTtcbmNsYXNzIFRyYWZmaWNMYXllciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdHJhZmZpY0xheWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFRyYWZmaWNMYXllckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUudHJhZmZpY0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUudHJhZmZpY0xheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgdHJhZmZpY0xheWVyID0gbmV3IGdvb2dsZS5tYXBzLlRyYWZmaWNMYXllcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRoLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGgsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRyYWZmaWNMYXllcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0VHJhZmZpY0xheWVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFmZmljTGF5ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFRyYWZmaWNMYXllckNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkaCxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkaCxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnRyYWZmaWNMYXllcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnRyYWZmaWNMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhZmZpY0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblRyYWZmaWNMYXllci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmNsYXNzIEJpY3ljbGluZ0xheWVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBiaWN5Y2xpbmdMYXllcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRCaWN5Y2xpbmdMYXllckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBob3cgaXMgdGhpcyBwb3NzaWJseSBudWxsIGlmIHdlJ3JlIGRvaW5nIGEgbnVsbCBjaGVja1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyLnNldE1hcCh0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBiaWN5Y2xpbmdMYXllciA9IG5ldyBnb29nbGUubWFwcy5CaWN5Y2xpbmdMYXllcigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldEJpY3ljbGluZ0xheWVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiaWN5Y2xpbmdMYXllcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0QmljeWNsaW5nTGF5ZXJDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbkJpY3ljbGluZ0xheWVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcblxuY2xhc3MgVHJhbnNpdExheWVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0cmFuc2l0TGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VHJhbnNpdExheWVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBob3cgaXMgdGhpcyBwb3NzaWJseSBudWxsIGlmIHdlJ3JlIGRvaW5nIGEgbnVsbCBjaGVja1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnRyYW5zaXRMYXllci5zZXRNYXAodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRMYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFuc2l0TGF5ZXIoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRUcmFuc2l0TGF5ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRMYXllcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0VHJhbnNpdExheWVyQ2FsbGJhY2spO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudHJhbnNpdExheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnRyYW5zaXRMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5UcmFuc2l0TGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG4vKiBnbG9iYWxzIGdvb2dsZSAqL1xuY29uc3QgZXZlbnRNYXAkZyA9IHtcbiAgICBvbkNpcmNsZUNvbXBsZXRlOiAnY2lyY2xlY29tcGxldGUnLFxuICAgIG9uTWFya2VyQ29tcGxldGU6ICdtYXJrZXJjb21wbGV0ZScsXG4gICAgb25PdmVybGF5Q29tcGxldGU6ICdvdmVybGF5Y29tcGxldGUnLFxuICAgIG9uUG9seWdvbkNvbXBsZXRlOiAncG9seWdvbmNvbXBsZXRlJyxcbiAgICBvblBvbHlsaW5lQ29tcGxldGU6ICdwb2x5bGluZWNvbXBsZXRlJyxcbiAgICBvblJlY3RhbmdsZUNvbXBsZXRlOiAncmVjdGFuZ2xlY29tcGxldGUnLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkZyA9IHtcbiAgICBkcmF3aW5nTW9kZShpbnN0YW5jZSwgZHJhd2luZ01vZGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RHJhd2luZ01vZGUoZHJhd2luZ01vZGUpO1xuICAgIH0sXG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG59O1xuY2xhc3MgRHJhd2luZ01hbmFnZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJhd2luZ01hbmFnZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0RHJhd2luZ01hbmFnZXJDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGludmFyaWFudF8xKCEhZ29vZ2xlLm1hcHMuZHJhd2luZywgYERpZCB5b3UgaW5jbHVkZSBwcm9wIGxpYnJhcmllcz17WydkcmF3aW5nJ119IGluIHRoZSBVUkw/ICVzYCwgZ29vZ2xlLm1hcHMuZHJhd2luZyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBkcmF3aW5nTWFuYWdlciA9IG5ldyBnb29nbGUubWFwcy5kcmF3aW5nLkRyYXdpbmdNYW5hZ2VyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGcsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZyxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogZHJhd2luZ01hbmFnZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERyYXdpbmdNYW5hZ2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkcmF3aW5nTWFuYWdlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0RHJhd2luZ01hbmFnZXJDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xuICAgIH1cbn1cbkRyYXdpbmdNYW5hZ2VyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcblxuY29uc3QgZXZlbnRNYXAkZiA9IHtcbiAgICBvbkFuaW1hdGlvbkNoYW5nZWQ6ICdhbmltYXRpb25fY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkNsaWNrYWJsZUNoYW5nZWQ6ICdjbGlja2FibGVfY2hhbmdlZCcsXG4gICAgb25DdXJzb3JDaGFuZ2VkOiAnY3Vyc29yX2NoYW5nZWQnLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnZ2FibGVDaGFuZ2VkOiAnZHJhZ2dhYmxlX2NoYW5nZWQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbkZsYXRDaGFuZ2VkOiAnZmxhdF9jaGFuZ2VkJyxcbiAgICBvbkljb25DaGFuZ2VkOiAnaWNvbl9jaGFuZ2VkJyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgICBvblNoYXBlQ2hhbmdlZDogJ3NoYXBlX2NoYW5nZWQnLFxuICAgIG9uVGl0bGVDaGFuZ2VkOiAndGl0bGVfY2hhbmdlZCcsXG4gICAgb25WaXNpYmxlQ2hhbmdlZDogJ3Zpc2libGVfY2hhbmdlZCcsXG4gICAgb25aaW5kZXhDaGFuZ2VkOiAnemluZGV4X2NoYW5nZWQnLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkZiA9IHtcbiAgICBhbmltYXRpb24oaW5zdGFuY2UsIGFuaW1hdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICB9LFxuICAgIGNsaWNrYWJsZShpbnN0YW5jZSwgY2xpY2thYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldENsaWNrYWJsZShjbGlja2FibGUpO1xuICAgIH0sXG4gICAgY3Vyc29yKGluc3RhbmNlLCBjdXJzb3IpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfSxcbiAgICBkcmFnZ2FibGUoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGljb24oaW5zdGFuY2UsIGljb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SWNvbihpY29uKTtcbiAgICB9LFxuICAgIGxhYmVsKGluc3RhbmNlLCBsYWJlbCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRMYWJlbChsYWJlbCk7XG4gICAgfSxcbiAgICBtYXAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wYWNpdHkoaW5zdGFuY2UsIG9wYWNpdHkpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICB9LFxuICAgIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBzaGFwZShpbnN0YW5jZSwgc2hhcGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0U2hhcGUoc2hhcGUpO1xuICAgIH0sXG4gICAgdGl0bGUoaW5zdGFuY2UsIHRpdGxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRpdGxlKTtcbiAgICB9LFxuICAgIHZpc2libGUoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxuICAgIHpJbmRleChpbnN0YW5jZSwgekluZGV4KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFpJbmRleCh6SW5kZXgpO1xuICAgIH0sXG59O1xuY2xhc3MgTWFya2VyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgbWFya2VyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksICh0aGlzLnByb3BzLmNsdXN0ZXJlciA/IHt9IDogeyBtYXA6IHRoaXMuY29udGV4dCB9KSksIHsgcG9zaXRpb246IHRoaXMucHJvcHMucG9zaXRpb24gfSk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QganVzdCBkbyB0aGlzIGluIHRoZSBjb250c3RydWN0b3IsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGBNYXBDb250ZXh0YCBtaWdodCBub3QgYmUgZmlsbGVkIGluIHlldC5cbiAgICAgICAgdGhpcy5tYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jbHVzdGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2x1c3RlcmVyLmFkZE1hcmtlcih0aGlzLm1hcmtlciwgISF0aGlzLnByb3BzLm5vQ2x1c3RlcmVyUmVkcmF3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VyLnNldE1hcCh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRmLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGYsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMubWFya2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLm1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZixcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZixcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLm1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMubWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmNsdXN0ZXJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2x1c3RlcmVyLnJlbW92ZU1hcmtlcih0aGlzLm1hcmtlciwgISF0aGlzLnByb3BzLm5vQ2x1c3RlcmVyUmVkcmF3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyICYmIHRoaXMubWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50Q2hpbGQsIHsgYW5jaG9yOiB0aGlzLm1hcmtlciB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiB8fCBudWxsO1xuICAgIH1cbn1cbk1hcmtlci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbnZhciBDbHVzdGVySWNvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbHVzdGVySWNvbihjbHVzdGVyLCBzdHlsZXMpIHtcbiAgICAgICAgY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5leHRlbmQoQ2x1c3Rlckljb24sIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcbiAgICAgICAgdGhpcy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICAgICAgdGhpcy5jbHVzdGVyQ2xhc3NOYW1lID0gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmdldENsdXN0ZXJDbGFzcygpO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2x1c3RlckNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VtcyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMudXJsID0gJyc7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuYW5jaG9yVGV4dCA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5hbmNob3JJY29uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLnRleHRDb2xvciA9ICdibGFjayc7XG4gICAgICAgIHRoaXMudGV4dFNpemUgPSAxMTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbiA9ICdub25lJztcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9ICdub3JtYWwnO1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSAnQXJpYWwsc2Fucy1zZXJpZic7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFBvc2l0aW9uID0gJzAgMCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2V0TWFwKGNsdXN0ZXIuZ2V0TWFwKCkpOyAvLyBOb3RlOiB0aGlzIGNhdXNlcyBvbkFkZCB0byBiZSBjYWxsZWRcbiAgICB9XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY01vdXNlRG93bkluQ2x1c3RlcjtcbiAgICAgICAgdmFyIGNEcmFnZ2luZ01hcEJ5Q2x1c3RlcjtcbiAgICAgICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZ2V0UGFuZXMoKS5vdmVybGF5TW91c2VUYXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5kaXYpO1xuICAgICAgICAvLyBGaXggZm9yIElzc3VlIDE1N1xuICAgICAgICB0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmdldE1hcCgpLCAnYm91bmRzY2hhbmdlZCcsIGZ1bmN0aW9uIGJvdW5kc0NoYW5nZWQoKSB7XG4gICAgICAgICAgICBjRHJhZ2dpbmdNYXBCeUNsdXN0ZXIgPSBjTW91c2VEb3duSW5DbHVzdGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXYsICdtb3VzZWRvd24nLCBmdW5jdGlvbiBvbk1vdXNlRG93bigpIHtcbiAgICAgICAgICAgIGNNb3VzZURvd25JbkNsdXN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzLCBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvbmFtZVxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdiwgJ2NsaWNrJywgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQGdldGlmeS9wcm9wZXItYXJyb3dzL3RoaXMsIEBnZXRpZnkvcHJvcGVyLWFycm93cy9uYW1lXG4gICAgICAgIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgY01vdXNlRG93bkluQ2x1c3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFjRHJhZ2dpbmdNYXBCeUNsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyQ2x1c3RlcmVyXzEgPSBfdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGNsdXN0ZXIgbWFya2VyIGlzIGNsaWNrZWQuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyI2NsaWNrXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICAgICAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXJrZXJDbHVzdGVyZXJfMSwgJ2NsaWNrJywgX3RoaXMuY2x1c3Rlcik7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXJrZXJDbHVzdGVyZXJfMSwgJ2NsdXN0ZXJjbGljaycsIF90aGlzLmNsdXN0ZXIpOyAvLyBkZXByZWNhdGVkIG5hbWVcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjbGljayBoYW5kbGVyIGZvbGxvd3MuIERpc2FibGUgaXQgYnkgc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSB6b29tT25DbGljayBwcm9wZXJ0eSB0byBmYWxzZS5cbiAgICAgICAgICAgICAgICBpZiAobWFya2VyQ2x1c3RlcmVyXzEuZ2V0Wm9vbU9uQ2xpY2soKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBab29tIGludG8gdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhab29tXzEgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXhab29tKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZHNfMSA9IF90aGlzLmNsdXN0ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNsdXN0ZXJlcl8xLmdldE1hcCgpLmZpdEJvdW5kcyhib3VuZHNfMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZml4IGZvciBJc3N1ZSAxNzAgaGVyZTpcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXAoKS5maXRCb3VuZHMoYm91bmRzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgem9vbSBiZXlvbmQgdGhlIG1heCB6b29tIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhab29tXzEgIT09IG51bGwgJiYgbWFya2VyQ2x1c3RlcmVyXzEuZ2V0TWFwKCkuZ2V0Wm9vbSgpID4gbWF4Wm9vbV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckNsdXN0ZXJlcl8xLmdldE1hcCgpLnNldFpvb20obWF4Wm9vbV8xICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZXZlbnQgcHJvcGFnYXRpb24gdG8gdGhlIG1hcDpcbiAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXYsICdtb3VzZW92ZXInLCBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvdGhpcywgQGdldGlmeS9wcm9wZXItYXJyb3dzL25hbWVcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBjbHVzdGVyIG1hcmtlci5cbiAgICAgICAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNtb3VzZW92ZXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q2x1c3Rlcn0gYyBUaGUgY2x1c3RlciB0aGF0IHRoZSBtb3VzZSBtb3ZlZCBvdmVyLlxuICAgICAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIoX3RoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKSwgJ21vdXNlb3ZlcicsIF90aGlzLmNsdXN0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvdGhpcywgQGdldGlmeS9wcm9wZXItYXJyb3dzL25hbWVcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXYsICdtb3VzZW91dCcsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzLCBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvbmFtZVxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgb3V0IG9mIGEgY2x1c3RlciBtYXJrZXIuXG4gICAgICAgICAgICAgKiBAbmFtZSBNYXJrZXJDbHVzdGVyZXIjbW91c2VvdXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q2x1c3Rlcn0gYyBUaGUgY2x1c3RlciB0aGF0IHRoZSBtb3VzZSBtb3ZlZCBvdXQgb2YuXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihfdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLCAnbW91c2VvdXQnLCBfdGhpcy5jbHVzdGVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnModGhpcy5kaXYpO1xuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlICYmIHRoaXMuZGl2ICE9PSBudWxsICYmIHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmcodGhpcy5jZW50ZXIpLCB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSAnJywgZGl2VGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIE5PVEU6IHZhbHVlcyBtdXN0IGJlIHNwZWNpZmllZCBpbiBweCB1bml0c1xuICAgICAgICAgICAgdmFyIGJwID0gdGhpcy5iYWNrZ3JvdW5kUG9zaXRpb24uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciBzcHJpdGVIID0gcGFyc2VJbnQoYnBbMF0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLCAxMCk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlViA9IHBhcnNlSW50KGJwWzFdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSwgMTApO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zRnJvbUxhdExuZyh0aGlzLmNlbnRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5zdW1zID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnN1bXMudGl0bGUgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc3Vtcy50aXRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBkaXZUaXRsZSA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5nZXRUaXRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGl2VGl0bGUgPSB0aGlzLnN1bXMudGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5jc3NUZXh0ID0gdGhpcy5jcmVhdGVDc3MocG9zKTtcbiAgICAgICAgICAgIGltZyA9XG4gICAgICAgICAgICAgICAgXCI8aW1nIGFsdD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZUaXRsZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBzcmM9J1wiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwgK1xuICAgICAgICAgICAgICAgICAgICBcIicgc3R5bGU9J3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZVYgK1xuICAgICAgICAgICAgICAgICAgICAncHg7IGxlZnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICBzcHJpdGVIICtcbiAgICAgICAgICAgICAgICAgICAgJ3B4OyAnO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmVuYWJsZVJldGluYUljb25zKSB7XG4gICAgICAgICAgICAgICAgaW1nICs9XG4gICAgICAgICAgICAgICAgICAgICdjbGlwOiByZWN0KCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgKiBzcHJpdGVWICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdweCwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoLTEgKiBzcHJpdGVIICsgdGhpcy53aWR0aCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgtMSAqIHNwcml0ZVYgKyB0aGlzLmhlaWdodCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xICogc3ByaXRlSCArXG4gICAgICAgICAgICAgICAgICAgICAgICAncHgpOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcgKz0gXCInPlwiO1xuICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBpbWcgK1xuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgc3R5bGU9J1wiICtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvcDogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yVGV4dFswXSArXG4gICAgICAgICAgICAgICAgICAgICdweDsnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclRleHRbMV0gK1xuICAgICAgICAgICAgICAgICAgICAncHg7JyArXG4gICAgICAgICAgICAgICAgICAgICdjb2xvcjogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbG9yICtcbiAgICAgICAgICAgICAgICAgICAgJzsnICtcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFNpemUgK1xuICAgICAgICAgICAgICAgICAgICAncHg7JyArXG4gICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9udEZhbWlseSArXG4gICAgICAgICAgICAgICAgICAgICc7JyArXG4gICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodDogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9udFdlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICc7JyArXG4gICAgICAgICAgICAgICAgICAgICdmb250LXN0eWxlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb250U3R5bGUgK1xuICAgICAgICAgICAgICAgICAgICAnOycgK1xuICAgICAgICAgICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uOiAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbiArXG4gICAgICAgICAgICAgICAgICAgICc7JyArXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFsaWduOiBjZW50ZXI7JyArXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aDogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAncHg7JyArXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodDonICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAncHg7JyArXG4gICAgICAgICAgICAgICAgICAgIFwiJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vtcy50ZXh0ICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgICAgICB0aGlzLmRpdi50aXRsZSA9IGRpdlRpdGxlO1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUudXNlU3R5bGUgPSBmdW5jdGlvbiAoc3Vtcykge1xuICAgICAgICB0aGlzLnN1bXMgPSBzdW1zO1xuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmdldFN0eWxlcygpO1xuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbTWF0aC5taW4oc3R5bGVzLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIHN1bXMuaW5kZXggLSAxKSldO1xuICAgICAgICB0aGlzLnVybCA9IHN0eWxlLnVybDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgaWYgKHN0eWxlLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbHVzdGVyQ2xhc3NOYW1lICsgXCIgXCIgKyBzdHlsZS5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYW5jaG9yVGV4dCA9IHN0eWxlLmFuY2hvclRleHQgfHwgWzAsIDBdO1xuICAgICAgICB0aGlzLmFuY2hvckljb24gPSBzdHlsZS5hbmNob3JJY29uIHx8IFt0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGggLyAyXTtcbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSBzdHlsZS50ZXh0Q29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgdGhpcy50ZXh0U2l6ZSA9IHN0eWxlLnRleHRTaXplIHx8IDExO1xuICAgICAgICB0aGlzLnRleHREZWNvcmF0aW9uID0gc3R5bGUudGV4dERlY29yYXRpb24gfHwgJ25vbmUnO1xuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0IHx8ICdib2xkJztcbiAgICAgICAgdGhpcy5mb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgfHwgJ25vcm1hbCc7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgfHwgJ0FyaWFsLHNhbnMtc2VyaWYnO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRQb3NpdGlvbiA9IHN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiB8fCAnMCAwJztcbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmNyZWF0ZUNzcyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gW107XG4gICAgICAgIHN0eWxlLnB1c2goJ2N1cnNvcjogcG9pbnRlcjsnKTtcbiAgICAgICAgc3R5bGUucHVzaCgncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBwb3MueSArICdweDsgbGVmdDogJyArIHBvcy54ICsgJ3B4OycpO1xuICAgICAgICBzdHlsZS5wdXNoKCd3aWR0aDogJyArIHRoaXMud2lkdGggKyAncHg7IGhlaWdodDogJyArIHRoaXMuaGVpZ2h0ICsgJ3B4OycpO1xuICAgICAgICByZXR1cm4gc3R5bGUuam9pbignJyk7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUuZ2V0UG9zRnJvbUxhdExuZyA9IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdGxuZyk7XG4gICAgICAgIHBvcy54IC09IHRoaXMuYW5jaG9ySWNvblsxXTtcbiAgICAgICAgcG9zLnkgLT0gdGhpcy5hbmNob3JJY29uWzBdO1xuICAgICAgICAvLyBwb3MueCA9IHBvcy54XG4gICAgICAgIC8vIHBvcy55ID0gcG9zLnlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIHJldHVybiBDbHVzdGVySWNvbjtcbn0oKSk7XG5cbnZhciBDbHVzdGVyJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3RlcihtYXJrZXJDbHVzdGVyZXIpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJDbHVzdGVyZXIgPSBtYXJrZXJDbHVzdGVyZXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMubWFwID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0TWFwKCk7XG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRHcmlkU2l6ZSgpO1xuICAgICAgICB0aGlzLm1pbkNsdXN0ZXJTaXplID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0TWluaW11bUNsdXN0ZXJTaXplKCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEF2ZXJhZ2VDZW50ZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2x1c3Rlckljb24gPSBuZXcgQ2x1c3Rlckljb24odGhpcywgdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0U3R5bGVzKCkpO1xuICAgIH1cbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldE1hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnM7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlcjtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0Q2x1c3RlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJDbHVzdGVyZXI7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlcik7XG4gICAgICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2Vyc1tpXS5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4dGVuZChwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbi5zZXRNYXAobnVsbCk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hcmtlcnM7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWFya2VyQWxyZWFkeUFkZGVkKG1hcmtlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gdGhpcy5tYXJrZXJzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZygodGhpcy5jZW50ZXIubGF0KCkgKiAobGVuZ3RoXzEgLSAxKSArIHBvc2l0aW9uLmxhdCgpKSAvIGxlbmd0aF8xLCAodGhpcy5jZW50ZXIubG5nKCkgKiAobGVuZ3RoXzEgLSAxKSArIHBvc2l0aW9uLmxuZygpKSAvIGxlbmd0aF8xKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLmlzQWRkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgICAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heFpvb20gPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNYXhab29tKCk7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBpZiAobWF4Wm9vbSAhPT0gbnVsbCAmJiB0eXBlb2Ygem9vbSAhPT0gJ3VuZGVmaW5lZCcgJiYgem9vbSA+IG1heFpvb20pIHtcbiAgICAgICAgICAgIC8vIFpvb21lZCBpbiBwYXN0IG1heCB6b29tLCBzbyBzaG93IHRoZSBtYXJrZXIuXG4gICAgICAgICAgICBpZiAobWFya2VyLmdldE1hcCgpICE9PSB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5zZXRNYXAodGhpcy5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1Db3VudCA8IHRoaXMubWluQ2x1c3RlclNpemUpIHtcbiAgICAgICAgICAgIC8vIE1pbiBjbHVzdGVyIHNpemUgbm90IHJlYWNoZWQgc28gc2hvdyB0aGUgbWFya2VyLlxuICAgICAgICAgICAgaWYgKG1hcmtlci5nZXRNYXAoKSAhPT0gdGhpcy5tYXApIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtQ291bnQgPT09IHRoaXMubWluQ2x1c3RlclNpemUpIHtcbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIG1hcmtlcnMgdGhhdCB3ZXJlIHNob3dpbmcuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzW2ldLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5pc01hcmtlckluQ2x1c3RlckJvdW5kcyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kcy5jb250YWlucyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEV4dGVuZGVkQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyKSk7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS51cGRhdGVJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heFpvb20gPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNYXhab29tKCk7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBpZiAobWF4Wm9vbSAhPT0gbnVsbCAmJiB0eXBlb2Ygem9vbSAhPT0gJ3VuZGVmaW5lZCcgJiYgem9vbSA+IG1heFpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlckljb24uaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtQ291bnQgPCB0aGlzLm1pbkNsdXN0ZXJTaXplKSB7XG4gICAgICAgICAgICAvLyBNaW4gY2x1c3RlciBzaXplIG5vdCB5ZXQgcmVhY2hlZC5cbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlckljb24uaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVySWNvbi5zZXRDZW50ZXIodGhpcy5jZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2x1c3Rlckljb24udXNlU3R5bGUodGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0Q2FsY3VsYXRvcigpKHRoaXMubWFya2VycywgdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0U3R5bGVzKCkubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuY2x1c3Rlckljb24uc2hvdygpO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuaXNNYXJrZXJBbHJlYWR5QWRkZWQgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMuaW5jbHVkZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMuaW5jbHVkZXMobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gdGhpcy5tYXJrZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gQ2x1c3Rlcjtcbn0oKSk7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbi8qKlxuICogU3VwcG9ydHMgdXAgdG8gOTAwNzE5OTI1NDc0MDk5MSAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIG1hcmtlcnNcbiAqIHdoaWNoIGlzIG5vdCBhIHByb2JsZW0gYXMgbWF4IGFycmF5IGxlbmd0aCBpcyA0Mjk0OTY3Mjk2ICgyKiozMilcbiAqL1xudmFyIENBTENVTEFUT1IgPSBmdW5jdGlvbiBDQUxDVUxBVE9SKG1hcmtlcnMsIG51bVN0eWxlcykge1xuICAgIHZhciBjb3VudCA9IG1hcmtlcnMubGVuZ3RoO1xuICAgIHZhciBudW1iZXJPZkRpZ2l0cyA9IGNvdW50LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IE1hdGgubWluKG51bWJlck9mRGlnaXRzLCBudW1TdHlsZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IGNvdW50LnRvU3RyaW5nKCksXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgIH07XG59O1xudmFyIEJBVENIX1NJWkUgPSAyMDAwO1xudmFyIEJBVENIX1NJWkVfSUUgPSA1MDA7XG52YXIgSU1BR0VfUEFUSCA9ICdodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9leGFtcGxlcy9tYXJrZXJjbHVzdGVyZXIvbSc7XG52YXIgSU1BR0VfRVhURU5TSU9OID0gJ3BuZyc7XG52YXIgSU1BR0VfU0laRVMgPSBbNTMsIDU2LCA2NiwgNzgsIDkwXTtcbnZhciBDTFVTVEVSRVJfQ0xBU1MgPSAnY2x1c3Rlcic7XG52YXIgQ2x1c3RlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsdXN0ZXJlcihtYXAsIG9wdE1hcmtlcnMsIG9wdE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdE1hcmtlcnMgPT09IHZvaWQgMCkgeyBvcHRNYXJrZXJzID0gW107IH1cbiAgICAgICAgaWYgKG9wdE9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRPcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5leHRlbmQoQ2x1c3RlcmVyLCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gb3B0T3B0aW9ucy5ncmlkU2l6ZSB8fCA2MDtcbiAgICAgICAgdGhpcy5taW5DbHVzdGVyU2l6ZSA9IG9wdE9wdGlvbnMubWluaW11bUNsdXN0ZXJTaXplIHx8IDI7XG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IG9wdE9wdGlvbnMubWF4Wm9vbSB8fCBudWxsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IG9wdE9wdGlvbnMuc3R5bGVzIHx8IFtdO1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0T3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICAgICAgdGhpcy56b29tT25DbGljayA9IHRydWU7XG4gICAgICAgIGlmIChvcHRPcHRpb25zLnpvb21PbkNsaWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbU9uQ2xpY2sgPSBvcHRPcHRpb25zLnpvb21PbkNsaWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy5hdmVyYWdlQ2VudGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IG9wdE9wdGlvbnMuYXZlcmFnZUNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlnbm9yZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy5pZ25vcmVIaWRkZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVIaWRkZW4gPSBvcHRPcHRpb25zLmlnbm9yZUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRPcHRpb25zLmVuYWJsZVJldGluYUljb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnMgPSBvcHRPcHRpb25zLmVuYWJsZVJldGluYUljb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VQYXRoID0gb3B0T3B0aW9ucy5pbWFnZVBhdGggfHwgSU1BR0VfUEFUSDtcbiAgICAgICAgdGhpcy5pbWFnZUV4dGVuc2lvbiA9IG9wdE9wdGlvbnMuaW1hZ2VFeHRlbnNpb24gfHwgSU1BR0VfRVhURU5TSU9OO1xuICAgICAgICB0aGlzLmltYWdlU2l6ZXMgPSBvcHRPcHRpb25zLmltYWdlU2l6ZXMgfHwgSU1BR0VfU0laRVM7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IG9wdE9wdGlvbnMuY2FsY3VsYXRvciB8fCBDQUxDVUxBVE9SO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IG9wdE9wdGlvbnMuYmF0Y2hTaXplIHx8IEJBVENIX1NJWkU7XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplSUUgPSBvcHRPcHRpb25zLmJhdGNoU2l6ZUlFIHx8IEJBVENIX1NJWkVfSUU7XG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzID0gb3B0T3B0aW9ucy5jbHVzdGVyQ2xhc3MgfHwgQ0xVU1RFUkVSX0NMQVNTO1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhdm9pZCBJRSB0aW1lb3V0IHdoZW4gcHJvY2Vzc2luZyBhIGh1Z2UgbnVtYmVyIG9mIG1hcmtlcnM6XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMuYmF0Y2hTaXplSUU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5hZGRNYXJrZXJzKG9wdE1hcmtlcnMsIHRydWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNldE1hcChtYXApOyAvLyBOb3RlOiB0aGlzIGNhdXNlcyBvbkFkZCB0byBiZSBjYWxsZWRcbiAgICB9XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5hY3RpdmVNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIC8vIEFkZCB0aGUgbWFwIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmdldE1hcCgpLCAnem9vbV9jaGFuZ2VkJywgXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzLCBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvbmFtZVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0Vmlld3BvcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIHRoaXMgR29vZ2xlIGJ1Zzogd2hlbiBtYXAgaXMgYXQgbGV2ZWwgMCBhbmQgXCItXCIgb2ZcbiAgICAgICAgICAgICAgICAvLyB6b29tIHNsaWRlciBpcyBjbGlja2VkLCBhIFwiem9vbV9jaGFuZ2VkXCIgZXZlbnQgaXMgZmlyZWQgZXZlbiB0aG91Z2hcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFwIGRvZXNuJ3Qgem9vbSBvdXQgYW55IGZ1cnRoZXIuIEluIHRoaXMgc2l0dWF0aW9uLCBubyBcImlkbGVcIlxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIHRyaWdnZXJlZCBzbyB0aGUgY2x1c3RlciBtYXJrZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgZ2V0IHJlZHJhd24uIFNhbWUgZ29lcyBmb3IgYSB6b29tIGluIGF0IG1heFpvb20uXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRNYXAoKS5nZXRab29tKCkgPT09IChfdGhpcy5nZXQoJ21pblpvb20nKSB8fCAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRNYXAoKS5nZXRab29tKCkgPT09IF90aGlzLmdldCgnbWF4Wm9vbScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIoX3RoaXMsICdpZGxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5nZXRNYXAoKSwgJ2lkbGUnLCBcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQGdldGlmeS9wcm9wZXItYXJyb3dzL3RoaXMsIEBnZXRpZnkvcHJvcGVyLWFycm93cy9uYW1lXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVkcmF3KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvdGhpc1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFB1dCBhbGwgdGhlIG1hbmFnZWQgbWFya2VycyBiYWNrIG9uIHRoZSBtYXA6XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmdldE1hcCgpICE9PSB0aGlzLmFjdGl2ZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2Vyc1tpXS5zZXRNYXAodGhpcy5hY3RpdmVNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgY2x1c3RlcnM6XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIC8vIFJlbW92ZSBtYXAgZXZlbnQgbGlzdGVuZXJzOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVNYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0dXBTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmltYWdlU2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVBhdGggKyAoaSArIDEpICsgJy4nICsgdGhpcy5pbWFnZUV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaW1hZ2VTaXplc1tpXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5pbWFnZVNpemVzW2ldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZml0TWFwVG9NYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlcnNbaV0uZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5leHRlbmQocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZ2V0TWFwKCkuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEdyaWRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkU2l6ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0R3JpZFNpemUgPSBmdW5jdGlvbiAoZ3JpZFNpemUpIHtcbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IGdyaWRTaXplO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNaW5pbXVtQ2x1c3RlclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbkNsdXN0ZXJTaXplO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRNaW5pbXVtQ2x1c3RlclNpemUgPSBmdW5jdGlvbiAobWluaW11bUNsdXN0ZXJTaXplKSB7XG4gICAgICAgIHRoaXMubWluQ2x1c3RlclNpemUgPSBtaW5pbXVtQ2x1c3RlclNpemU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldE1heFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heFpvb207XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldE1heFpvb20gPSBmdW5jdGlvbiAobWF4Wm9vbSkge1xuICAgICAgICB0aGlzLm1heFpvb20gPSBtYXhab29tO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFpvb21PbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tT25DbGljaztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0Wm9vbU9uQ2xpY2sgPSBmdW5jdGlvbiAoem9vbU9uQ2xpY2spIHtcbiAgICAgICAgdGhpcy56b29tT25DbGljayA9IHpvb21PbkNsaWNrO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRBdmVyYWdlQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdmVyYWdlQ2VudGVyO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRBdmVyYWdlQ2VudGVyID0gZnVuY3Rpb24gKGF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgICAgdGhpcy5hdmVyYWdlQ2VudGVyID0gYXZlcmFnZUNlbnRlcjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SWdub3JlSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ25vcmVIaWRkZW47XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldElnbm9yZUhpZGRlbiA9IGZ1bmN0aW9uIChpZ25vcmVIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5pZ25vcmVIaWRkZW4gPSBpZ25vcmVIaWRkZW47XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEVuYWJsZVJldGluYUljb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVSZXRpbmFJY29ucztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0RW5hYmxlUmV0aW5hSWNvbnMgPSBmdW5jdGlvbiAoZW5hYmxlUmV0aW5hSWNvbnMpIHtcbiAgICAgICAgdGhpcy5lbmFibGVSZXRpbmFJY29ucyA9IGVuYWJsZVJldGluYUljb25zO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRJbWFnZUV4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VFeHRlbnNpb247XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEltYWdlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGltYWdlRXh0ZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VFeHRlbnNpb24gPSBpbWFnZUV4dGVuc2lvbjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVBhdGg7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEltYWdlUGF0aCA9IGZ1bmN0aW9uIChpbWFnZVBhdGgpIHtcbiAgICAgICAgdGhpcy5pbWFnZVBhdGggPSBpbWFnZVBhdGg7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEltYWdlU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlU2l6ZXM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEltYWdlU2l6ZXMgPSBmdW5jdGlvbiAoaW1hZ2VTaXplcykge1xuICAgICAgICB0aGlzLmltYWdlU2l6ZXMgPSBpbWFnZVNpemVzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRDYWxjdWxhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdG9yO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRDYWxjdWxhdG9yID0gZnVuY3Rpb24gKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdG9yID0gY2FsY3VsYXRvcjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0QmF0Y2hTaXplSUUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoU2l6ZUlFO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRCYXRjaFNpemVJRSA9IGZ1bmN0aW9uIChiYXRjaFNpemVJRSkge1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUlFID0gYmF0Y2hTaXplSUU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldENsdXN0ZXJDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlckNsYXNzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRDbHVzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoY2x1c3RlckNsYXNzKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzID0gY2x1c3RlckNsYXNzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRUb3RhbE1hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcnM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsQ2x1c3RlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzLmxlbmd0aDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlciwgb3B0Tm9EcmF3KSB7XG4gICAgICAgIHRoaXMucHVzaE1hcmtlclRvKG1hcmtlcik7XG4gICAgICAgIGlmICghb3B0Tm9EcmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZE1hcmtlcnMgPSBmdW5jdGlvbiAobWFya2Vycywgb3B0Tm9EcmF3KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXJrZXJzKSB7XG4gICAgICAgICAgICBpZiAobWFya2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTWFya2VyVG8obWFya2Vyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdE5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5wdXNoTWFya2VyVG8gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIGFkZCBhIGxpc3RlbmVyIHNvIHdlIGNhbiB1cGRhdGUgdGhlIGNsdXN0ZXJzIG9uIHRoZSBkcmFnZW5kOlxuICAgICAgICBpZiAobWFya2VyLmdldERyYWdnYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGdldGlmeS9wcm9wZXItYXJyb3dzL25hbWUsIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyXyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMuaW5kZXhPZikge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm1hcmtlcnMuaW5kZXhPZihtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSB0aGlzLm1hcmtlcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gTWFya2VyIGlzIG5vdCBpbiBvdXIgbGlzdCBvZiBtYXJrZXJzLCBzbyBkbyBub3RoaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIHRoaXMubWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpOyAvLyBSZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBsaXN0IG9mIG1hbmFnZWQgbWFya2Vyc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlciwgb3B0Tm9EcmF3KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yZW1vdmVNYXJrZXJfKG1hcmtlcik7XG4gICAgICAgIGlmICghb3B0Tm9EcmF3ICYmIHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZW1vdmVNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMsIG9wdE5vRHJhdykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSByZW1vdmVkIHx8IHRoaXMucmVtb3ZlTWFya2VyXyhtYXJrZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdE5vRHJhdyAmJiByZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuY2xlYXJNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2xkQ2x1c3RlcnMgPSB0aGlzLmNsdXN0ZXJzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNldFZpZXdwb3J0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMuXG4gICAgICAgIC8vIERvIGl0IGluIGEgdGltZW91dCB0byBwcmV2ZW50IGJsaW5raW5nIGVmZmVjdC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9sZENsdXN0ZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0RXh0ZW5kZWRCb3VuZHMgPSBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHBvaW50cyB0byBwaXhlbHMgYW5kIHRoZSBleHRlbmQgb3V0IGJ5IHRoZSBncmlkIHNpemUuXG4gICAgICAgIHZhciB0clBpeCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoXG4gICAgICAgIC8vIFR1cm4gdGhlIGJvdW5kcyBpbnRvIGxhdGxuZy5cbiAgICAgICAgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubGF0KCksIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sbmcoKSkpO1xuICAgICAgICB0clBpeC54ICs9IHRoaXMuZ3JpZFNpemU7XG4gICAgICAgIHRyUGl4LnkgLT0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgdmFyIGJsUGl4ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChcbiAgICAgICAgLy8gVHVybiB0aGUgYm91bmRzIGludG8gbGF0bG5nLlxuICAgICAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sYXQoKSwgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZygpKSk7XG4gICAgICAgIGJsUGl4LnggLT0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgYmxQaXgueSArPSB0aGlzLmdyaWRTaXplO1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBuZXcgYm91bmRzLlxuICAgICAgICBib3VuZHMuZXh0ZW5kKFxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBwaXhlbCBwb2ludHMgYmFjayB0byBMYXRMbmcgbndcbiAgICAgICAgcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyh0clBpeCkpO1xuICAgICAgICBib3VuZHMuZXh0ZW5kKFxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBwaXhlbCBwb2ludHMgYmFjayB0byBMYXRMbmcgc3dcbiAgICAgICAgcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhibFBpeCkpO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlZHJhd3MgYWxsIHRoZSBjbHVzdGVycy5cbiAgICAgICAgdGhpcy5jcmVhdGVDbHVzdGVycygwKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVzZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIChvcHRIaWRlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIGNsdXN0ZXJzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIC8vIFJlc2V0IHRoZSBtYXJrZXJzIHRvIG5vdCBiZSBhZGRlZCBhbmQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5tYXJrZXJzW2ldO1xuICAgICAgICAgICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvcHRIaWRlKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHZhciBSID0gNjM3MTsgLy8gUmFkaXVzIG9mIHRoZSBFYXJ0aCBpbiBrbVxuICAgICAgICB2YXIgZExhdCA9ICgocDIubGF0KCkgLSBwMS5sYXQoKSkgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICAgICAgdmFyIGRMb24gPSAoKHAyLmxuZygpIC0gcDEubG5nKCkpICogTWF0aC5QSSkgLyAxODA7XG4gICAgICAgIHZhciBhID0gTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcbiAgICAgICAgICAgIE1hdGguY29zKChwMS5sYXQoKSAqIE1hdGguUEkpIC8gMTgwKSAqXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoKHAyLmxhdCgpICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihkTG9uIC8gMikgKlxuICAgICAgICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKTtcbiAgICAgICAgcmV0dXJuIFIgKiAoMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKSk7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmlzTWFya2VySW5Cb3VuZHMgPSBmdW5jdGlvbiAobWFya2VyLCBib3VuZHMpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcy5jb250YWlucyhwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRUb0Nsb3Nlc3RDbHVzdGVyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgY2x1c3RlcjtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gNDAwMDA7IC8vIFNvbWUgbGFyZ2UgbnVtYmVyXG4gICAgICAgIHZhciBjbHVzdGVyVG9BZGRUbyA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2x1c3RlciA9IHRoaXMuY2x1c3RlcnNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gY2x1c3Rlci5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNlbnRlciAmJiBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZUJldHdlZW5Qb2ludHMoY2VudGVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGQgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJUb0FkZFRvID0gY2x1c3RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsdXN0ZXJUb0FkZFRvICYmIGNsdXN0ZXJUb0FkZFRvLmlzTWFya2VySW5DbHVzdGVyQm91bmRzKG1hcmtlcikpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJUb0FkZFRvLmFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2x1c3RlciA9IG5ldyBDbHVzdGVyJDEodGhpcyk7XG4gICAgICAgICAgICBjbHVzdGVyLmFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmNyZWF0ZUNsdXN0ZXJzID0gZnVuY3Rpb24gKGlGaXJzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgcHJldmlvdXMgYmF0Y2ggcHJvY2Vzc2luZyBpZiB3ZSdyZSB3b3JraW5nIG9uIHRoZSBmaXJzdCBiYXRjaDpcbiAgICAgICAgaWYgKGlGaXJzdCA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIDxjb2RlPkNsdXN0ZXJlcjwvY29kZT4gYmVnaW5zXG4gICAgICAgICAgICAgKiAgY2x1c3RlcmluZyBtYXJrZXJzLlxuICAgICAgICAgICAgICogQG5hbWUgQ2x1c3RlcmVyI2NsdXN0ZXJpbmdiZWdpblxuICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyZXJ9IG1jIFRoZSBDbHVzdGVyZXIgd2hvc2UgbWFya2VycyBhcmUgYmVpbmcgY2x1c3RlcmVkLlxuICAgICAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2NsdXN0ZXJpbmdiZWdpbicsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJSZWZTdGF0aWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJSZWZTdGF0aWMpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50aW1lclJlZlN0YXRpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgb3VyIGN1cnJlbnQgbWFwIHZpZXcgYm91bmRzLlxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYm91bmRzIG9iamVjdCBzbyB3ZSBkb24ndCBhZmZlY3QgdGhlIG1hcC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlIENvbW1lbnRzIDkgJiAxMSBvbiBJc3N1ZSAzNjUxIHJlbGF0aW5nIHRvIHRoaXMgd29ya2Fyb3VuZCBmb3IgYSBHb29nbGUgTWFwcyBidWc6XG4gICAgICAgIHZhciBtYXBCb3VuZHMgPSBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5nZXRNYXAoKS5nZXRab29tKCkgPiAzXG4gICAgICAgICAgICA/IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuZ2V0TWFwKClcbiAgICAgICAgICAgICAgICAuZ2V0Qm91bmRzKClcbiAgICAgICAgICAgICAgICAuZ2V0U291dGhXZXN0KCksIFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmdldE1hcCgpXG4gICAgICAgICAgICAgICAgLmdldEJvdW5kcygpXG4gICAgICAgICAgICAgICAgLmdldE5vcnRoRWFzdCgpKVxuICAgICAgICAgICAgOiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoODUuMDIwNzA3NzE3NDM0NzIsIC0xNzguNDgzODg0MzQzNzUpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKC04NS4wODEzNjQ0NDM4NDU0NCwgMTc4LjAwMDQ4ODY1NjI1KSk7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEV4dGVuZGVkQm91bmRzKG1hcEJvdW5kcyk7XG4gICAgICAgIHZhciBpTGFzdCA9IE1hdGgubWluKGlGaXJzdCArIHRoaXMuYmF0Y2hTaXplLCB0aGlzLm1hcmtlcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGlGaXJzdDsgaSA8IGlMYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XG4gICAgICAgICAgICBpZiAoIW1hcmtlci5pc0FkZGVkICYmIHRoaXMuaXNNYXJrZXJJbkJvdW5kcyhtYXJrZXIsIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWdub3JlSGlkZGVuIHx8ICh0aGlzLmlnbm9yZUhpZGRlbiAmJiBtYXJrZXIuZ2V0VmlzaWJsZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRvQ2xvc2VzdENsdXN0ZXIobWFya2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlMYXN0IDwgdGhpcy5tYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzLCBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvbmFtZVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUNsdXN0ZXJzKGlMYXN0KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgPGNvZGU+Q2x1c3RlcmVyPC9jb2RlPiBzdG9wc1xuICAgICAgICAgICAgICogIGNsdXN0ZXJpbmcgbWFya2Vycy5cbiAgICAgICAgICAgICAqIEBuYW1lIENsdXN0ZXJlciNjbHVzdGVyaW5nZW5kXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJlcn0gbWMgVGhlIENsdXN0ZXJlciB3aG9zZSBtYXJrZXJzIGFyZSBiZWluZyBjbHVzdGVyZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnY2x1c3RlcmluZ2VuZCcsIHRoaXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyc1tpXS51cGRhdGVJY29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXh0ZW5kKG9iamVjdCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBvYmplY3QucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0uYXBwbHkob2JqMSwgW29iajJdKTtcbiAgICB9O1xuICAgIHJldHVybiBDbHVzdGVyZXI7XG59KCkpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtZXhwb3J0ZWQgKi9cbmNvbnN0IGV2ZW50TWFwJGUgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkNsdXN0ZXJpbmdCZWdpbjogJ2NsdXN0ZXJpbmdiZWdpbicsXG4gICAgb25DbHVzdGVyaW5nRW5kOiAnY2x1c3RlcmluZ2VuZCcsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG59O1xuY29uc3QgdXBkYXRlck1hcCRlID0ge1xuICAgIGF2ZXJhZ2VDZW50ZXIoaW5zdGFuY2UsIGF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0QXZlcmFnZUNlbnRlcihhdmVyYWdlQ2VudGVyKTtcbiAgICB9LFxuICAgIGJhdGNoU2l6ZUlFKGluc3RhbmNlLCBiYXRjaFNpemVJRSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRCYXRjaFNpemVJRShiYXRjaFNpemVJRSk7XG4gICAgfSxcbiAgICBjYWxjdWxhdG9yKGluc3RhbmNlLCBjYWxjdWxhdG9yKSB7XG4gICAgICAgIGluc3RhbmNlLnNldENhbGN1bGF0b3IoY2FsY3VsYXRvcik7XG4gICAgfSxcbiAgICBjbHVzdGVyQ2xhc3MoaW5zdGFuY2UsIGNsdXN0ZXJDbGFzcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRDbHVzdGVyQ2xhc3MoY2x1c3RlckNsYXNzKTtcbiAgICB9LFxuICAgIGVuYWJsZVJldGluYUljb25zKGluc3RhbmNlLCBlbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRFbmFibGVSZXRpbmFJY29ucyhlbmFibGVSZXRpbmFJY29ucyk7XG4gICAgfSxcbiAgICBncmlkU2l6ZShpbnN0YW5jZSwgZ3JpZFNpemUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0R3JpZFNpemUoZ3JpZFNpemUpO1xuICAgIH0sXG4gICAgaWdub3JlSGlkZGVuKGluc3RhbmNlLCBpZ25vcmVIaWRkZW4pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SWdub3JlSGlkZGVuKGlnbm9yZUhpZGRlbik7XG4gICAgfSxcbiAgICBpbWFnZUV4dGVuc2lvbihpbnN0YW5jZSwgaW1hZ2VFeHRlbnNpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SW1hZ2VFeHRlbnNpb24oaW1hZ2VFeHRlbnNpb24pO1xuICAgIH0sXG4gICAgaW1hZ2VQYXRoKGluc3RhbmNlLCBpbWFnZVBhdGgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SW1hZ2VQYXRoKGltYWdlUGF0aCk7XG4gICAgfSxcbiAgICBpbWFnZVNpemVzKGluc3RhbmNlLCBpbWFnZVNpemVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEltYWdlU2l6ZXMoaW1hZ2VTaXplcyk7XG4gICAgfSxcbiAgICBtYXhab29tKGluc3RhbmNlLCBtYXhab29tKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1heFpvb20obWF4Wm9vbSk7XG4gICAgfSxcbiAgICBtaW5pbXVtQ2x1c3RlclNpemUoaW5zdGFuY2UsIG1pbmltdW1DbHVzdGVyU2l6ZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNaW5pbXVtQ2x1c3RlclNpemUobWluaW11bUNsdXN0ZXJTaXplKTtcbiAgICB9LFxuICAgIHN0eWxlcyhpbnN0YW5jZSwgc3R5bGVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgIH0sXG4gICAgdGl0bGUoaW5zdGFuY2UsIHRpdGxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRpdGxlKTtcbiAgICB9LFxuICAgIHpvb21PbkNsaWNrKGluc3RhbmNlLCB6b29tT25DbGljaykge1xuICAgICAgICBpbnN0YW5jZS5zZXRab29tT25DbGljayh6b29tT25DbGljayk7XG4gICAgfSxcbn07XG5jbGFzcyBDbHVzdGVyZXJDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBtYXJrZXJDbHVzdGVyZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0Q2x1c3RlcmVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJDbHVzdGVyZXIgPSBuZXcgQ2x1c3RlcmVyKHRoaXMuY29udGV4dCwgW10sIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGUsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGUsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG1hcmtlckNsdXN0ZXJlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRDbHVzdGVyZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ2x1c3RlcmVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzLnNldENsdXN0ZXJlckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlcikge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRlLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRlLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIgIT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlcilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG59XG5DbHVzdGVyZXJDb21wb25lbnQuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG52YXIgSW5mb0JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmZvQm94KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5leHRlbmQoSW5mb0JveCwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICAgICAgICAvLyBTdGFuZGFyZCBvcHRpb25zIChpbiBjb21tb24gd2l0aCBnb29nbGUubWFwcy5JbmZvV2luZG93KTpcbiAgICAgICAgdGhpcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgICAgICB0aGlzLmRpc2FibGVBdXRvUGFuID0gb3B0aW9ucy5kaXNhYmxlQXV0b1BhbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5waXhlbE9mZnNldCA9IG9wdGlvbnMucGl4ZWxPZmZzZXQgfHwgbmV3IGdvb2dsZS5tYXBzLlNpemUoMCwgMCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uIHx8IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMCwgMCk7XG4gICAgICAgIHRoaXMuekluZGV4ID0gb3B0aW9ucy56SW5kZXggfHwgbnVsbDtcbiAgICAgICAgLy8gQWRkaXRpb25hbCBvcHRpb25zICh1bmlxdWUgdG8gSW5mb0JveCk6XG4gICAgICAgIHRoaXMuYm94Q2xhc3MgPSBvcHRpb25zLmJveENsYXNzIHx8ICdpbmZvQm94JztcbiAgICAgICAgdGhpcy5ib3hTdHlsZSA9IG9wdGlvbnMuYm94U3R5bGUgfHwge307XG4gICAgICAgIHRoaXMuY2xvc2VCb3hNYXJnaW4gPSBvcHRpb25zLmNsb3NlQm94TWFyZ2luIHx8ICcycHgnO1xuICAgICAgICB0aGlzLmNsb3NlQm94VVJMID0gb3B0aW9ucy5jbG9zZUJveFVSTCB8fCAnaHR0cDovL3d3dy5nb29nbGUuY29tL2ludGwvZW5fdXMvbWFwZmlsZXMvY2xvc2UuZ2lmJztcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCb3hVUkwgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQm94VVJMID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvQm94Q2xlYXJhbmNlID0gb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlIHx8IG5ldyBnb29nbGUubWFwcy5TaXplKDEsIDEpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pc0hpZGRlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aXNpYmxlID0gIW9wdGlvbnMuaXNIaWRkZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICFvcHRpb25zLnZpc2libGU7XG4gICAgICAgIHRoaXMuYWxpZ25Cb3R0b20gPSBvcHRpb25zLmFsaWduQm90dG9tIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnBhbmUgPSBvcHRpb25zLnBhbmUgfHwgJ2Zsb2F0UGFuZSc7XG4gICAgICAgIHRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiA9IG9wdGlvbnMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXQgPSBudWxsO1xuICAgIH1cbiAgICBJbmZvQm94LnByb3RvdHlwZS5jcmVhdGVJbmZvQm94RGl2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXIgcHJldmVudHMgYW4gZXZlbnQgaW4gdGhlIEluZm9Cb3ggZnJvbSBiZWluZyBwYXNzZWQgb24gdG8gdGhlIG1hcC5cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsSGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGhhbmRsZXIgaWdub3JlcyB0aGUgY3VycmVudCBldmVudCBpbiB0aGUgSW5mb0JveCBhbmQgY29uZGl0aW9uYWxseSBwcmV2ZW50c1xuICAgICAgICAvLyB0aGUgZXZlbnQgZnJvbSBiZWluZyBwYXNzZWQgb24gdG8gdGhlIG1hcC4gSXQgaXMgdXNlZCBmb3IgdGhlIGNvbnRleHRtZW51IGV2ZW50LlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEBnZXRpZnkvcHJvcGVyLWFycm93cy90aGlzXG4gICAgICAgIHZhciBpZ25vcmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3RoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3hTdHlsZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpICsgdGhpcy5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHZhciBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKTtcbiAgICAgICAgICAgIHBhbmVzW3RoaXMucGFuZV0uYXBwZW5kQ2hpbGQodGhpcy5kaXYpOyAvLyBBZGQgdGhlIEluZm9Cb3ggZGl2IHRvIHRoZSBET01cbiAgICAgICAgICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXYuc3R5bGUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4V2lkdGggIT09IDAgJiYgdGhpcy5kaXYub2Zmc2V0V2lkdGggPiB0aGlzLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gdGhpcy5tYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRXaWR0aFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgbmVlZGVkIHRvIG92ZXJjb21lIHByb2JsZW1zIHdpdGggTVNJRVxuICAgICAgICAgICAgICAgICAgICB2YXIgYncgPSB0aGlzLmdldEJveFdpZHRocygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IHRoaXMuZGl2Lm9mZnNldFdpZHRoIC0gYncubGVmdCAtIGJ3LnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYW5Cb3godGhpcy5kaXNhYmxlQXV0b1Bhbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogbW91c2Vtb3ZlIG5vdCBpbmNsdWRlZCAodG8gcmVzb2x2ZSBJc3N1ZSAxNTIpXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgICAgICdtb3VzZW92ZXInLFxuICAgICAgICAgICAgICAgICAgICAnbW91c2VvdXQnLFxuICAgICAgICAgICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgICdkYmxjbGljaycsXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXYsIGV2ZW50c1tpXSwgY2FuY2VsSGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBHb29nbGUgYnVnIHRoYXQgY2F1c2VzIHRoZSBjdXJzb3IgdG8gY2hhbmdlIHRvIGEgcG9pbnRlclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBtYXJrZXIgdW5kZXJuZWF0aCBJbmZvQm94LlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMucHVzaChnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdiwgJ21vdXNlb3ZlcicsIFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQGdldGlmeS9wcm9wZXItYXJyb3dzL3RoaXMsIEBnZXRpZnkvcHJvcGVyLWFycm93cy9uYW1lXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdiwgJ2NvbnRleHRtZW51JywgaWdub3JlSGFuZGxlcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRElWIGNvbnRhaW5pbmcgdGhlIEluZm9Cb3gncyBjb250ZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICAgICAgICAgKiBAbmFtZSBJbmZvQm94I2RvbXJlYWR5XG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnZG9tcmVhZHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VCb3hJbWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VCb3hVUkwgIT09ICcnKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBhbHQ9XCJcIic7XG4gICAgICAgICAgICBpbWcgKz0gJyBhcmlhLWhpZGRlbj1cInRydWVcIic7XG4gICAgICAgICAgICBpbWcgKz0gXCIgc3JjPSdcIiArIHRoaXMuY2xvc2VCb3hVUkwgKyBcIidcIjtcbiAgICAgICAgICAgIGltZyArPSAnIGFsaWduPXJpZ2h0JzsgLy8gRG8gdGhpcyBiZWNhdXNlIE9wZXJhIGNob2tlcyBvbiBzdHlsZT0nZmxvYXQ6IHJpZ2h0OydcbiAgICAgICAgICAgIGltZyArPSBcIiBzdHlsZT0nXCI7XG4gICAgICAgICAgICBpbWcgKz0gJyBwb3NpdGlvbjogcmVsYXRpdmU7JzsgLy8gUmVxdWlyZWQgYnkgTVNJRVxuICAgICAgICAgICAgaW1nICs9ICcgY3Vyc29yOiBwb2ludGVyOyc7XG4gICAgICAgICAgICBpbWcgKz0gJyBtYXJnaW46ICcgKyB0aGlzLmNsb3NlQm94TWFyZ2luICsgJzsnO1xuICAgICAgICAgICAgaW1nICs9IFwiJz5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuYWRkQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5kaXYuZmlyc3RDaGlsZCAmJiB0aGlzLmNsb3NlQm94VVJMICE9PSAnJykge1xuICAgICAgICAgICAgdmFyIGNsb3NlQm94ID0gdGhpcy5kaXYuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZERvbUxpc3RlbmVyKGNsb3NlQm94LCAnY2xpY2snLCB0aGlzLmdldENsb3NlQ2xpY2tIYW5kbGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQGdldGlmeS9wcm9wZXItYXJyb3dzL3RoaXMsIEBnZXRpZnkvcHJvcGVyLWFycm93cy9uYW1lXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIDEuMC4zIGZpeDogQWx3YXlzIHByZXZlbnQgcHJvcGFnYXRpb24gb2YgYSBjbG9zZSBib3ggY2xpY2sgdG8gdGhlIG1hcDpcbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgSW5mb0JveCdzIGNsb3NlIGJveCBpcyBjbGlja2VkLlxuICAgICAgICAgICAgICogQG5hbWUgSW5mb0JveCNjbG9zZWNsaWNrXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihfdGhpcywgJ2Nsb3NlY2xpY2snKTtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5wYW5Cb3ggPSBmdW5jdGlvbiAoZGlzYWJsZVBhbikge1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgIWRpc2FibGVQYW4pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHBhbiBpZiBhdHRhY2hlZCB0byBtYXAsIG5vdCBwYW5vcmFtYVxuICAgICAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLk1hcCkge1xuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzICYmICFib3VuZHMuY29udGFpbnModGhpcy5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFya2VyIG5vdCBpbiB2aXNpYmxlIGFyZWEgb2YgbWFwLCBzbyBzZXQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIG1hcCB0byB0aGUgbWFya2VyIHBvc2l0aW9uIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0Q2VudGVyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgbWFwV2lkdGggPSBtYXBEaXYub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBtYXBIZWlnaHQgPSBtYXBEaXYub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBpd09mZnNldFggPSB0aGlzLnBpeGVsT2Zmc2V0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBpd09mZnNldFkgPSB0aGlzLnBpeGVsT2Zmc2V0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgaXdXaWR0aCA9IHRoaXMuZGl2Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBpd0hlaWdodCA9IHRoaXMuZGl2Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgcGFkWCA9IHRoaXMuaW5mb0JveENsZWFyYW5jZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGFkWSA9IHRoaXMuaW5mb0JveENsZWFyYW5jZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpeFBvc2l0aW9uID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAocGl4UG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpeFBvc2l0aW9uLnggPCAtaXdPZmZzZXRYICsgcGFkWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeE9mZnNldCA9IHBpeFBvc2l0aW9uLnggKyBpd09mZnNldFggLSBwYWRYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBpeFBvc2l0aW9uLnggKyBpd1dpZHRoICsgaXdPZmZzZXRYICsgcGFkWCA+IG1hcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gcGl4UG9zaXRpb24ueCArIGl3V2lkdGggKyBpd09mZnNldFggKyBwYWRYIC0gbWFwV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ25Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhQb3NpdGlvbi55IDwgLWl3T2Zmc2V0WSArIHBhZFkgKyBpd0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdPZmZzZXRZIC0gcGFkWSAtIGl3SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSArIHBhZFkgPiBtYXBIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSArIHBhZFkgLSBtYXBIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4UG9zaXRpb24ueSA8IC1pd09mZnNldFkgKyBwYWRZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgLSBwYWRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGl4UG9zaXRpb24ueSArIGl3SGVpZ2h0ICsgaXdPZmZzZXRZICsgcGFkWSA+IG1hcEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdIZWlnaHQgKyBpd09mZnNldFkgKyBwYWRZIC0gbWFwSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgbWFwIHRvIHRoZSBzaGlmdGVkIGNlbnRlci5cbiAgICAgICAgICAgICAgICAgICAgbWFwLnBhbkJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0Qm94U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGUgdmFsdWVzIGZyb20gdGhlIHN0eWxlIHNoZWV0IGRlZmluZWQgaW4gdGhlIGJveENsYXNzIHBhcmFtZXRlcjpcbiAgICAgICAgICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMuYm94Q2xhc3M7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBpbmxpbmUgc3R5bGUgdmFsdWVzOlxuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGUgdmFsdWVzIGRlZmluZWQgaW4gdGhlIGJveFN0eWxlIHBhcmFtZXRlcjpcbiAgICAgICAgICAgIHZhciBib3hTdHlsZSA9IHRoaXMuYm94U3R5bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGJveFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJveFN0eWxlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlW2ldID0gYm94U3R5bGVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGZvciBpT1MgZGlzYXBwZWFyaW5nIEluZm9Cb3ggcHJvYmxlbVxuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTIyOTUzNS9nb29nbGUtbWFwcy1tYXJrZXJzLWRpc2FwcGVhci1hdC1jZXJ0YWluLXpvb20tbGV2ZWwtb25seS1vbi1pcGhvbmUtaXBhZFxuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICAgICAgLy8gRml4IHVwIG9wYWNpdHkgc3R5bGUgZm9yIGJlbmVmaXQgb2YgTVNJRVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpdi5zdHlsZS5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmRpdi5zdHlsZS5vcGFjaXR5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Nzcy9vcGFjaXR5Lmh0bWxcbiAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5kaXYuc3R5bGUub3BhY2l0eSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLm1zRmlsdGVyID1cbiAgICAgICAgICAgICAgICAgICAgJ1wicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9JyArIG9wYWNpdHkgKiAxMDAgKyAnKVwiJztcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5maWx0ZXIgPSAnYWxwaGEob3BhY2l0eT0nICsgb3BhY2l0eSAqIDEwMCArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IHJlcXVpcmVkIHN0eWxlc1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgaWYgKHRoaXMuekluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXggKyAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXYuc3R5bGUub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Qm94V2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYncgPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICAgICAgICByZXR1cm4gYnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5kaXYub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gb3duZXJEb2N1bWVudCAmJiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICAgICAgICAgICAgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5kaXYsICcnKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbXB1dGVkIHN0eWxlcyBhcmUgYWx3YXlzIGluIHBpeGVsIHVuaXRzIChnb29kISlcbiAgICAgICAgICAgICAgICBidy50b3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBidy5ib3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBidy5sZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGJ3LnJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSAvLyBNU0lFXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0eWxlID0gdGhpcy5kaXYuY3VycmVudFN0eWxlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0eWxlcyBtYXkgbm90IGJlIGluIHBpeGVsIHVuaXRzLCBidXQgYXNzdW1lIHRoZXkgYXJlIChiYWQhKVxuICAgICAgICAgICAgICAgIGJ3LnRvcCA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBidy5sZWZ0ID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlckxlZnRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncucmlnaHQgPSBwYXJzZUludChjdXJyZW50U3R5bGUuYm9yZGVyUmlnaHRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ3O1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVJbmZvQm94RGl2KCk7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIHBpeFBvc2l0aW9uID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChwaXhQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSBwaXhQb3NpdGlvbi54ICsgdGhpcy5waXhlbE9mZnNldC53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ25Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuYm90dG9tID0gLShwaXhQb3NpdGlvbi55ICsgdGhpcy5waXhlbE9mZnNldC5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IHBpeFBvc2l0aW9uLnkgKyB0aGlzLnBpeGVsT2Zmc2V0LmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJveENsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBmaXJzdFxuICAgICAgICAgICAgdGhpcy5ib3hDbGFzcyA9IG9wdGlvbnMuYm94Q2xhc3M7XG4gICAgICAgICAgICB0aGlzLnNldEJveFN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJveFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBzZWNvbmRcbiAgICAgICAgICAgIHRoaXMuYm94U3R5bGUgPSBvcHRpb25zLmJveFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3hTdHlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZW50KG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRpc2FibGVBdXRvUGFuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQXV0b1BhbiA9IG9wdGlvbnMuZGlzYWJsZUF1dG9QYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBpeGVsT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5waXhlbE9mZnNldCA9IG9wdGlvbnMucGl4ZWxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsaWduQm90dG9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5hbGlnbkJvdHRvbSA9IG9wdGlvbnMuYWxpZ25Cb3R0b207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuekluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRaSW5kZXgob3B0aW9ucy56SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jbG9zZUJveE1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCb3hNYXJnaW4gPSBvcHRpb25zLmNsb3NlQm94TWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jbG9zZUJveFVSTCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCb3hVUkwgPSBvcHRpb25zLmNsb3NlQm94VVJMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5pbmZvQm94Q2xlYXJhbmNlID0gb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pc0hpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBvcHRpb25zLmlzSGlkZGVuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICFvcHRpb25zLnZpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gPSBvcHRpb25zLmVuYWJsZUV2ZW50UHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY2xvc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9kZCBjb2RlIHJlcXVpcmVkIHRvIG1ha2UgdGhpbmdzIHdvcmsgd2l0aCBNU0lFLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmZpeGVkV2lkdGhTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKSArIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJ2ZXJzZSBjb2RlIHJlcXVpcmVkIHRvIG1ha2UgdGhpbmdzIHdvcmsgd2l0aCBNU0lFLlxuICAgICAgICAgICAgLy8gKEVuc3VyZXMgdGhlIGNsb3NlIGJveCBkb2VzLCBpbiBmYWN0LCBmbG9hdCB0byB0aGUgcmlnaHQuKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmZpeGVkV2lkdGhTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IHRoaXMuZGl2Lm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKSArIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY29udGVudCBvZiB0aGUgSW5mb0JveCBjaGFuZ2VzLlxuICAgICAgICAgKiBAbmFtZSBJbmZvQm94I2NvbnRlbnRfY2hhbmdlZFxuICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2NvbnRlbnRfY2hhbmdlZCcpO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBsYXRMbmc7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICAgICAgICogQG5hbWUgSW5mb0JveCNwb3NpdGlvbl9jaGFuZ2VkXG4gICAgICAgICAqIEBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAncG9zaXRpb25fY2hhbmdlZCcpO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICFpc1Zpc2libGU7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuaXNIaWRkZW4gPyAnaGlkZGVuJyA6ICd2aXNpYmxlJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuekluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gaW5kZXggKyAnJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB6SW5kZXggb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICAgICAgICogQG5hbWUgSW5mb0JveCN6aW5kZXhfY2hhbmdlZFxuICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ3ppbmRleF9jaGFuZ2VkJyk7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56SW5kZXg7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5nZXRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgdmFyIGlzVmlzaWJsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXAgPT09ICd1bmRlZmluZWQnIHx8IG1hcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSAhdGhpcy5pc0hpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtYXAsIGFuY2hvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBhbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYW5jaG9yLCAncG9zaXRpb25fY2hhbmdlZCcsIFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBAZ2V0aWZ5L3Byb3Blci1hcnJvd3MvdGhpcywgQGdldGlmeS9wcm9wZXItYXJyb3dzL25hbWVcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcExpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYW5jaG9yLCAnbWFwX2NoYW5nZWQnLCBcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQGdldGlmeS9wcm9wZXItYXJyb3dzL3RoaXMsIEBnZXRpZnkvcHJvcGVyLWFycm93cy9uYW1lXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIF90aGlzLnNldE1hcChhbmNob3IubWFwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5wYW5Cb3goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY2xvc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5tb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLm1hcExpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5jb250ZXh0TGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2V0TWFwKG51bGwpO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXh0ZW5kKG9iamVjdCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBvYmplY3QucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LmFwcGx5KG9iajEsIFtvYmoyXSk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mb0JveDtcbn0oKSk7XG5cbmNvbnN0IGV2ZW50TWFwJGQgPSB7XG4gICAgb25DbG9zZUNsaWNrOiAnY2xvc2VjbGljaycsXG4gICAgb25Db250ZW50Q2hhbmdlZDogJ2NvbnRlbnRfY2hhbmdlZCcsXG4gICAgb25Eb21SZWFkeTogJ2RvbXJlYWR5JyxcbiAgICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICAgIG9uWmluZGV4Q2hhbmdlZDogJ3ppbmRleF9jaGFuZ2VkJyxcbn07XG5jb25zdCB1cGRhdGVyTWFwJGQgPSB7XG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcG9zaXRpb24oaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24obmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbi5sYXQsIHBvc2l0aW9uLmxuZykpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbiAgICB6SW5kZXgoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9LFxufTtcbmNsYXNzIEluZm9Cb3hDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmZvQm94OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wZW4gPSAoaW5mb0JveCwgYW5jaG9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaW5mb0JveC5vcGVuKHRoaXMuY29udGV4dCwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZm9Cb3guZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluZm9Cb3gub3Blbih0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50XzEoZmFsc2UsICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3Igb3IgYSBwb3NpdGlvbiBwcm9wIGZvciA8SW5mb0JveD4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW5mb0JveENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhbmNob3IsIG9uTG9hZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgaW5mb0JveCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChpbmZvQm94ICE9PSBudWxsICYmIHRoaXMuY29udGFpbmVyRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZm9Cb3guc2V0Q29udGVudCh0aGlzLmNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbihpbmZvQm94LCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKGluZm9Cb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgX2EgPSBvcHRpb25zIHx8IHt9LCB7IHBvc2l0aW9uIH0gPSBfYSwgaW5mb0JveE9wdGlvbnMgPSBfX3Jlc3QkMShfYSwgW1wicG9zaXRpb25cIl0pO1xuICAgICAgICBsZXQgcG9zaXRpb25MYXRMbmc7XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAhKHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSkge1xuICAgICAgICAgICAgcG9zaXRpb25MYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmxhdCwgcG9zaXRpb24ubG5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZvQm94ID0gbmV3IEluZm9Cb3goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbmZvQm94T3B0aW9ucyksIChwb3NpdGlvbkxhdExuZyA/IHsgcG9zaXRpb246IHBvc2l0aW9uTGF0TG5nIH0gOiB7fSkpKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRkLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGQsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluZm9Cb3gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaW5mb0JveCB9LCB0aGlzLnNldEluZm9Cb3hDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBpbmZvQm94IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoaW5mb0JveCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRkLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRkLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluZm9Cb3gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBvblVubW91bnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgaW5mb0JveCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKGluZm9Cb3ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQoaW5mb0JveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICBpbmZvQm94LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB0aGlzLmNvbnRhaW5lckVsZW1lbnQpO1xuICAgIH1cbn1cbkluZm9Cb3hDb21wb25lbnQuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG4vKipcbiAqIEBtb2R1bGUgaGVscGVyc1xuICovXG4vKipcbiAqIEVhcnRoIFJhZGl1cyB1c2VkIHdpdGggdGhlIEhhcnZlc2luZSBmb3JtdWxhIGFuZCBhcHByb3hpbWF0ZXMgdXNpbmcgYSBzcGhlcmljYWwgKG5vbi1lbGxpcHNvaWQpIEVhcnRoLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgZWFydGhSYWRpdXMgPSA2MzcxMDA4Ljg7XG4vKipcbiAqIFVuaXQgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyB1c2luZyBhIHNwaGVyaWNhbCAobm9uLWVsbGlwc29pZCkgZWFydGggcmFkaXVzLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgZmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogZWFydGhSYWRpdXMgKiAxMDAsXG4gICAgY2VudGltZXRyZXM6IGVhcnRoUmFkaXVzICogMTAwLFxuICAgIGRlZ3JlZXM6IGVhcnRoUmFkaXVzIC8gMTExMzI1LFxuICAgIGZlZXQ6IGVhcnRoUmFkaXVzICogMy4yODA4NCxcbiAgICBpbmNoZXM6IGVhcnRoUmFkaXVzICogMzkuMzcsXG4gICAga2lsb21ldGVyczogZWFydGhSYWRpdXMgLyAxMDAwLFxuICAgIGtpbG9tZXRyZXM6IGVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgICBtZXRlcnM6IGVhcnRoUmFkaXVzLFxuICAgIG1ldHJlczogZWFydGhSYWRpdXMsXG4gICAgbWlsZXM6IGVhcnRoUmFkaXVzIC8gMTYwOS4zNDQsXG4gICAgbWlsbGltZXRlcnM6IGVhcnRoUmFkaXVzICogMTAwMCxcbiAgICBtaWxsaW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICAgIG5hdXRpY2FsbWlsZXM6IGVhcnRoUmFkaXVzIC8gMTg1MixcbiAgICByYWRpYW5zOiAxLFxuICAgIHlhcmRzOiBlYXJ0aFJhZGl1cyAqIDEuMDkzNixcbn07XG4vKipcbiAqIFdyYXBzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGluIGEgR2VvSlNPTiB7QGxpbmsgRmVhdHVyZX0uXG4gKlxuICogQG5hbWUgZmVhdHVyZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgaW5wdXQgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZX0gYSBHZW9KU09OIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvbWV0cnkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNTBdXG4gKiB9O1xuICpcbiAqIHZhciBmZWF0dXJlID0gdHVyZi5mZWF0dXJlKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZlYXQgPSB7IHR5cGU6IFwiRmVhdHVyZVwiIH07XG4gICAgaWYgKG9wdGlvbnMuaWQgPT09IDAgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgICBmZWF0LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgICAgICBmZWF0LmJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgfVxuICAgIGZlYXQucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgZmVhdC5nZW9tZXRyeSA9IGdlb207XG4gICAgcmV0dXJuIGZlYXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9pbnR9IHtAbGluayBGZWF0dXJlfSBmcm9tIGEgUG9zaXRpb24uXG4gKlxuICogQG5hbWUgcG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwb3NpdGlvbiAoZWFjaCBpbiBkZWNpbWFsIGRlZ3JlZXMpXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSBhIFBvaW50IGZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wb2ludFxuICovXG5mdW5jdGlvbiBwb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKGNvb3JkaW5hdGVzWzBdKSB8fCAhaXNOdW1iZXIoY29vcmRpbmF0ZXNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgY29udGFpbiBudW1iZXJzXCIpO1xuICAgIH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUge0BsaW5rIEZlYXR1cmV8RmVhdHVyZXN9IGFuZCBjcmVhdGVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtGZWF0dXJlW119IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gRmVhdHVyZUNvbGxlY3Rpb24gb2YgRmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgbG9jYXRpb25BID0gdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSwge25hbWU6ICdMb2NhdGlvbiBBJ30pO1xuICogdmFyIGxvY2F0aW9uQiA9IHR1cmYucG9pbnQoWy03NS44MzMsIDM5LjI4NF0sIHtuYW1lOiAnTG9jYXRpb24gQid9KTtcbiAqIHZhciBsb2NhdGlvbkMgPSB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdLCB7bmFtZTogJ0xvY2F0aW9uIEMnfSk7XG4gKlxuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgbG9jYXRpb25BLFxuICogICBsb2NhdGlvbkIsXG4gKiAgIGxvY2F0aW9uQ1xuICogXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5mdW5jdGlvbiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZjID0geyB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgfTtcbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgICBmYy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJib3gpIHtcbiAgICAgICAgZmMuYmJveCA9IG9wdGlvbnMuYmJveDtcbiAgICB9XG4gICAgZmMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICByZXR1cm4gZmM7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gcmFkaWFucyB0byBhIG1vcmUgZnJpZW5kbHkgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgcmFkaWFuc1RvTGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPVwia2lsb21ldGVyc1wiXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJhZGlhbnNUb0xlbmd0aChyYWRpYW5zLCB1bml0cykge1xuICAgIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7IHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG4gICAgaWYgKCFmYWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byByYWRpYW5zXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBraWxvbWV0ZXJzLCBjZW50aW1ldGVycywgZmVldFxuICpcbiAqIEBuYW1lIGxlbmd0aFRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKSB7XG4gICAgaWYgKHVuaXRzID09PSB2b2lkIDApIHsgdW5pdHMgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzXTtcbiAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIGRlZ3JlZXMgdG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRlZ3JlZXNUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICUgMzYwO1xuICAgIHJldHVybiAocmFkaWFucyAqIE1hdGguUEkpIC8gMTgwO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxlbmd0aCB0byB0aGUgcmVxdWVzdGVkIHVuaXQuXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBraWxvbWV0ZXJzLCBjZW50aW1ldGVycywgZmVldFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggdG8gYmUgY29udmVydGVkXG4gKiBAcGFyYW0ge1VuaXRzfSBbb3JpZ2luYWxVbml0PVwia2lsb21ldGVyc1wiXSBvZiB0aGUgbGVuZ3RoXG4gKiBAcGFyYW0ge1VuaXRzfSBbZmluYWxVbml0PVwia2lsb21ldGVyc1wiXSByZXR1cm5lZCB1bml0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29udmVydGVkIGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb252ZXJ0TGVuZ3RoKGxlbmd0aCwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHsgb3JpZ2luYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHsgZmluYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICBpZiAoIShsZW5ndGggPj0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgfVxuICAgIHJldHVybiByYWRpYW5zVG9MZW5ndGgobGVuZ3RoVG9SYWRpYW5zKGxlbmd0aCwgb3JpZ2luYWxVbml0KSwgZmluYWxVbml0KTtcbn1cbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gICAgcmV0dXJuICFpc05hTihudW0pICYmIG51bSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShudW0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBjbG9uZWQgY29weSBvZiB0aGUgcGFzc2VkIEdlb0pTT04gT2JqZWN0LCBpbmNsdWRpbmcgcG9zc2libGUgJ0ZvcmVpZ24gTWVtYmVycycuXG4gKiB+My01eCBmYXN0ZXIgdGhhbiB0aGUgY29tbW9uIEpTT04ucGFyc2UgKyBKU09OLnN0cmluZ2lmeSBjb21ibyBtZXRob2QuXG4gKlxuICogQG5hbWUgY2xvbmVcbiAqIEBwYXJhbSB7R2VvSlNPTn0gZ2VvanNvbiBHZW9KU09OIE9iamVjdFxuICogQHJldHVybnMge0dlb0pTT059IGNsb25lZCBHZW9KU09OIE9iamVjdFxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtbLTc0LCA0MF0sIFstNzgsIDQyXSwgWy04MiwgMzVdXSwge2NvbG9yOiAncmVkJ30pO1xuICpcbiAqIHZhciBsaW5lQ2xvbmVkID0gdHVyZi5jbG9uZShsaW5lKTtcbiAqL1xuZnVuY3Rpb24gY2xvbmUoZ2VvanNvbikge1xuICAgIGlmICghZ2VvanNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGdlb2pzb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lRmVhdHVyZShnZW9qc29uKTtcbiAgICAgICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVGZWF0dXJlQ29sbGVjdGlvbihnZW9qc29uKTtcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVHZW9tZXRyeShnZW9qc29uKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gR2VvSlNPTiB0eXBlXCIpO1xuICAgIH1cbn1cbi8qKlxuICogQ2xvbmUgRmVhdHVyZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPGFueT59IGNsb25lZCBGZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRmVhdHVyZShnZW9qc29uKSB7XG4gICAgdmFyIGNsb25lZCA9IHsgdHlwZTogXCJGZWF0dXJlXCIgfTtcbiAgICAvLyBQcmVzZXJ2ZSBGb3JlaWduIE1lbWJlcnNcbiAgICBPYmplY3Qua2V5cyhnZW9qc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJvcGVydGllc1wiOlxuICAgICAgICAgICAgY2FzZSBcImdlb21ldHJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjbG9uZWRba2V5XSA9IGdlb2pzb25ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBwcm9wZXJ0aWVzICYgZ2VvbWV0cnkgbGFzdFxuICAgIGNsb25lZC5wcm9wZXJ0aWVzID0gY2xvbmVQcm9wZXJ0aWVzKGdlb2pzb24ucHJvcGVydGllcyk7XG4gICAgY2xvbmVkLmdlb21ldHJ5ID0gY2xvbmVHZW9tZXRyeShnZW9qc29uLmdlb21ldHJ5KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBDbG9uZSBQcm9wZXJ0aWVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEdlb0pTT04gUHJvcGVydGllc1xuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkIFByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gY2xvbmVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICB2YXIgY2xvbmVkID0ge307XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBudWxsXG4gICAgICAgICAgICAgICAgY2xvbmVkW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgQXJyYXlcbiAgICAgICAgICAgICAgICBjbG9uZWRba2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBnZW5lcmljIE9iamVjdFxuICAgICAgICAgICAgICAgIGNsb25lZFtrZXldID0gY2xvbmVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb25lZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBDbG9uZSBGZWF0dXJlIENvbGxlY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxhbnk+fSBnZW9qc29uIEdlb0pTT04gRmVhdHVyZSBDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248YW55Pn0gY2xvbmVkIEZlYXR1cmUgQ29sbGVjdGlvblxuICovXG5mdW5jdGlvbiBjbG9uZUZlYXR1cmVDb2xsZWN0aW9uKGdlb2pzb24pIHtcbiAgICB2YXIgY2xvbmVkID0geyB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgfTtcbiAgICAvLyBQcmVzZXJ2ZSBGb3JlaWduIE1lbWJlcnNcbiAgICBPYmplY3Qua2V5cyhnZW9qc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmVhdHVyZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNsb25lZFtrZXldID0gZ2VvanNvbltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGZlYXR1cmVzXG4gICAgY2xvbmVkLmZlYXR1cmVzID0gZ2VvanNvbi5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lRmVhdHVyZShmZWF0dXJlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBDbG9uZSBHZW9tZXRyeVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0dlb21ldHJ5PGFueT59IGdlb21ldHJ5IEdlb0pTT04gR2VvbWV0cnlcbiAqIEByZXR1cm5zIHtHZW9tZXRyeTxhbnk+fSBjbG9uZWQgR2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gY2xvbmVHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHZhciBnZW9tID0geyB0eXBlOiBnZW9tZXRyeS50eXBlIH07XG4gICAgaWYgKGdlb21ldHJ5LmJib3gpIHtcbiAgICAgICAgZ2VvbS5iYm94ID0gZ2VvbWV0cnkuYmJveDtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIHtcbiAgICAgICAgZ2VvbS5nZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZUdlb21ldHJ5KGcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdlb207XG4gICAgfVxuICAgIGdlb20uY29vcmRpbmF0ZXMgPSBkZWVwU2xpY2UoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgIHJldHVybiBnZW9tO1xufVxuLyoqXG4gKiBEZWVwIFNsaWNlIGNvb3JkaW5hdGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZXN9IGNvb3JkcyBDb29yZGluYXRlc1xuICogQHJldHVybnMge0Nvb3JkaW5hdGVzfSBhbGwgY29vcmRpbmF0ZXMgc2xpY2VkXG4gKi9cbmZ1bmN0aW9uIGRlZXBTbGljZShjb29yZHMpIHtcbiAgICB2YXIgY2xvbmVkID0gY29vcmRzO1xuICAgIGlmICh0eXBlb2YgY2xvbmVkWzBdICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBjbG9uZWQuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZC5tYXAoZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIHJldHVybiBkZWVwU2xpY2UoY29vcmQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBjb29yZEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgY29vcmRFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBmaW5hbCBjb29yZGluYXRlIG9mIExpbmVhclJpbmdzIHRoYXQgd3JhcHMgdGhlIHJpbmcgaW4gaXRzIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudENvb3JkXG4gKiAgIC8vPWNvb3JkSW5kZXhcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb29yZEVhY2goZ2VvanNvbiwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgLy8gSGFuZGxlcyBudWxsIEdlb21ldHJ5IC0tIFNraXBzIHRoaXMgR2VvSlNPTlxuICBpZiAoZ2VvanNvbiA9PT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgaixcbiAgICBrLFxuICAgIGwsXG4gICAgZ2VvbWV0cnksXG4gICAgc3RvcEcsXG4gICAgY29vcmRzLFxuICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgIHdyYXBTaHJpbmsgPSAwLFxuICAgIGNvb3JkSW5kZXggPSAwLFxuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgIHR5cGUgPSBnZW9qc29uLnR5cGUsXG4gICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IHR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICBpc0ZlYXR1cmUgPSB0eXBlID09PSBcIkZlYXR1cmVcIixcbiAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gIGZvciAodmFyIGZlYXR1cmVJbmRleCA9IDA7IGZlYXR1cmVJbmRleCA8IHN0b3A7IGZlYXR1cmVJbmRleCsrKSB7XG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSBpc0ZlYXR1cmVDb2xsZWN0aW9uXG4gICAgICA/IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeVxuICAgICAgOiBpc0ZlYXR1cmVcbiAgICAgID8gZ2VvanNvbi5nZW9tZXRyeVxuICAgICAgOiBnZW9qc29uO1xuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoXG4gICAgICA6IDE7XG5cbiAgICBmb3IgKHZhciBnZW9tSW5kZXggPSAwOyBnZW9tSW5kZXggPCBzdG9wRzsgZ2VvbUluZGV4KyspIHtcbiAgICAgIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IDA7XG4gICAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICAgID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnZW9tSW5kZXhdXG4gICAgICAgIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XG5cbiAgICAgIC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIGdlb21ldHJ5XG4gICAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICB2YXIgZ2VvbVR5cGUgPSBnZW9tZXRyeS50eXBlO1xuXG4gICAgICB3cmFwU2hyaW5rID1cbiAgICAgICAgZXhjbHVkZVdyYXBDb29yZCAmJlxuICAgICAgICAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiIHx8IGdlb21UeXBlID09PSBcIk11bHRpUG9seWdvblwiKVxuICAgICAgICAgID8gMVxuICAgICAgICAgIDogMDtcblxuICAgICAgc3dpdGNoIChnZW9tVHlwZSkge1xuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgICAgIGNvb3JkSW5kZXgsXG4gICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgICAgICkgPT09IGZhbHNlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgY29vcmRzW2pdLFxuICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgsXG4gICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgICAgICAgKSA9PT0gZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIk11bHRpUG9pbnRcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIkxpbmVTdHJpbmdcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoIC0gd3JhcFNocmluazsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgIGNvb3Jkc1tqXVtrXSxcbiAgICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgICAgICAgICApID09PSBmYWxzZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiKSBnZW9tZXRyeUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBnZW9tZXRyeUluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGNvb3Jkc1tqXVtrXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBsKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzW2pdW2tdW2xdLFxuICAgICAgICAgICAgICAgICAgICBjb29yZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeUluZGV4XG4gICAgICAgICAgICAgICAgICApID09PSBmYWxzZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY29vcmRFYWNoKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKSA9PT1cbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZmVhdHVyZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZlYXR1cmVFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgIGNhbGxiYWNrKGdlb2pzb24sIDApO1xuICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXSwgaSkgPT09IGZhbHNlKSBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWxsIGNvb3JkaW5hdGVzIGZyb20gYW55IEdlb0pTT04gb2JqZWN0LlxuICpcbiAqIEBuYW1lIGNvb3JkQWxsXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGUgcG9zaXRpb24gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHZhciBjb29yZHMgPSB0dXJmLmNvb3JkQWxsKGZlYXR1cmVzKTtcbiAqIC8vPSBbWzI2LCAzN10sIFszNiwgNTNdXVxuICovXG5mdW5jdGlvbiBjb29yZEFsbChnZW9qc29uKSB7XG4gIHZhciBjb29yZHMgPSBbXTtcbiAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgfSk7XG4gIHJldHVybiBjb29yZHM7XG59XG5cbnZhciBkaXN0YW5jZSQxID0ge1xuXHQvKipcbiAgKiBFdWNsaWRlYW4gZGlzdGFuY2VcbiAgKi9cblx0ZXVkaXN0OiBmdW5jdGlvbiBldWRpc3QodjEsIHYyLCBzcXJ0KSB7XG5cdFx0dmFyIGxlbiA9IHYxLmxlbmd0aDtcblx0XHR2YXIgc3VtID0gMDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHZhciBkID0gKHYxW2ldIHx8IDApIC0gKHYyW2ldIHx8IDApO1xuXHRcdFx0c3VtICs9IGQgKiBkO1xuXHRcdH1cblx0XHQvLyBTcXVhcmUgcm9vdCBub3QgcmVhbGx5IG5lZWRlZFxuXHRcdHJldHVybiBzcXJ0ID8gTWF0aC5zcXJ0KHN1bSkgOiBzdW07XG5cdH0sXG5cdG1hbmRpc3Q6IGZ1bmN0aW9uIG1hbmRpc3QodjEsIHYyLCBzcXJ0KSB7XG5cdFx0dmFyIGxlbiA9IHYxLmxlbmd0aDtcblx0XHR2YXIgc3VtID0gMDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHN1bSArPSBNYXRoLmFicygodjFbaV0gfHwgMCkgLSAodjJbaV0gfHwgMCkpO1xuXHRcdH1cblxuXHRcdC8vIFNxdWFyZSByb290IG5vdCByZWFsbHkgbmVlZGVkXG5cdFx0cmV0dXJuIHNxcnQgPyBNYXRoLnNxcnQoc3VtKSA6IHN1bTtcblx0fSxcblxuXG5cdC8qKlxuICAqIFVuaWRpbWVuc2lvbmFsIGRpc3RhbmNlXG4gICovXG5cdGRpc3Q6IGZ1bmN0aW9uIGRpc3QodjEsIHYyLCBzcXJ0KSB7XG5cdFx0dmFyIGQgPSBNYXRoLmFicyh2MSAtIHYyKTtcblx0XHRyZXR1cm4gc3FydCA/IGQgOiBkICogZDtcblx0fVxufTtcblxudmFyIERpc3RhbmNlJDEgPSBkaXN0YW5jZSQxLFxuICAgIGV1ZGlzdCQxID0gRGlzdGFuY2UkMS5ldWRpc3QsXG4gICAgZGlzdCA9IERpc3RhbmNlJDEuZGlzdDtcblxudmFyIGtpbml0ID0ge1xuXHRrbXJhbmQ6IGZ1bmN0aW9uIGttcmFuZChkYXRhLCBrKSB7XG5cdFx0dmFyIG1hcCA9IHt9LFxuXHRcdCAgICBrcyA9IFtdLFxuXHRcdCAgICB0ID0gayA8PCAyO1xuXHRcdHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblx0XHR2YXIgbXVsdGkgPSBkYXRhWzBdLmxlbmd0aCA+IDA7XG5cblx0XHR3aGlsZSAoa3MubGVuZ3RoIDwgayAmJiB0LS0gPiAwKSB7XG5cdFx0XHR2YXIgZCA9IGRhdGFbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKV07XG5cdFx0XHR2YXIga2V5ID0gbXVsdGkgPyBkLmpvaW4oXCJfXCIpIDogXCJcIiArIGQ7XG5cdFx0XHRpZiAoIW1hcFtrZXldKSB7XG5cdFx0XHRcdG1hcFtrZXldID0gdHJ1ZTtcblx0XHRcdFx0a3MucHVzaChkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoa3MubGVuZ3RoIDwgaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW5pdGlhbGl6YXRpbmcgY2x1c3RlcnNcIik7ZWxzZSByZXR1cm4ga3M7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBLLW1lYW5zKysgaW5pdGlhbCBjZW50cm9pZCBzZWxlY3Rpb25cbiAgKi9cblx0a21wcDogZnVuY3Rpb24ga21wcChkYXRhLCBrKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gZGF0YVswXS5sZW5ndGggPyBldWRpc3QkMSA6IGRpc3Q7XG5cdFx0dmFyIGtzID0gW10sXG5cdFx0ICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciBtdWx0aSA9IGRhdGFbMF0ubGVuZ3RoID4gMDtcblx0XHR2YXIgbWFwID0ge307XG5cblx0XHQvLyBGaXJzdCByYW5kb20gY2VudHJvaWRcblx0XHR2YXIgYyA9IGRhdGFbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKV07XG5cdFx0dmFyIGtleSA9IG11bHRpID8gYy5qb2luKFwiX1wiKSA6IFwiXCIgKyBjO1xuXHRcdGtzLnB1c2goYyk7XG5cdFx0bWFwW2tleV0gPSB0cnVlO1xuXG5cdFx0Ly8gUmV0cmlldmUgbmV4dCBjZW50cm9pZHNcblx0XHR3aGlsZSAoa3MubGVuZ3RoIDwgaykge1xuXHRcdFx0Ly8gTWluIERpc3RhbmNlcyBiZXR3ZWVuIGN1cnJlbnQgY2VudHJvaWRzIGFuZCBkYXRhIHBvaW50c1xuXHRcdFx0dmFyIGRpc3RzID0gW10sXG5cdFx0XHQgICAgbGsgPSBrcy5sZW5ndGg7XG5cdFx0XHR2YXIgZHN1bSA9IDAsXG5cdFx0XHQgICAgcHJzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIG1pbiA9IEluZmluaXR5O1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxrOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgX2Rpc3QgPSBkaXN0YW5jZShkYXRhW2ldLCBrc1tqXSk7XG5cdFx0XHRcdFx0aWYgKF9kaXN0IDw9IG1pbikgbWluID0gX2Rpc3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlzdHNbaV0gPSBtaW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1bSBhbGwgbWluIGRpc3RhbmNlc1xuXHRcdFx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xuXHRcdFx0XHRkc3VtICs9IGRpc3RzW19pXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvYmFiaWxpdGllcyBhbmQgY3VtbXVsYXRpdmUgcHJvYiAoY3Vtc3VtKVxuXHRcdFx0Zm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuOyBfaTIrKykge1xuXHRcdFx0XHRwcnNbX2kyXSA9IHsgaTogX2kyLCB2OiBkYXRhW19pMl0sIHByOiBkaXN0c1tfaTJdIC8gZHN1bSwgY3M6IDAgfTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCBQcm9iYWJpbGl0aWVzXG5cdFx0XHRwcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5wciAtIGIucHI7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQ3VtbXVsYXRpdmUgUHJvYmFiaWxpdGllc1xuXHRcdFx0cHJzWzBdLmNzID0gcHJzWzBdLnByO1xuXHRcdFx0Zm9yICh2YXIgX2kzID0gMTsgX2kzIDwgbGVuOyBfaTMrKykge1xuXHRcdFx0XHRwcnNbX2kzXS5jcyA9IHByc1tfaTMgLSAxXS5jcyArIHByc1tfaTNdLnByO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSYW5kb21pemVcblx0XHRcdHZhciBybmQgPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0XHQvLyBHZXRzIG9ubHkgdGhlIGl0ZW1zIHdob3NlIGN1bXN1bSA+PSBybmRcblx0XHRcdHZhciBpZHggPSAwO1xuXHRcdFx0d2hpbGUgKGlkeCA8IGxlbiAtIDEgJiYgcHJzW2lkeCsrXS5jcyA8IHJuZCkge31cblx0XHRcdGtzLnB1c2gocHJzW2lkeCAtIDFdLnYpO1xuXHRcdFx0LypcbiAgIGxldCBkb25lID0gZmFsc2U7XG4gICB3aGlsZSghZG9uZSkge1xuICAgXHQvLyB0aGlzIGlzIG91ciBuZXcgY2VudHJvaWRcbiAgIFx0YyA9IHByc1tpZHgtMV0udlxuICAgXHRrZXkgPSBtdWx0aT8gYy5qb2luKFwiX1wiKSA6IGAke2N9YDtcbiAgIFx0aWYoIW1hcFtrZXldKSB7XG4gICBcdFx0bWFwW2tleV0gPSB0cnVlO1xuICAgXHRcdGtzLnB1c2goYyk7XG4gICBcdFx0ZG9uZSA9IHRydWU7XG4gICBcdH1cbiAgIFx0ZWxzZSB7XG4gICBcdFx0aWR4Kys7XG4gICBcdH1cbiAgIH1cbiAgICovXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtzO1xuXHR9XG59O1xuXG4vKmpzaGludCBlc3ZlcnNpb246IDYgKi9cblxudmFyIERpc3RhbmNlID0gZGlzdGFuY2UkMSxcbiAgICBDbHVzdGVySW5pdCA9IGtpbml0LFxuICAgIGV1ZGlzdCA9IERpc3RhbmNlLmV1ZGlzdCxcbiAgICBrbXJhbmQgPSBDbHVzdGVySW5pdC5rbXJhbmQsXG4gICAga21wcCA9IENsdXN0ZXJJbml0LmttcHA7XG5cbnZhciBNQVggPSAxMDAwMDtcblxuLyoqXG4gKiBJbml0cyBhbiBhcnJheSB3aXRoIHZhbHVlc1xuICovXG5mdW5jdGlvbiBpbml0KGxlbiwgdmFsLCB2KSB7XG5cdHYgPSB2IHx8IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dltpXSA9IHZhbDtcblx0fXJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBza21lYW5zKGRhdGEsIGssIGluaXRpYWwsIG1heGl0KSB7XG5cdHZhciBrcyA9IFtdLFxuXHQgICAgb2xkID0gW10sXG5cdCAgICBpZHhzID0gW10sXG5cdCAgICBkaXN0ID0gW107XG5cdHZhciBjb252ID0gZmFsc2UsXG5cdCAgICBpdCA9IG1heGl0IHx8IE1BWDtcblx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoLFxuXHQgICAgdmxlbiA9IGRhdGFbMF0ubGVuZ3RoLFxuXHQgICAgbXVsdGkgPSB2bGVuID4gMDtcblx0dmFyIGNvdW50ID0gW107XG5cblx0aWYgKCFpbml0aWFsKSB7XG5cdFx0dmFyIF9pZHhzID0ge307XG5cdFx0d2hpbGUgKGtzLmxlbmd0aCA8IGspIHtcblx0XHRcdHZhciBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW4pO1xuXHRcdFx0aWYgKCFfaWR4c1tpZHhdKSB7XG5cdFx0XHRcdF9pZHhzW2lkeF0gPSB0cnVlO1xuXHRcdFx0XHRrcy5wdXNoKGRhdGFbaWR4XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGluaXRpYWwgPT0gXCJrbXJhbmRcIikge1xuXHRcdGtzID0ga21yYW5kKGRhdGEsIGspO1xuXHR9IGVsc2UgaWYgKGluaXRpYWwgPT0gXCJrbXBwXCIpIHtcblx0XHRrcyA9IGttcHAoZGF0YSwgayk7XG5cdH0gZWxzZSB7XG5cdFx0a3MgPSBpbml0aWFsO1xuXHR9XG5cblx0ZG8ge1xuXHRcdC8vIFJlc2V0IGsgY291bnRcblx0XHRpbml0KGssIDAsIGNvdW50KTtcblxuXHRcdC8vIEZvciBlYWNoIHZhbHVlIGluIGRhdGEsIGZpbmQgdGhlIG5lYXJlc3QgY2VudHJvaWRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgbWluID0gSW5maW5pdHksXG5cdFx0XHQgICAgX2lkeCA9IDA7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHQvLyBNdWx0aWRpbWVuc2lvbmFsIG9yIHVuaWRpbWVuc2lvbmFsXG5cdFx0XHRcdHZhciBkaXN0ID0gbXVsdGkgPyBldWRpc3QoZGF0YVtpXSwga3Nbal0pIDogTWF0aC5hYnMoZGF0YVtpXSAtIGtzW2pdKTtcblx0XHRcdFx0aWYgKGRpc3QgPD0gbWluKSB7XG5cdFx0XHRcdFx0bWluID0gZGlzdDtcblx0XHRcdFx0XHRfaWR4ID0gajtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWR4c1tpXSA9IF9pZHg7IC8vIEluZGV4IG9mIHRoZSBzZWxlY3RlZCBjZW50cm9pZCBmb3IgdGhhdCB2YWx1ZVxuXHRcdFx0Y291bnRbX2lkeF0rKzsgLy8gTnVtYmVyIG9mIHZhbHVlcyBmb3IgdGhpcyBjZW50cm9pZFxuXHRcdH1cblxuXHRcdC8vIFJlY2FsY3VsYXRlIGNlbnRyb2lkc1xuXHRcdHZhciBzdW0gPSBbXSxcblx0XHQgICAgb2xkID0gW107XG5cdFx0Zm9yICh2YXIgX2ogPSAwOyBfaiA8IGs7IF9qKyspIHtcblx0XHRcdC8vIE11bHRpZGltZW5zaW9uYWwgb3IgdW5pZGltZW5zaW9uYWxcblx0XHRcdHN1bVtfal0gPSBtdWx0aSA/IGluaXQodmxlbiwgMCwgc3VtW19qXSkgOiAwO1xuXHRcdFx0b2xkW19qXSA9IGtzW19qXTtcblx0XHR9XG5cblx0XHQvLyBJZiBtdWx0aWRpbWVuc2lvbmFsXG5cdFx0aWYgKG11bHRpKSB7XG5cdFx0XHRmb3IgKHZhciBfajIgPSAwOyBfajIgPCBrOyBfajIrKykge1xuXHRcdFx0XHRrc1tfajJdID0gW107XG5cdFx0XHR9IC8vIFN1bSB2YWx1ZXMgYW5kIGNvdW50IGZvciBlYWNoIGNlbnRyb2lkXG5cdFx0XHRmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG5cdFx0XHRcdHZhciBfaWR4MiA9IGlkeHNbX2ldLFxuXHRcdFx0XHQgICAgLy8gQ2VudHJvaWQgZm9yIHRoYXQgaXRlbVxuXHRcdFx0XHR2c3VtID0gc3VtW19pZHgyXSxcblx0XHRcdFx0ICAgIC8vIFN1bSB2YWx1ZXMgZm9yIHRoaXMgY2VudHJvaWRcblx0XHRcdFx0dmVjdCA9IGRhdGFbX2ldOyAvLyBDdXJyZW50IHZlY3RvclxuXG5cdFx0XHRcdC8vIEFjY3VtdWxhdGUgdmFsdWUgb24gdGhlIGNlbnRyb2lkIGZvciBjdXJyZW50IHZlY3RvclxuXHRcdFx0XHRmb3IgKHZhciBoID0gMDsgaCA8IHZsZW47IGgrKykge1xuXHRcdFx0XHRcdHZzdW1baF0gKz0gdmVjdFtoXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIGZvciBlYWNoIGNlbnRyb2lkXG5cdFx0XHRjb252ID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGs7IF9qMysrKSB7XG5cdFx0XHRcdHZhciBrc2ogPSBrc1tfajNdLFxuXHRcdFx0XHQgICAgLy8gQ3VycmVudCBjZW50cm9pZFxuXHRcdFx0XHRzdW1qID0gc3VtW19qM10sXG5cdFx0XHRcdCAgICAvLyBBY2N1bXVsYXRlZCBjZW50cm9pZCB2YWx1ZXNcblx0XHRcdFx0b2xkaiA9IG9sZFtfajNdLFxuXHRcdFx0XHQgICAgLy8gT2xkIGNlbnRyb2lkIHZhbHVlXG5cdFx0XHRcdGNqID0gY291bnRbX2ozXTsgLy8gTnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGlzIGNlbnRyb2lkXG5cblx0XHRcdFx0Ly8gTmV3IGF2ZXJhZ2Vcblx0XHRcdFx0Zm9yICh2YXIgX2ggPSAwOyBfaCA8IHZsZW47IF9oKyspIHtcblx0XHRcdFx0XHRrc2pbX2hdID0gc3VtaltfaF0gLyBjaiB8fCAwOyAvLyBOZXcgY2VudHJvaWRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZpbmQgaWYgY2VudHJvaWRzIGhhdmUgbW92ZWRcblx0XHRcdFx0aWYgKGNvbnYpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBfaDIgPSAwOyBfaDIgPCB2bGVuOyBfaDIrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZGpbX2gyXSAhPSBrc2pbX2gyXSkge1xuXHRcdFx0XHRcdFx0XHRjb252ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB1bmlkaW1lbnNpb25hbFxuXHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBTdW0gdmFsdWVzIGFuZCBjb3VudCBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0XHRmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW47IF9pMisrKSB7XG5cdFx0XHRcdFx0dmFyIF9pZHgzID0gaWR4c1tfaTJdO1xuXHRcdFx0XHRcdHN1bVtfaWR4M10gKz0gZGF0YVtfaTJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYXZlcmFnZSBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0XHRmb3IgKHZhciBfajQgPSAwOyBfajQgPCBrOyBfajQrKykge1xuXHRcdFx0XHRcdGtzW19qNF0gPSBzdW1bX2o0XSAvIGNvdW50W19qNF0gfHwgMDsgLy8gTmV3IGNlbnRyb2lkXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRmluZCBpZiBjZW50cm9pZHMgaGF2ZSBtb3ZlZFxuXHRcdFx0XHRjb252ID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgazsgX2o1KyspIHtcblx0XHRcdFx0XHRpZiAob2xkW19qNV0gIT0ga3NbX2o1XSkge1xuXHRcdFx0XHRcdFx0Y29udiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRjb252ID0gY29udiB8fCAtLWl0IDw9IDA7XG5cdH0gd2hpbGUgKCFjb252KTtcblxuXHRyZXR1cm4ge1xuXHRcdGl0OiBNQVggLSBpdCxcblx0XHRrOiBrLFxuXHRcdGlkeHM6IGlkeHMsXG5cdFx0Y2VudHJvaWRzOiBrc1xuXHR9O1xufVxuXG52YXIgbWFpbiA9IHNrbWVhbnM7XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIHBhcnRpdGlvbiB0aGVtIGludG8gY2x1c3RlcnMgdXNpbmcgdGhlIGstbWVhbiAuXG4gKiBJdCB1c2VzIHRoZSBbay1tZWFucyBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0stbWVhbnNfY2x1c3RlcmluZylcbiAqXG4gKiBAbmFtZSBjbHVzdGVyc0ttZWFuc1xuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyB0byBiZSBjbHVzdGVyZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm51bWJlck9mQ2x1c3RlcnM9TWF0aC5zcXJ0KG51bWJlck9mUG9pbnRzLzIpXSBudW1iZXJPZkNsdXN0ZXJzIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubXV0YXRlPWZhbHNlXSBhbGxvd3MgR2VvSlNPTiBpbnB1dCB0byBiZSBtdXRhdGVkIChzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpZiB0cnVlKVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gQ2x1c3RlcmVkIFBvaW50cyB3aXRoIGFuIGFkZGl0aW9uYWwgdHdvIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB0byBlYWNoIEZlYXR1cmU6XG4gKiAtIHtudW1iZXJ9IGNsdXN0ZXIgLSB0aGUgYXNzb2NpYXRlZCBjbHVzdGVySWRcbiAqIC0ge1tudW1iZXIsIG51bWJlcl19IGNlbnRyb2lkIC0gQ2VudHJvaWQgb2YgdGhlIGNsdXN0ZXIgW0xvbmdpdHVkZSwgTGF0aXR1ZGVdXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRlIHJhbmRvbSBwb2ludHMgd2l0aCByYW5kb20gei12YWx1ZXMgaW4gdGhlaXIgcHJvcGVydGllc1xuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tUG9pbnQoMTAwLCB7YmJveDogWzAsIDMwLCAyMCwgNTBdfSk7XG4gKiB2YXIgb3B0aW9ucyA9IHtudW1iZXJPZkNsdXN0ZXJzOiA3fTtcbiAqIHZhciBjbHVzdGVyZWQgPSB0dXJmLmNsdXN0ZXJzS21lYW5zKHBvaW50cywgb3B0aW9ucyk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2NsdXN0ZXJlZF07XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJzS21lYW5zKHBvaW50cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgLy8gRGVmYXVsdCBQYXJhbXNcbiAgICB2YXIgY291bnQgPSBwb2ludHMuZmVhdHVyZXMubGVuZ3RoO1xuICAgIG9wdGlvbnMubnVtYmVyT2ZDbHVzdGVycyA9XG4gICAgICAgIG9wdGlvbnMubnVtYmVyT2ZDbHVzdGVycyB8fCBNYXRoLnJvdW5kKE1hdGguc3FydChjb3VudCAvIDIpKTtcbiAgICAvLyBudW1iZXJPZkNsdXN0ZXJzIGNhbid0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgIC8vIGZhbGxiYWNrcyB0byBjb3VudFxuICAgIGlmIChvcHRpb25zLm51bWJlck9mQ2x1c3RlcnMgPiBjb3VudClcbiAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsdXN0ZXJzID0gY291bnQ7XG4gICAgLy8gQ2xvbmUgcG9pbnRzIHRvIHByZXZlbnQgYW55IG11dGF0aW9ucyAoZW5hYmxlZCBieSBkZWZhdWx0KVxuICAgIGlmIChvcHRpb25zLm11dGF0ZSAhPT0gdHJ1ZSlcbiAgICAgICAgcG9pbnRzID0gY2xvbmUocG9pbnRzKTtcbiAgICAvLyBjb2xsZWN0IHBvaW50cyBjb29yZGluYXRlc1xuICAgIHZhciBkYXRhID0gY29vcmRBbGwocG9pbnRzKTtcbiAgICAvLyBjcmVhdGUgc2VlZCB0byBhdm9pZCBza21lYW5zIHRvIGRyaWZ0XG4gICAgdmFyIGluaXRpYWxDZW50cm9pZHMgPSBkYXRhLnNsaWNlKDAsIG9wdGlvbnMubnVtYmVyT2ZDbHVzdGVycyk7XG4gICAgLy8gY3JlYXRlIHNrbWVhbnMgY2x1c3RlcnNcbiAgICB2YXIgc2ttZWFuc1Jlc3VsdCA9IG1haW4oZGF0YSwgb3B0aW9ucy5udW1iZXJPZkNsdXN0ZXJzLCBpbml0aWFsQ2VudHJvaWRzKTtcbiAgICAvLyBzdG9yZSBjZW50cm9pZHMge2NsdXN0ZXJJZDogW251bWJlciwgbnVtYmVyXX1cbiAgICB2YXIgY2VudHJvaWRzID0ge307XG4gICAgc2ttZWFuc1Jlc3VsdC5jZW50cm9pZHMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQsIGlkeCkge1xuICAgICAgICBjZW50cm9pZHNbaWR4XSA9IGNvb3JkO1xuICAgIH0pO1xuICAgIC8vIGFkZCBhc3NvY2lhdGVkIGNsdXN0ZXIgbnVtYmVyXG4gICAgZmVhdHVyZUVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBjbHVzdGVySWQgPSBza21lYW5zUmVzdWx0LmlkeHNbaW5kZXhdO1xuICAgICAgICBwb2ludC5wcm9wZXJ0aWVzLmNsdXN0ZXIgPSBjbHVzdGVySWQ7XG4gICAgICAgIHBvaW50LnByb3BlcnRpZXMuY2VudHJvaWQgPSBjZW50cm9pZHNbY2x1c3RlcklkXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG4vKipcbiAqIFVud3JhcCBhIGNvb3JkaW5hdGUgZnJvbSBhIFBvaW50IEZlYXR1cmUsIEdlb21ldHJ5IG9yIGEgc2luZ2xlIGNvb3JkaW5hdGUuXG4gKlxuICogQG5hbWUgZ2V0Q29vcmRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxHZW9tZXRyeTxQb2ludD58RmVhdHVyZTxQb2ludD59IGNvb3JkIEdlb0pTT04gUG9pbnQgb3IgYW4gQXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0gdHVyZi5wb2ludChbMTAsIDEwXSk7XG4gKlxuICogdmFyIGNvb3JkID0gdHVyZi5nZXRDb29yZChwdCk7XG4gKiAvLz0gWzEwLCAxMF1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmQoY29vcmQpIHtcbiAgICBpZiAoIWNvb3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29vcmQpKSB7XG4gICAgICAgIGlmIChjb29yZC50eXBlID09PSBcIkZlYXR1cmVcIiAmJlxuICAgICAgICAgICAgY29vcmQuZ2VvbWV0cnkgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGNvb3JkLmdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZC50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5jb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb29yZCkgJiZcbiAgICAgICAgY29vcmQubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoY29vcmRbMF0pICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KGNvb3JkWzFdKSkge1xuICAgICAgICByZXR1cm4gY29vcmQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIG11c3QgYmUgR2VvSlNPTiBQb2ludCBvciBhbiBBcnJheSBvZiBudW1iZXJzXCIpO1xufVxuXG4vL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28ge0BsaW5rIFBvaW50fHBvaW50c30gaW4gZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnMuXG4gKiBUaGlzIHVzZXMgdGhlIFtIYXZlcnNpbmUgZm9ybXVsYV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYSkgdG8gYWNjb3VudCBmb3IgZ2xvYmFsIGN1cnZhdHVyZS5cbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVxuICogQHBhcmFtIHtDb29yZCB8IFBvaW50fSBmcm9tIG9yaWdpbiBwb2ludCBvciBjb29yZGluYXRlXG4gKiBAcGFyYW0ge0Nvb3JkIHwgUG9pbnR9IHRvIGRlc3RpbmF0aW9uIHBvaW50IG9yIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXRzPSdraWxvbWV0ZXJzJ10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZyb20gPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciB0byA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10pO1xuICogdmFyIG9wdGlvbnMgPSB7dW5pdHM6ICdtaWxlcyd9O1xuICpcbiAqIHZhciBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICpcbiAqIC8vYWRkVG9NYXBcbiAqIHZhciBhZGRUb01hcCA9IFtmcm9tLCB0b107XG4gKiBmcm9tLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqIHRvLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjb29yZGluYXRlczEgPSBnZXRDb29yZChmcm9tKTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gZ2V0Q29vcmQodG8pO1xuICAgIHZhciBkTGF0ID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMV0gLSBjb29yZGluYXRlczFbMV0pO1xuICAgIHZhciBkTG9uID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMF0gLSBjb29yZGluYXRlczFbMF0pO1xuICAgIHZhciBsYXQxID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczFbMV0pO1xuICAgIHZhciBsYXQyID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMV0pO1xuICAgIHZhciBhID0gTWF0aC5wb3coTWF0aC5zaW4oZExhdCAvIDIpLCAyKSArXG4gICAgICAgIE1hdGgucG93KE1hdGguc2luKGRMb24gLyAyKSwgMikgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xuICAgIHJldHVybiByYWRpYW5zVG9MZW5ndGgoMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKSwgb3B0aW9ucy51bml0cyk7XG59XG5cbnZhciBsaWIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREJTQ0FOID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXHJcbiAqIERCU0NBTiAtIERlbnNpdHkgYmFzZWQgY2x1c3RlcmluZ1xyXG4gKlxyXG4gKiBAYXV0aG9yIEx1a2FzeiBLcmF3Y3p5ayA8Y29udGFjdEBsdWthc3prcmF3Y3p5ay5ldT5cclxuICogQGNvcHlyaWdodCBNSVRcclxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4vKipcclxuICogREJTQ0FOIGNsYXNzIGNvbnN0cnVjb3RyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcHNpbG9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QdHNcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VGdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7REJTQ0FOfVxyXG4gKi9cclxuZnVuY3Rpb24gREJTQ0FOKGRhdGFzZXQsIGVwc2lsb24sIG1pblB0cywgZGlzdGFuY2VGdW5jdGlvbikge1xyXG4gIC8qKiBAdHlwZSB7QXJyYXl9ICovXHJcbiAgdGhpcy5kYXRhc2V0ID0gW107XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgdGhpcy5lcHNpbG9uID0gMTtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICB0aGlzLm1pblB0cyA9IDI7XHJcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbn0gKi9cclxuICB0aGlzLmRpc3RhbmNlID0gdGhpcy5fZXVjbGlkZWFuRGlzdGFuY2U7XHJcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cclxuICB0aGlzLmNsdXN0ZXJzID0gW107XHJcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cclxuICB0aGlzLm5vaXNlID0gW107XHJcblxyXG4gIC8vIHRlbXBvcmFyeSB2YXJpYWJsZXMgdXNlZCBkdXJpbmcgY29tcHV0YXRpb25cclxuXHJcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cclxuICB0aGlzLl92aXNpdGVkID0gW107XHJcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cclxuICB0aGlzLl9hc3NpZ25lZCA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIHRoaXMuX2RhdGFzZXRMZW5ndGggPSAwO1xyXG5cclxuICB0aGlzLl9pbml0KGRhdGFzZXQsIGVwc2lsb24sIG1pblB0cywgZGlzdGFuY2VGdW5jdGlvbik7XHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLy8gcHVibGljIGZ1bmN0aW9uc1xyXG5cclxuLyoqXHJcbiAqIFN0YXJ0IGNsdXN0ZXJpbmdcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YXNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXBzaWxvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUHRzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlRnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQGFjY2VzcyBwdWJsaWNcclxuICovXHJcbkRCU0NBTi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZGF0YXNldCwgZXBzaWxvbiwgbWluUHRzLCBkaXN0YW5jZUZ1bmN0aW9uKSB7XHJcbiAgdGhpcy5faW5pdChkYXRhc2V0LCBlcHNpbG9uLCBtaW5QdHMsIGRpc3RhbmNlRnVuY3Rpb24pO1xyXG5cclxuICBmb3IgKHZhciBwb2ludElkID0gMDsgcG9pbnRJZCA8IHRoaXMuX2RhdGFzZXRMZW5ndGg7IHBvaW50SWQrKykge1xyXG4gICAgLy8gaWYgcG9pbnQgaXMgbm90IHZpc2l0ZWQsIGNoZWNrIGlmIGl0IGZvcm1zIGEgY2x1c3RlclxyXG4gICAgaWYgKHRoaXMuX3Zpc2l0ZWRbcG9pbnRJZF0gIT09IDEpIHtcclxuICAgICAgdGhpcy5fdmlzaXRlZFtwb2ludElkXSA9IDE7XHJcblxyXG4gICAgICAvLyBpZiBjbG9zZXN0IG5laWdoYm9yaG9vZCBpcyB0b28gc21hbGwgdG8gZm9ybSBhIGNsdXN0ZXIsIG1hcmsgYXMgbm9pc2VcclxuICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuX3JlZ2lvblF1ZXJ5KHBvaW50SWQpO1xyXG5cclxuICAgICAgaWYgKG5laWdoYm9ycy5sZW5ndGggPCB0aGlzLm1pblB0cykge1xyXG4gICAgICAgIHRoaXMubm9pc2UucHVzaChwb2ludElkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IGNsdXN0ZXIgYW5kIGFkZCBwb2ludFxyXG4gICAgICAgIHZhciBjbHVzdGVySWQgPSB0aGlzLmNsdXN0ZXJzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzLnB1c2goW10pO1xyXG4gICAgICAgIHRoaXMuX2FkZFRvQ2x1c3Rlcihwb2ludElkLCBjbHVzdGVySWQpO1xyXG5cclxuICAgICAgICB0aGlzLl9leHBhbmRDbHVzdGVyKGNsdXN0ZXJJZCwgbmVpZ2hib3JzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcnM7XHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vLyBwcm90ZWN0ZWQgZnVuY3Rpb25zXHJcblxyXG4vKipcclxuICogU2V0IG9iamVjdCBwcm9wZXJ0aWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVwc2lsb25cclxuICogQHBhcmFtIHtudW1iZXJ9IG1pblB0c1xyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gKi9cclxuREJTQ0FOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGRhdGFzZXQsIGVwc2lsb24sIG1pblB0cywgZGlzdGFuY2UpIHtcclxuXHJcbiAgaWYgKGRhdGFzZXQpIHtcclxuXHJcbiAgICBpZiAoIShkYXRhc2V0IGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdEYXRhc2V0IG11c3QgYmUgb2YgdHlwZSBhcnJheSwgJyArXHJcbiAgICAgICAgdHlwZW9mIGRhdGFzZXQgKyAnIGdpdmVuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXRhc2V0ID0gZGF0YXNldDtcclxuICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcclxuICAgIHRoaXMubm9pc2UgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9kYXRhc2V0TGVuZ3RoID0gZGF0YXNldC5sZW5ndGg7XHJcbiAgICB0aGlzLl92aXNpdGVkID0gbmV3IEFycmF5KHRoaXMuX2RhdGFzZXRMZW5ndGgpO1xyXG4gICAgdGhpcy5fYXNzaWduZWQgPSBuZXcgQXJyYXkodGhpcy5fZGF0YXNldExlbmd0aCk7XHJcbiAgfVxyXG5cclxuICBpZiAoZXBzaWxvbikge1xyXG4gICAgdGhpcy5lcHNpbG9uID0gZXBzaWxvbjtcclxuICB9XHJcblxyXG4gIGlmIChtaW5QdHMpIHtcclxuICAgIHRoaXMubWluUHRzID0gbWluUHRzO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRpc3RhbmNlKSB7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4cGFuZCBjbHVzdGVyIHRvIGNsb3Nlc3QgcG9pbnRzIG9mIGdpdmVuIG5laWdoYm9yaG9vZFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2x1c3RlcklkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gKi9cclxuREJTQ0FOLnByb3RvdHlwZS5fZXhwYW5kQ2x1c3RlciA9IGZ1bmN0aW9uKGNsdXN0ZXJJZCwgbmVpZ2hib3JzKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0J3MgdmVyeSBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZiBuZWlnaGJvcnMgYXJyYXkgZWFjaCB0aW1lLFxyXG4gICAqIGFzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY2hhbmdlcyBvdmVyIHRpbWVcclxuICAgKi9cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHBvaW50SWQyID0gbmVpZ2hib3JzW2ldO1xyXG5cclxuICAgIGlmICh0aGlzLl92aXNpdGVkW3BvaW50SWQyXSAhPT0gMSkge1xyXG4gICAgICB0aGlzLl92aXNpdGVkW3BvaW50SWQyXSA9IDE7XHJcbiAgICAgIHZhciBuZWlnaGJvcnMyID0gdGhpcy5fcmVnaW9uUXVlcnkocG9pbnRJZDIpO1xyXG5cclxuICAgICAgaWYgKG5laWdoYm9yczIubGVuZ3RoID49IHRoaXMubWluUHRzKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzID0gdGhpcy5fbWVyZ2VBcnJheXMobmVpZ2hib3JzLCBuZWlnaGJvcnMyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCB0byBjbHVzdGVyXHJcbiAgICBpZiAodGhpcy5fYXNzaWduZWRbcG9pbnRJZDJdICE9PSAxKSB7XHJcbiAgICAgIHRoaXMuX2FkZFRvQ2x1c3Rlcihwb2ludElkMiwgY2x1c3RlcklkKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIG5ldyBwb2ludCB0byBjbHVzdGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludElkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbHVzdGVySWRcclxuICovXHJcbkRCU0NBTi5wcm90b3R5cGUuX2FkZFRvQ2x1c3RlciA9IGZ1bmN0aW9uKHBvaW50SWQsIGNsdXN0ZXJJZCkge1xyXG4gIHRoaXMuY2x1c3RlcnNbY2x1c3RlcklkXS5wdXNoKHBvaW50SWQpO1xyXG4gIHRoaXMuX2Fzc2lnbmVkW3BvaW50SWRdID0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFsbCBuZWlnaGJvcnMgYXJvdW5kIGdpdmVuIHBvaW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludElkLFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXBzaWxvblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAqL1xyXG5EQlNDQU4ucHJvdG90eXBlLl9yZWdpb25RdWVyeSA9IGZ1bmN0aW9uKHBvaW50SWQpIHtcclxuICB2YXIgbmVpZ2hib3JzID0gW107XHJcblxyXG4gIGZvciAodmFyIGlkID0gMDsgaWQgPCB0aGlzLl9kYXRhc2V0TGVuZ3RoOyBpZCsrKSB7XHJcbiAgICB2YXIgZGlzdCA9IHRoaXMuZGlzdGFuY2UodGhpcy5kYXRhc2V0W3BvaW50SWRdLCB0aGlzLmRhdGFzZXRbaWRdKTtcclxuICAgIGlmIChkaXN0IDwgdGhpcy5lcHNpbG9uKSB7XHJcbiAgICAgIG5laWdoYm9ycy5wdXNoKGlkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZWlnaGJvcnM7XHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vLyBoZWxwZXJzXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtBcnJheX0gYVxyXG4gKiBAcGFyYW0ge0FycmF5fSBiXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICovXHJcbkRCU0NBTi5wcm90b3R5cGUuX21lcmdlQXJyYXlzID0gZnVuY3Rpb24oYSwgYikge1xyXG4gIHZhciBsZW4gPSBiLmxlbmd0aDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdmFyIFAgPSBiW2ldO1xyXG4gICAgaWYgKGEuaW5kZXhPZihQKSA8IDApIHtcclxuICAgICAgYS5wdXNoKFApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGV1Y2xpZGVhbiBkaXN0YW5jZSBpbiBtdWx0aWRpbWVuc2lvbmFsIHNwYWNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBcclxuICogQHBhcmFtIHtBcnJheX0gcVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gKi9cclxuREJTQ0FOLnByb3RvdHlwZS5fZXVjbGlkZWFuRGlzdGFuY2UgPSBmdW5jdGlvbihwLCBxKSB7XHJcbiAgdmFyIHN1bSA9IDA7XHJcbiAgdmFyIGkgPSBNYXRoLm1pbihwLmxlbmd0aCwgcS5sZW5ndGgpO1xyXG5cclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBzdW0gKz0gKHBbaV0gLSBxW2ldKSAqIChwW2ldIC0gcVtpXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XHJcbn07XHJcblxyXG5pZiAobW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IERCU0NBTjtcclxufVxufShEQlNDQU4pKTtcblxudmFyIEtNRUFOUyA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4vKipcclxuICogS01FQU5TIGNsdXN0ZXJpbmdcclxuICpcclxuICogQGF1dGhvciBMdWthc3ogS3Jhd2N6eWsgPGNvbnRhY3RAbHVrYXN6a3Jhd2N6eWsuZXU+XHJcbiAqIEBjb3B5cmlnaHQgTUlUXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEtNRUFOUyBjbGFzcyBjb25zdHJ1Y3RvclxyXG4gKiBAY29uc3RydWN0b3JcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YXNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gayAtIG51bWJlciBvZiBjbHVzdGVyc1xyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZSAtIGRpc3RhbmNlIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtLTUVBTlN9XHJcbiAqL1xyXG4gZnVuY3Rpb24gS01FQU5TKGRhdGFzZXQsIGssIGRpc3RhbmNlKSB7XHJcbiAgdGhpcy5rID0gMzsgLy8gbnVtYmVyIG9mIGNsdXN0ZXJzXHJcbiAgdGhpcy5kYXRhc2V0ID0gW107IC8vIHNldCBvZiBmZWF0dXJlIHZlY3RvcnNcclxuICB0aGlzLmFzc2lnbm1lbnRzID0gW107IC8vIHNldCBvZiBhc3NvY2lhdGVkIGNsdXN0ZXJzIGZvciBlYWNoIGZlYXR1cmUgdmVjdG9yXHJcbiAgdGhpcy5jZW50cm9pZHMgPSBbXTsgLy8gdmVjdG9ycyBmb3Igb3VyIGNsdXN0ZXJzXHJcblxyXG4gIHRoaXMuaW5pdChkYXRhc2V0LCBrLCBkaXN0YW5jZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuS01FQU5TLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGF0YXNldCwgaywgZGlzdGFuY2UpIHtcclxuICB0aGlzLmFzc2lnbm1lbnRzID0gW107XHJcbiAgdGhpcy5jZW50cm9pZHMgPSBbXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBkYXRhc2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhpcy5kYXRhc2V0ID0gZGF0YXNldDtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgayAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRoaXMuayA9IGs7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGRpc3RhbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuS01FQU5TLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihkYXRhc2V0LCBrKSB7XHJcbiAgdGhpcy5pbml0KGRhdGFzZXQsIGspO1xyXG5cclxuICB2YXIgbGVuID0gdGhpcy5kYXRhc2V0Lmxlbmd0aDtcclxuXHJcbiAgLy8gaW5pdGlhbGl6ZSBjZW50cm9pZHNcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuazsgaSsrKSB7XHJcbiAgICB0aGlzLmNlbnRyb2lkc1tpXSA9IHRoaXMucmFuZG9tQ2VudHJvaWQoKTtcclxuXHR9XHJcblxyXG4gIHZhciBjaGFuZ2UgPSB0cnVlO1xyXG4gIHdoaWxlKGNoYW5nZSkge1xyXG5cclxuICAgIC8vIGFzc2lnbiBmZWF0dXJlIHZlY3RvcnMgdG8gY2x1c3RlcnNcclxuICAgIGNoYW5nZSA9IHRoaXMuYXNzaWduKCk7XHJcblxyXG4gICAgLy8gYWRqdXN0IGxvY2F0aW9uIG9mIGNlbnRyb2lkc1xyXG4gICAgZm9yICh2YXIgY2VudHJvaWRJZCA9IDA7IGNlbnRyb2lkSWQgPCB0aGlzLms7IGNlbnRyb2lkSWQrKykge1xyXG4gICAgICB2YXIgbWVhbiA9IG5ldyBBcnJheShtYXhEaW0pO1xyXG4gICAgICB2YXIgY291bnQgPSAwO1xyXG5cclxuICAgICAgLy8gaW5pdCBtZWFuIHZlY3RvclxyXG4gICAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBtYXhEaW07IGRpbSsrKSB7XHJcbiAgICAgICAgbWVhbltkaW1dID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgIHZhciBtYXhEaW0gPSB0aGlzLmRhdGFzZXRbal0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBpZiBjdXJyZW50IGNsdXN0ZXIgaWQgaXMgYXNzaWduZWQgdG8gcG9pbnRcclxuICAgICAgICBpZiAoY2VudHJvaWRJZCA9PT0gdGhpcy5hc3NpZ25tZW50c1tqXSkge1xyXG4gICAgICAgICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbWF4RGltOyBkaW0rKykge1xyXG4gICAgICAgICAgICBtZWFuW2RpbV0gKz0gdGhpcy5kYXRhc2V0W2pdW2RpbV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvdW50ID4gMCkge1xyXG4gICAgICAgIC8vIGlmIGNsdXN0ZXIgY29udGFpbiBwb2ludHMsIGFkanVzdCBjZW50cm9pZCBwb3NpdGlvblxyXG4gICAgICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IG1heERpbTsgZGltKyspIHtcclxuICAgICAgICAgIG1lYW5bZGltXSAvPSBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jZW50cm9pZHNbY2VudHJvaWRJZF0gPSBtZWFuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNsdXN0ZXIgaXMgZW1wdHksIGdlbmVyYXRlIG5ldyByYW5kb20gY2VudHJvaWRcclxuICAgICAgICB0aGlzLmNlbnRyb2lkc1tjZW50cm9pZElkXSA9IHRoaXMucmFuZG9tQ2VudHJvaWQoKTtcclxuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5nZXRDbHVzdGVycygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHJhbmRvbSBjZW50cm9pZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5LTUVBTlMucHJvdG90eXBlLnJhbmRvbUNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG1heElkID0gdGhpcy5kYXRhc2V0Lmxlbmd0aCAtMTtcclxuICB2YXIgY2VudHJvaWQ7XHJcbiAgdmFyIGlkO1xyXG5cclxuICBkbyB7XHJcbiAgICBpZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIG1heElkKTtcclxuICAgIGNlbnRyb2lkID0gdGhpcy5kYXRhc2V0W2lkXTtcclxuICB9IHdoaWxlICh0aGlzLmNlbnRyb2lkcy5pbmRleE9mKGNlbnRyb2lkKSA+PSAwKTtcclxuXHJcbiAgcmV0dXJuIGNlbnRyb2lkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFzc2lnbiBwb2ludHMgdG8gY2x1c3RlcnNcclxuICpcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5LTUVBTlMucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBjaGFuZ2UgPSBmYWxzZTtcclxuICB2YXIgbGVuID0gdGhpcy5kYXRhc2V0Lmxlbmd0aDtcclxuICB2YXIgY2xvc2VzdENlbnRyb2lkO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBjbG9zZXN0Q2VudHJvaWQgPSB0aGlzLmFyZ21pbih0aGlzLmRhdGFzZXRbaV0sIHRoaXMuY2VudHJvaWRzLCB0aGlzLmRpc3RhbmNlKTtcclxuXHJcbiAgICBpZiAoY2xvc2VzdENlbnRyb2lkICE9IHRoaXMuYXNzaWdubWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5hc3NpZ25tZW50c1tpXSA9IGNsb3Nlc3RDZW50cm9pZDtcclxuICAgICAgY2hhbmdlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjaGFuZ2U7XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBpbmZvcm1hdGlvbiBhYm91dCBjbHVzdGVyc1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuS01FQU5TLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gIHZhciBjZW50cm9pZElkO1xyXG5cclxuICBmb3IgKHZhciBwb2ludElkID0gMDsgcG9pbnRJZCA8IHRoaXMuYXNzaWdubWVudHMubGVuZ3RoOyBwb2ludElkKyspIHtcclxuICAgIGNlbnRyb2lkSWQgPSB0aGlzLmFzc2lnbm1lbnRzW3BvaW50SWRdO1xyXG5cclxuICAgIC8vIGluaXQgZW1wdHkgY2x1c3RlclxyXG4gICAgaWYgKHR5cGVvZiBjbHVzdGVyc1tjZW50cm9pZElkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY2x1c3RlcnNbY2VudHJvaWRJZF0gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjbHVzdGVyc1tjZW50cm9pZElkXS5wdXNoKHBvaW50SWQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsdXN0ZXJzO1xyXG59O1xyXG5cclxuLy8gdXRpbHNcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW1zIHtBcnJheX0gcG9pbnRcclxuICogQHBhcmFtcyB7QXJyYXkuPEFycmF5Pn0gc2V0XHJcbiAqIEBwYXJhbXMge0Z1bmN0aW9ufSBmXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5LTUVBTlMucHJvdG90eXBlLmFyZ21pbiA9IGZ1bmN0aW9uKHBvaW50LCBzZXQsIGYpIHtcclxuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICB2YXIgYXJnID0gMDtcclxuICB2YXIgbGVuID0gc2V0Lmxlbmd0aDtcclxuICB2YXIgZDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgZCA9IGYocG9pbnQsIHNldFtpXSk7XHJcbiAgICBpZiAoZCA8IG1pbikge1xyXG4gICAgICBtaW4gPSBkO1xyXG4gICAgICBhcmcgPSBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFyZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFdWNsaWRlYW4gZGlzdGFuY2VcclxuICpcclxuICogQHBhcmFtcyB7bnVtYmVyfSBwXHJcbiAqIEBwYXJhbXMge251bWJlcn0gcVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuS01FQU5TLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKHAsIHEpIHtcclxuICB2YXIgc3VtID0gMDtcclxuICB2YXIgaSA9IE1hdGgubWluKHAubGVuZ3RoLCBxLmxlbmd0aCk7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHZhciBkaWZmID0gcFtpXSAtIHFbaV07XHJcbiAgICBzdW0gKz0gZGlmZiAqIGRpZmY7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XHJcbn07XHJcblxyXG5pZiAobW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEtNRUFOUztcclxufVxufShLTUVBTlMpKTtcblxudmFyIE9QVElDUyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBQcmlvcml0eVF1ZXVlID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXHJcbiAqIFByaW9yaXR5UXVldWVcclxuICogRWxlbWVudHMgaW4gdGhpcyBxdWV1ZSBhcmUgc29ydGVkIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZVxyXG4gKlxyXG4gKiBAYXV0aG9yIEx1a2FzeiBLcmF3Y3p5ayA8Y29udGFjdEBsdWthc3prcmF3Y3p5ay5ldT5cclxuICogQGNvcHlyaWdodCBNSVRcclxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4vKipcclxuICogUHJpb3JpdHlRdWV1ZSBjbGFzcyBjb25zdHJ1Y290clxyXG4gKiBAY29uc3RydWN0b3JcclxuICpcclxuICogQGV4YW1wbGVcclxuICogcXVldWU6IFsxLDIsMyw0XVxyXG4gKiBwcmlvcml0aWVzOiBbNCwxLDIsM11cclxuICogPiByZXN1bHQgPSBbMSw0LDIsM11cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHNcclxuICogQHBhcmFtIHtBcnJheX0gcHJpb3JpdGllc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gc29ydGluZyAtIGFzYyAvIGRlc2NcclxuICogQHJldHVybnMge1ByaW9yaXR5UXVldWV9XHJcbiAqL1xyXG5mdW5jdGlvbiBQcmlvcml0eVF1ZXVlKGVsZW1lbnRzLCBwcmlvcml0aWVzLCBzb3J0aW5nKSB7XHJcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cclxuICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7QXJyYXl9ICovXHJcbiAgdGhpcy5fcHJpb3JpdGllcyA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gIHRoaXMuX3NvcnRpbmcgPSAnZGVzYyc7XHJcblxyXG4gIHRoaXMuX2luaXQoZWxlbWVudHMsIHByaW9yaXRpZXMsIHNvcnRpbmcpO1xyXG59XHJcbi8qKlxyXG4gKiBJbnNlcnQgZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcmlvcml0eVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAYWNjZXNzIHB1YmxpY1xyXG4gKi9cclxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlLCBwcmlvcml0eSkge1xyXG4gIHZhciBpbmRleFRvSW5zZXJ0ID0gdGhpcy5fcXVldWUubGVuZ3RoO1xyXG4gIHZhciBpbmRleCA9IGluZGV4VG9JbnNlcnQ7XHJcblxyXG4gIHdoaWxlIChpbmRleC0tKSB7XHJcbiAgICB2YXIgcHJpb3JpdHkyID0gdGhpcy5fcHJpb3JpdGllc1tpbmRleF07XHJcbiAgICBpZiAodGhpcy5fc29ydGluZyA9PT0gJ2Rlc2MnKSB7XHJcbiAgICAgIGlmIChwcmlvcml0eSA+IHByaW9yaXR5Mikge1xyXG4gICAgICAgIGluZGV4VG9JbnNlcnQgPSBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByaW9yaXR5IDwgcHJpb3JpdHkyKSB7XHJcbiAgICAgICAgaW5kZXhUb0luc2VydCA9IGluZGV4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLl9pbnNlcnRBdChlbGUsIHByaW9yaXR5LCBpbmRleFRvSW5zZXJ0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBhY2Nlc3MgcHVibGljXHJcbiAqL1xyXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGUpIHtcclxuICB2YXIgaW5kZXggPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XHJcblxyXG4gIHdoaWxlIChpbmRleC0tKSB7XHJcbiAgICB2YXIgZWxlMiA9IHRoaXMuX3F1ZXVlW2luZGV4XTtcclxuICAgIGlmIChlbGUgPT09IGVsZTIpIHtcclxuICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgdGhpcy5fcHJpb3JpdGllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yIGVhY2ggbG9vcCB3cmFwcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICogQHJldHVycyB7dW5kZWZpbmVkfVxyXG4gKiBAYWNjZXNzIHB1YmxpY1xyXG4gKi9cclxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGZ1bmMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQGFjY2VzcyBwdWJsaWNcclxuICovXHJcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuX3F1ZXVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKiBAYWNjZXNzIHB1YmxpY1xyXG4gKi9cclxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0RWxlbWVudFByaW9yaXR5ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICByZXR1cm4gdGhpcy5fcHJpb3JpdGllc1tpbmRleF07XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAYWNjZXNzIHB1YmxpY1xyXG4gKi9cclxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UHJpb3JpdGllcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLl9wcmlvcml0aWVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQGFjY2VzcyBwdWJsaWNcclxuICovXHJcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldEVsZW1lbnRzV2l0aFByaW9yaXRpZXMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICByZXN1bHQucHVzaChbdGhpcy5fcXVldWVbaV0sIHRoaXMuX3ByaW9yaXRpZXNbaV1dKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IG9iamVjdCBwcm9wZXJ0aWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHByaW9yaXRpZXNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICovXHJcblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oZWxlbWVudHMsIHByaW9yaXRpZXMsIHNvcnRpbmcpIHtcclxuXHJcbiAgaWYgKGVsZW1lbnRzICYmIHByaW9yaXRpZXMpIHtcclxuICAgIHRoaXMuX3F1ZXVlID0gW107XHJcbiAgICB0aGlzLl9wcmlvcml0aWVzID0gW107XHJcblxyXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gcHJpb3JpdGllcy5sZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5pbnNlcnQoZWxlbWVudHNbaV0sIHByaW9yaXRpZXNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHNvcnRpbmcpIHtcclxuICAgIHRoaXMuX3NvcnRpbmcgPSBzb3J0aW5nO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnQgZWxlbWVudCBhdCBnaXZlbiBwb3NpdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gKi9cclxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2luc2VydEF0ID0gZnVuY3Rpb24oZWxlLCBwcmlvcml0eSwgaW5kZXgpIHtcclxuICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSBpbmRleCkge1xyXG4gICAgdGhpcy5fcXVldWUucHVzaChlbGUpO1xyXG4gICAgdGhpcy5fcHJpb3JpdGllcy5wdXNoKHByaW9yaXR5KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAwLCBlbGUpO1xyXG4gICAgdGhpcy5fcHJpb3JpdGllcy5zcGxpY2UoaW5kZXgsIDAsIHByaW9yaXR5KTtcclxuICB9XHJcbn07XHJcblxyXG5pZiAobW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XHJcbn1cbn0oUHJpb3JpdHlRdWV1ZSkpO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuLyoqXHJcbiAqIEByZXF1aXJlcyAuL1ByaW9yaXR5UXVldWUuanNcclxuICovXHJcblxyXG5pZiAobW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgdmFyIFByaW9yaXR5UXVldWUkMSA9IFByaW9yaXR5UXVldWUuZXhwb3J0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIE9QVElDUyAtIE9yZGVyaW5nIHBvaW50cyB0byBpZGVudGlmeSB0aGUgY2x1c3RlcmluZyBzdHJ1Y3R1cmVcclxuICpcclxuICogQGF1dGhvciBMdWthc3ogS3Jhd2N6eWsgPGNvbnRhY3RAbHVrYXN6a3Jhd2N6eWsuZXU+XHJcbiAqIEBjb3B5cmlnaHQgTUlUXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE9QVElDUyBjbGFzcyBjb25zdHJ1Y3RvclxyXG4gKiBAY29uc3RydWN0b3JcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YXNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXBzaWxvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUHRzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlRnVuY3Rpb25cclxuICogQHJldHVybnMge09QVElDU31cclxuICovXHJcbmZ1bmN0aW9uIE9QVElDUyhkYXRhc2V0LCBlcHNpbG9uLCBtaW5QdHMsIGRpc3RhbmNlRnVuY3Rpb24pIHtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICB0aGlzLmVwc2lsb24gPSAxO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIHRoaXMubWluUHRzID0gMTtcclxuICAvKiogQHR5cGUge2Z1bmN0aW9ufSAqL1xyXG4gIHRoaXMuZGlzdGFuY2UgPSB0aGlzLl9ldWNsaWRlYW5EaXN0YW5jZTtcclxuXHJcbiAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlcyB1c2VkIGR1cmluZyBjb21wdXRhdGlvblxyXG5cclxuICAvKiogQHR5cGUge0FycmF5fSAqL1xyXG4gIHRoaXMuX3JlYWNoYWJpbGl0eSA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7QXJyYXl9ICovXHJcbiAgdGhpcy5fcHJvY2Vzc2VkID0gW107XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgdGhpcy5fY29yZURpc3RhbmNlID0gMDtcclxuICAvKiogQHR5cGUge0FycmF5fSAqL1xyXG4gIHRoaXMuX29yZGVyZWRMaXN0ID0gW107XHJcblxyXG4gIHRoaXMuX2luaXQoZGF0YXNldCwgZXBzaWxvbiwgbWluUHRzLCBkaXN0YW5jZUZ1bmN0aW9uKTtcclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLy8gcHVsaWMgZnVuY3Rpb25zXHJcblxyXG4vKipcclxuICogU3RhcnQgY2x1c3RlcmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBhY2Nlc3MgcHVibGljXHJcbiAqL1xyXG5PUFRJQ1MucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGRhdGFzZXQsIGVwc2lsb24sIG1pblB0cywgZGlzdGFuY2VGdW5jdGlvbikge1xyXG4gIHRoaXMuX2luaXQoZGF0YXNldCwgZXBzaWxvbiwgbWluUHRzLCBkaXN0YW5jZUZ1bmN0aW9uKTtcclxuXHJcbiAgZm9yICh2YXIgcG9pbnRJZCA9IDAsIGwgPSB0aGlzLmRhdGFzZXQubGVuZ3RoOyBwb2ludElkIDwgbDsgcG9pbnRJZCsrKSB7XHJcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2VkW3BvaW50SWRdICE9PSAxKSB7XHJcbiAgICAgIHRoaXMuX3Byb2Nlc3NlZFtwb2ludElkXSA9IDE7XHJcbiAgICAgIHRoaXMuY2x1c3RlcnMucHVzaChbcG9pbnRJZF0pO1xyXG4gICAgICB2YXIgY2x1c3RlcklkID0gdGhpcy5jbHVzdGVycy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgdGhpcy5fb3JkZXJlZExpc3QucHVzaChwb2ludElkKTtcclxuICAgICAgdmFyIHByaW9yaXR5UXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSQxKG51bGwsIG51bGwsICdhc2MnKTtcclxuICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuX3JlZ2lvblF1ZXJ5KHBvaW50SWQpO1xyXG5cclxuICAgICAgLy8gdXNpbmcgcHJpb3JpdHkgcXVldWUgYXNzaWduIGVsZW1lbnRzIHRvIG5ldyBjbHVzdGVyXHJcbiAgICAgIGlmICh0aGlzLl9kaXN0YW5jZVRvQ29yZShwb2ludElkKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUXVldWUocG9pbnRJZCwgbmVpZ2hib3JzLCBwcmlvcml0eVF1ZXVlKTtcclxuICAgICAgICB0aGlzLl9leHBhbmRDbHVzdGVyKGNsdXN0ZXJJZCwgcHJpb3JpdHlRdWV1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHJlYWNoYWJpbGl0eSBwbG90IGZvciBhbGwgcG9pbnRzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHthcnJheX1cclxuICogQGFjY2VzcyBwdWJsaWNcclxuICovXHJcbk9QVElDUy5wcm90b3R5cGUuZ2V0UmVhY2hhYmlsaXR5UGxvdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciByZWFjaGFiaWxpdHlQbG90ID0gW107XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3JkZXJlZExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgcG9pbnRJZCA9IHRoaXMuX29yZGVyZWRMaXN0W2ldO1xyXG4gICAgdmFyIGRpc3RhbmNlID0gdGhpcy5fcmVhY2hhYmlsaXR5W3BvaW50SWRdO1xyXG5cclxuICAgIHJlYWNoYWJpbGl0eVBsb3QucHVzaChbcG9pbnRJZCwgZGlzdGFuY2VdKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZWFjaGFiaWxpdHlQbG90O1xyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLy8gcHJvdGVjdGVkIGZ1bmN0aW9uc1xyXG5cclxuLyoqXHJcbiAqIFNldCBvYmplY3QgcHJvcGVydGllc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhc2V0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcHNpbG9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QdHNcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICovXHJcbk9QVElDUy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihkYXRhc2V0LCBlcHNpbG9uLCBtaW5QdHMsIGRpc3RhbmNlKSB7XHJcblxyXG4gIGlmIChkYXRhc2V0KSB7XHJcblxyXG4gICAgaWYgKCEoZGF0YXNldCBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICB0aHJvdyBFcnJvcignRGF0YXNldCBtdXN0IGJlIG9mIHR5cGUgYXJyYXksICcgK1xyXG4gICAgICAgIHR5cGVvZiBkYXRhc2V0ICsgJyBnaXZlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGF0YXNldCA9IGRhdGFzZXQ7XHJcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XHJcbiAgICB0aGlzLl9yZWFjaGFiaWxpdHkgPSBuZXcgQXJyYXkodGhpcy5kYXRhc2V0Lmxlbmd0aCk7XHJcbiAgICB0aGlzLl9wcm9jZXNzZWQgPSBuZXcgQXJyYXkodGhpcy5kYXRhc2V0Lmxlbmd0aCk7XHJcbiAgICB0aGlzLl9jb3JlRGlzdGFuY2UgPSAwO1xyXG4gICAgdGhpcy5fb3JkZXJlZExpc3QgPSBbXTtcclxuICB9XHJcblxyXG4gIGlmIChlcHNpbG9uKSB7XHJcbiAgICB0aGlzLmVwc2lsb24gPSBlcHNpbG9uO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pblB0cykge1xyXG4gICAgdGhpcy5taW5QdHMgPSBtaW5QdHM7XHJcbiAgfVxyXG5cclxuICBpZiAoZGlzdGFuY2UpIHtcclxuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlIGluZm9ybWF0aW9uIGluIHF1ZXVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludElkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xyXG4gKiBAcGFyYW0ge1ByaW9yaXR5UXVldWV9IHF1ZXVlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAqL1xyXG5PUFRJQ1MucHJvdG90eXBlLl91cGRhdGVRdWV1ZSA9IGZ1bmN0aW9uKHBvaW50SWQsIG5laWdoYm9ycywgcXVldWUpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuX2NvcmVEaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlVG9Db3JlKHBvaW50SWQpO1xyXG4gIG5laWdoYm9ycy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50SWQyKSB7XHJcbiAgICBpZiAoc2VsZi5fcHJvY2Vzc2VkW3BvaW50SWQyXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBkaXN0ID0gc2VsZi5kaXN0YW5jZShzZWxmLmRhdGFzZXRbcG9pbnRJZF0sIHNlbGYuZGF0YXNldFtwb2ludElkMl0pO1xyXG4gICAgICB2YXIgbmV3UmVhY2hhYmxlRGlzdGFuY2UgPSBNYXRoLm1heChzZWxmLl9jb3JlRGlzdGFuY2UsIGRpc3QpO1xyXG5cclxuICAgICAgaWYgKHNlbGYuX3JlYWNoYWJpbGl0eVtwb2ludElkMl0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNlbGYuX3JlYWNoYWJpbGl0eVtwb2ludElkMl0gPSBuZXdSZWFjaGFibGVEaXN0YW5jZTtcclxuICAgICAgICBxdWV1ZS5pbnNlcnQocG9pbnRJZDIsIG5ld1JlYWNoYWJsZURpc3RhbmNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobmV3UmVhY2hhYmxlRGlzdGFuY2UgPCBzZWxmLl9yZWFjaGFiaWxpdHlbcG9pbnRJZDJdKSB7XHJcbiAgICAgICAgICBzZWxmLl9yZWFjaGFiaWxpdHlbcG9pbnRJZDJdID0gbmV3UmVhY2hhYmxlRGlzdGFuY2U7XHJcbiAgICAgICAgICBxdWV1ZS5yZW1vdmUocG9pbnRJZDIpO1xyXG4gICAgICAgICAgcXVldWUuaW5zZXJ0KHBvaW50SWQyLCBuZXdSZWFjaGFibGVEaXN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwYW5kIGNsdXN0ZXJcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNsdXN0ZXJJZFxyXG4gKiBAcGFyYW0ge1ByaW9yaXR5UXVldWV9IHF1ZXVlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAqL1xyXG5PUFRJQ1MucHJvdG90eXBlLl9leHBhbmRDbHVzdGVyID0gZnVuY3Rpb24oY2x1c3RlcklkLCBxdWV1ZSkge1xyXG4gIHZhciBxdWV1ZUVsZW1lbnRzID0gcXVldWUuZ2V0RWxlbWVudHMoKTtcclxuXHJcbiAgZm9yICh2YXIgcCA9IDAsIGwgPSBxdWV1ZUVsZW1lbnRzLmxlbmd0aDsgcCA8IGw7IHArKykge1xyXG4gICAgdmFyIHBvaW50SWQgPSBxdWV1ZUVsZW1lbnRzW3BdO1xyXG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NlZFtwb2ludElkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLl9yZWdpb25RdWVyeShwb2ludElkKTtcclxuICAgICAgdGhpcy5fcHJvY2Vzc2VkW3BvaW50SWRdID0gMTtcclxuXHJcbiAgICAgIHRoaXMuY2x1c3RlcnNbY2x1c3RlcklkXS5wdXNoKHBvaW50SWQpO1xyXG4gICAgICB0aGlzLl9vcmRlcmVkTGlzdC5wdXNoKHBvaW50SWQpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlVG9Db3JlKHBvaW50SWQpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVRdWV1ZShwb2ludElkLCBuZWlnaGJvcnMsIHF1ZXVlKTtcclxuICAgICAgICB0aGlzLl9leHBhbmRDbHVzdGVyKGNsdXN0ZXJJZCwgcXVldWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0aW5nIGRpc3RhbmNlIHRvIGNsdXN0ZXIgY29yZVxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9pbnRJZFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gKi9cclxuT1BUSUNTLnByb3RvdHlwZS5fZGlzdGFuY2VUb0NvcmUgPSBmdW5jdGlvbihwb2ludElkKSB7XHJcbiAgdmFyIGwgPSB0aGlzLmVwc2lsb247XHJcbiAgZm9yICh2YXIgY29yZURpc3RDYW5kID0gMDsgY29yZURpc3RDYW5kIDwgbDsgY29yZURpc3RDYW5kKyspIHtcclxuICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLl9yZWdpb25RdWVyeShwb2ludElkLCBjb3JlRGlzdENhbmQpO1xyXG4gICAgaWYgKG5laWdoYm9ycy5sZW5ndGggPj0gdGhpcy5taW5QdHMpIHtcclxuICAgICAgcmV0dXJuIGNvcmVEaXN0Q2FuZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFsbCBuZWlnaGJvcnMgYXJvdW5kIGdpdmVuIHBvaW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludElkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcHNpbG9uXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICovXHJcbk9QVElDUy5wcm90b3R5cGUuX3JlZ2lvblF1ZXJ5ID0gZnVuY3Rpb24ocG9pbnRJZCwgZXBzaWxvbikge1xyXG4gIGVwc2lsb24gPSBlcHNpbG9uIHx8IHRoaXMuZXBzaWxvbjtcclxuICB2YXIgbmVpZ2hib3JzID0gW107XHJcblxyXG4gIGZvciAodmFyIGlkID0gMCwgbCA9IHRoaXMuZGF0YXNldC5sZW5ndGg7IGlkIDwgbDsgaWQrKykge1xyXG4gICAgaWYgKHRoaXMuZGlzdGFuY2UodGhpcy5kYXRhc2V0W3BvaW50SWRdLCB0aGlzLmRhdGFzZXRbaWRdKSA8IGVwc2lsb24pIHtcclxuICAgICAgbmVpZ2hib3JzLnB1c2goaWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5laWdoYm9ycztcclxufTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8vIGhlbHBlcnNcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgZXVjbGlkZWFuIGRpc3RhbmNlIGluIG11bHRpZGltZW5zaW9uYWwgc3BhY2VcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gcFxyXG4gKiBAcGFyYW0ge0FycmF5fSBxXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAqL1xyXG5PUFRJQ1MucHJvdG90eXBlLl9ldWNsaWRlYW5EaXN0YW5jZSA9IGZ1bmN0aW9uKHAsIHEpIHtcclxuICB2YXIgc3VtID0gMDtcclxuICB2YXIgaSA9IE1hdGgubWluKHAubGVuZ3RoLCBxLmxlbmd0aCk7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHN1bSArPSAocFtpXSAtIHFbaV0pICogKHBbaV0gLSBxW2ldKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcclxufTtcclxuXHJcbmlmIChtb2R1bGUuZXhwb3J0cykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gT1BUSUNTO1xyXG59XG59KE9QVElDUykpO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuaWYgKG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgREJTQ0FOOiBEQlNDQU4uZXhwb3J0cyxcclxuICAgICAgS01FQU5TOiBLTUVBTlMuZXhwb3J0cyxcclxuICAgICAgT1BUSUNTOiBPUFRJQ1MuZXhwb3J0cyxcclxuICAgICAgUHJpb3JpdHlRdWV1ZTogUHJpb3JpdHlRdWV1ZS5leHBvcnRzXHJcbiAgICB9O1xyXG59XG59KGxpYikpO1xuXG52YXIgY2x1c3RlcmluZyA9IGxpYi5leHBvcnRzO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBwYXJ0aXRpb24gdGhlbSBpbnRvIGNsdXN0ZXJzIGFjY29yZGluZyB0byB7QGxpbmsgREJTQ0FOJ3N8aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvREJTQ0FOfSBkYXRhIGNsdXN0ZXJpbmcgYWxnb3JpdGhtLlxuICpcbiAqIEBuYW1lIGNsdXN0ZXJzRGJzY2FuXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gcG9pbnRzIHRvIGJlIGNsdXN0ZXJlZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heERpc3RhbmNlIE1heGltdW0gRGlzdGFuY2UgYmV0d2VlbiBhbnkgcG9pbnQgb2YgdGhlIGNsdXN0ZXIgdG8gZ2VuZXJhdGUgdGhlIGNsdXN0ZXJzIChraWxvbWV0ZXJzIG9ubHkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51bml0cz1cImtpbG9tZXRlcnNcIl0gaW4gd2hpY2ggYG1heERpc3RhbmNlYCBpcyBleHByZXNzZWQsIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5tdXRhdGU9ZmFsc2VdIEFsbG93cyBHZW9KU09OIGlucHV0IHRvIGJlIG11dGF0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5Qb2ludHM9M10gTWluaW11bSBudW1iZXIgb2YgcG9pbnRzIHRvIGdlbmVyYXRlIGEgc2luZ2xlIGNsdXN0ZXIsXG4gKiBwb2ludHMgd2hpY2ggZG8gbm90IG1lZXQgdGhpcyByZXF1aXJlbWVudCB3aWxsIGJlIGNsYXNzaWZpZWQgYXMgYW4gJ2VkZ2UnIG9yICdub2lzZScuXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBDbHVzdGVyZWQgUG9pbnRzIHdpdGggYW4gYWRkaXRpb25hbCB0d28gcHJvcGVydGllcyBhc3NvY2lhdGVkIHRvIGVhY2ggRmVhdHVyZTpcbiAqIC0ge251bWJlcn0gY2x1c3RlciAtIHRoZSBhc3NvY2lhdGVkIGNsdXN0ZXJJZFxuICogLSB7c3RyaW5nfSBkYnNjYW4gLSB0eXBlIG9mIHBvaW50IGl0IGhhcyBiZWVuIGNsYXNzaWZpZWQgYXMgKCdjb3JlJ3wnZWRnZSd8J25vaXNlJylcbiAqIEBleGFtcGxlXG4gKiAvLyBjcmVhdGUgcmFuZG9tIHBvaW50cyB3aXRoIHJhbmRvbSB6LXZhbHVlcyBpbiB0aGVpciBwcm9wZXJ0aWVzXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5yYW5kb21Qb2ludCgxMDAsIHtiYm94OiBbMCwgMzAsIDIwLCA1MF19KTtcbiAqIHZhciBtYXhEaXN0YW5jZSA9IDEwMDtcbiAqIHZhciBjbHVzdGVyZWQgPSB0dXJmLmNsdXN0ZXJzRGJzY2FuKHBvaW50cywgbWF4RGlzdGFuY2UpO1xuICpcbiAqIC8vYWRkVG9NYXBcbiAqIHZhciBhZGRUb01hcCA9IFtjbHVzdGVyZWRdO1xuICovXG5mdW5jdGlvbiBjbHVzdGVyc0Ric2Nhbihwb2ludHMsIG1heERpc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgLy8gSW5wdXQgdmFsaWRhdGlvbiBiZWluZyBoYW5kbGVkIGJ5IFR5cGVzY3JpcHRcbiAgICAvLyBjb2xsZWN0aW9uT2YocG9pbnRzLCAnUG9pbnQnLCAncG9pbnRzIG11c3QgY29uc2lzdCBvZiBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIG9ubHkgUG9pbnRzJyk7XG4gICAgLy8gaWYgKG1heERpc3RhbmNlID09PSBudWxsIHx8IG1heERpc3RhbmNlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignbWF4RGlzdGFuY2UgaXMgcmVxdWlyZWQnKTtcbiAgICAvLyBpZiAoIShNYXRoLnNpZ24obWF4RGlzdGFuY2UpID4gMCkpIHRocm93IG5ldyBFcnJvcignbWF4RGlzdGFuY2UgaXMgaW52YWxpZCcpO1xuICAgIC8vIGlmICghKG1pblBvaW50cyA9PT0gdW5kZWZpbmVkIHx8IG1pblBvaW50cyA9PT0gbnVsbCB8fCBNYXRoLnNpZ24obWluUG9pbnRzKSA+IDApKSB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMubWluUG9pbnRzIGlzIGludmFsaWQnKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIENsb25lIHBvaW50cyB0byBwcmV2ZW50IGFueSBtdXRhdGlvbnNcbiAgICBpZiAob3B0aW9ucy5tdXRhdGUgIT09IHRydWUpXG4gICAgICAgIHBvaW50cyA9IGNsb25lKHBvaW50cyk7XG4gICAgLy8gRGVmYXVsdHNcbiAgICBvcHRpb25zLm1pblBvaW50cyA9IG9wdGlvbnMubWluUG9pbnRzIHx8IDM7XG4gICAgLy8gY3JlYXRlIGNsdXN0ZXJlZCBpZHNcbiAgICB2YXIgZGJzY2FuID0gbmV3IGNsdXN0ZXJpbmcuREJTQ0FOKCk7XG4gICAgdmFyIGNsdXN0ZXJlZElkcyA9IGRic2Nhbi5ydW4oY29vcmRBbGwocG9pbnRzKSwgY29udmVydExlbmd0aChtYXhEaXN0YW5jZSwgb3B0aW9ucy51bml0cyksIG9wdGlvbnMubWluUG9pbnRzLCBkaXN0YW5jZSk7XG4gICAgLy8gVGFnIHBvaW50cyB0byBDbHVzdGVycyBJRFxuICAgIHZhciBjbHVzdGVySWQgPSAtMTtcbiAgICBjbHVzdGVyZWRJZHMuZm9yRWFjaChmdW5jdGlvbiAoY2x1c3Rlcklkcykge1xuICAgICAgICBjbHVzdGVySWQrKztcbiAgICAgICAgLy8gYXNzaWduIGNsdXN0ZXIgaWRzIHRvIGlucHV0IHBvaW50c1xuICAgICAgICBjbHVzdGVySWRzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXJQb2ludCA9IHBvaW50cy5mZWF0dXJlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKCFjbHVzdGVyUG9pbnQucHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBjbHVzdGVyUG9pbnQucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgY2x1c3RlclBvaW50LnByb3BlcnRpZXMuY2x1c3RlciA9IGNsdXN0ZXJJZDtcbiAgICAgICAgICAgIGNsdXN0ZXJQb2ludC5wcm9wZXJ0aWVzLmRic2NhbiA9IFwiY29yZVwiO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBoYW5kbGUgbm9pc2UgcG9pbnRzLCBpZiBhbnlcbiAgICAvLyBlZGdlcyBwb2ludHMgYXJlIHRhZ2dlZCBieSBEQlNDQU4gYXMgYm90aCAnbm9pc2UnIGFuZCAnY2x1c3RlcicgYXMgdGhleSBjYW4gXCJyZWFjaFwiIGxlc3MgdGhhbiAnbWluUG9pbnRzJyBudW1iZXIgb2YgcG9pbnRzXG4gICAgZGJzY2FuLm5vaXNlLmZvckVhY2goZnVuY3Rpb24gKG5vaXNlSWQpIHtcbiAgICAgICAgdmFyIG5vaXNlUG9pbnQgPSBwb2ludHMuZmVhdHVyZXNbbm9pc2VJZF07XG4gICAgICAgIGlmICghbm9pc2VQb2ludC5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbm9pc2VQb2ludC5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmIChub2lzZVBvaW50LnByb3BlcnRpZXMuY2x1c3RlcilcbiAgICAgICAgICAgIG5vaXNlUG9pbnQucHJvcGVydGllcy5kYnNjYW4gPSBcImVkZ2VcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbm9pc2VQb2ludC5wcm9wZXJ0aWVzLmRic2NhbiA9IFwibm9pc2VcIjtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG52YXIgc3VwZXJjbHVzdGVyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA7XG59KShjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uICgpIHtcbmZ1bmN0aW9uIHNvcnRLRChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIGxlZnQsIHJpZ2h0LCBkZXB0aCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgbSA9IChsZWZ0ICsgcmlnaHQpID4+IDE7XG5cbiAgICBzZWxlY3QoaWRzLCBjb29yZHMsIG0sIGxlZnQsIHJpZ2h0LCBkZXB0aCAlIDIpO1xuXG4gICAgc29ydEtEKGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbGVmdCwgbSAtIDEsIGRlcHRoICsgMSk7XG4gICAgc29ydEtEKGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbSArIDEsIHJpZ2h0LCBkZXB0aCArIDEpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3QoaWRzLCBjb29yZHMsIGssIGxlZnQsIHJpZ2h0LCBpbmMpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBzZWxlY3QoaWRzLCBjb29yZHMsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBpbmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBjb29yZHNbMiAqIGsgKyBpbmNdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29vcmRzWzIgKiByaWdodCArIGluY10gPiB0KSB7IHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCByaWdodCk7IH1cblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb29yZHNbMiAqIGkgKyBpbmNdIDwgdCkgeyBpKys7IH1cbiAgICAgICAgICAgIHdoaWxlIChjb29yZHNbMiAqIGogKyBpbmNdID4gdCkgeyBqLS07IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb29yZHNbMiAqIGxlZnQgKyBpbmNdID09PSB0KSB7IHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCBqKTsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSB7IGxlZnQgPSBqICsgMTsgfVxuICAgICAgICBpZiAoayA8PSBqKSB7IHJpZ2h0ID0gaiAtIDE7IH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXBJdGVtKGlkcywgY29vcmRzLCBpLCBqKSB7XG4gICAgc3dhcChpZHMsIGksIGopO1xuICAgIHN3YXAoY29vcmRzLCAyICogaSwgMiAqIGopO1xuICAgIHN3YXAoY29vcmRzLCAyICogaSArIDEsIDIgKiBqICsgMSk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiByYW5nZShpZHMsIGNvb3JkcywgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgbm9kZVNpemUpIHtcbiAgICB2YXIgc3RhY2sgPSBbMCwgaWRzLmxlbmd0aCAtIDEsIDBdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgeCwgeTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGF4aXMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBub2RlU2l6ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBjb29yZHNbMiAqIGldO1xuICAgICAgICAgICAgICAgIHkgPSBjb29yZHNbMiAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSB7IHJlc3VsdC5wdXNoKGlkc1tpXSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG5cbiAgICAgICAgeCA9IGNvb3Jkc1syICogbV07XG4gICAgICAgIHkgPSBjb29yZHNbMiAqIG0gKyAxXTtcblxuICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSB7IHJlc3VsdC5wdXNoKGlkc1ttXSk7IH1cblxuICAgICAgICB2YXIgbmV4dEF4aXMgPSAoYXhpcyArIDEpICUgMjtcblxuICAgICAgICBpZiAoYXhpcyA9PT0gMCA/IG1pblggPD0geCA6IG1pblkgPD0geSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobSAtIDEpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBtYXhYID49IHggOiBtYXhZID49IHkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobSArIDEpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChyaWdodCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5leHRBeGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihpZHMsIGNvb3JkcywgcXgsIHF5LCByLCBub2RlU2l6ZSkge1xuICAgIHZhciBzdGFjayA9IFswLCBpZHMubGVuZ3RoIC0gMSwgMF07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciByMiA9IHIgKiByO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXhpcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNxRGlzdChjb29yZHNbMiAqIGldLCBjb29yZHNbMiAqIGkgKyAxXSwgcXgsIHF5KSA8PSByMikgeyByZXN1bHQucHVzaChpZHNbaV0pOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuXG4gICAgICAgIHZhciB4ID0gY29vcmRzWzIgKiBtXTtcbiAgICAgICAgdmFyIHkgPSBjb29yZHNbMiAqIG0gKyAxXTtcblxuICAgICAgICBpZiAoc3FEaXN0KHgsIHksIHF4LCBxeSkgPD0gcjIpIHsgcmVzdWx0LnB1c2goaWRzW21dKTsgfVxuXG4gICAgICAgIHZhciBuZXh0QXhpcyA9IChheGlzICsgMSkgJSAyO1xuXG4gICAgICAgIGlmIChheGlzID09PSAwID8gcXggLSByIDw9IHggOiBxeSAtIHIgPD0geSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobSAtIDEpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBxeCArIHIgPj0geCA6IHF5ICsgciA+PSB5KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG0gKyAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocmlnaHQpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzcURpc3QoYXgsIGF5LCBieCwgYnkpIHtcbiAgICB2YXIgZHggPSBheCAtIGJ4O1xuICAgIHZhciBkeSA9IGF5IC0gYnk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG52YXIgZGVmYXVsdEdldFggPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfTtcbnZhciBkZWZhdWx0R2V0WSA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwWzFdOyB9O1xuXG52YXIgS0RCdXNoID0gZnVuY3Rpb24gS0RCdXNoKHBvaW50cywgZ2V0WCwgZ2V0WSwgbm9kZVNpemUsIEFycmF5VHlwZSkge1xuICAgIGlmICggZ2V0WCA9PT0gdm9pZCAwICkgZ2V0WCA9IGRlZmF1bHRHZXRYO1xuICAgIGlmICggZ2V0WSA9PT0gdm9pZCAwICkgZ2V0WSA9IGRlZmF1bHRHZXRZO1xuICAgIGlmICggbm9kZVNpemUgPT09IHZvaWQgMCApIG5vZGVTaXplID0gNjQ7XG4gICAgaWYgKCBBcnJheVR5cGUgPT09IHZvaWQgMCApIEFycmF5VHlwZSA9IEZsb2F0NjRBcnJheTtcblxuICAgIHRoaXMubm9kZVNpemUgPSBub2RlU2l6ZTtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIHZhciBJbmRleEFycmF5VHlwZSA9IHBvaW50cy5sZW5ndGggPCA2NTUzNiA/IFVpbnQxNkFycmF5IDogVWludDMyQXJyYXk7XG5cbiAgICB2YXIgaWRzID0gdGhpcy5pZHMgPSBuZXcgSW5kZXhBcnJheVR5cGUocG9pbnRzLmxlbmd0aCk7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzID0gbmV3IEFycmF5VHlwZShwb2ludHMubGVuZ3RoICogMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZHNbaV0gPSBpO1xuICAgICAgICBjb29yZHNbMiAqIGldID0gZ2V0WChwb2ludHNbaV0pO1xuICAgICAgICBjb29yZHNbMiAqIGkgKyAxXSA9IGdldFkocG9pbnRzW2ldKTtcbiAgICB9XG5cbiAgICBzb3J0S0QoaWRzLCBjb29yZHMsIG5vZGVTaXplLCAwLCBpZHMubGVuZ3RoIC0gMSwgMCk7XG59O1xuXG5LREJ1c2gucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UkMSAobWluWCwgbWluWSwgbWF4WCwgbWF4WSkge1xuICAgIHJldHVybiByYW5nZSh0aGlzLmlkcywgdGhpcy5jb29yZHMsIG1pblgsIG1pblksIG1heFgsIG1heFksIHRoaXMubm9kZVNpemUpO1xufTtcblxuS0RCdXNoLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiB3aXRoaW4kMSAoeCwgeSwgcikge1xuICAgIHJldHVybiB3aXRoaW4odGhpcy5pZHMsIHRoaXMuY29vcmRzLCB4LCB5LCByLCB0aGlzLm5vZGVTaXplKTtcbn07XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtaW5ab29tOiAwLCAgIC8vIG1pbiB6b29tIHRvIGdlbmVyYXRlIGNsdXN0ZXJzIG9uXG4gICAgbWF4Wm9vbTogMTYsICAvLyBtYXggem9vbSBsZXZlbCB0byBjbHVzdGVyIHRoZSBwb2ludHMgb25cbiAgICBtaW5Qb2ludHM6IDIsIC8vIG1pbmltdW0gcG9pbnRzIHRvIGZvcm0gYSBjbHVzdGVyXG4gICAgcmFkaXVzOiA0MCwgICAvLyBjbHVzdGVyIHJhZGl1cyBpbiBwaXhlbHNcbiAgICBleHRlbnQ6IDUxMiwgIC8vIHRpbGUgZXh0ZW50IChyYWRpdXMgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBpdClcbiAgICBub2RlU2l6ZTogNjQsIC8vIHNpemUgb2YgdGhlIEtELXRyZWUgbGVhZiBub2RlLCBhZmZlY3RzIHBlcmZvcm1hbmNlXG4gICAgbG9nOiBmYWxzZSwgICAvLyB3aGV0aGVyIHRvIGxvZyB0aW1pbmcgaW5mb1xuXG4gICAgLy8gd2hldGhlciB0byBnZW5lcmF0ZSBudW1lcmljIGlkcyBmb3IgaW5wdXQgZmVhdHVyZXMgKGluIHZlY3RvciB0aWxlcylcbiAgICBnZW5lcmF0ZUlkOiBmYWxzZSxcblxuICAgIC8vIGEgcmVkdWNlIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyBjdXN0b20gY2x1c3RlciBwcm9wZXJ0aWVzXG4gICAgcmVkdWNlOiBudWxsLCAvLyAoYWNjdW11bGF0ZWQsIHByb3BzKSA9PiB7IGFjY3VtdWxhdGVkLnN1bSArPSBwcm9wcy5zdW07IH1cblxuICAgIC8vIHByb3BlcnRpZXMgdG8gdXNlIGZvciBpbmRpdmlkdWFsIHBvaW50cyB3aGVuIHJ1bm5pbmcgdGhlIHJlZHVjZXJcbiAgICBtYXA6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gcHJvcHM7IH0gLy8gcHJvcHMgPT4gKHtzdW06IHByb3BzLm15X3ZhbHVlfSlcbn07XG5cbnZhciBmcm91bmQgPSBNYXRoLmZyb3VuZCB8fCAoZnVuY3Rpb24gKHRtcCkgeyByZXR1cm4gKGZ1bmN0aW9uICh4KSB7IHRtcFswXSA9ICt4OyByZXR1cm4gdG1wWzBdOyB9KTsgfSkobmV3IEZsb2F0MzJBcnJheSgxKSk7XG5cbnZhciBTdXBlcmNsdXN0ZXIgPSBmdW5jdGlvbiBTdXBlcmNsdXN0ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZChPYmplY3QuY3JlYXRlKGRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdGhpcy50cmVlcyA9IG5ldyBBcnJheSh0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAocG9pbnRzKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGxvZyA9IHJlZi5sb2c7XG4gICAgICAgIHZhciBtaW5ab29tID0gcmVmLm1pblpvb207XG4gICAgICAgIHZhciBtYXhab29tID0gcmVmLm1heFpvb207XG4gICAgICAgIHZhciBub2RlU2l6ZSA9IHJlZi5ub2RlU2l6ZTtcblxuICAgIGlmIChsb2cpIHsgY29uc29sZS50aW1lKCd0b3RhbCB0aW1lJyk7IH1cblxuICAgIHZhciB0aW1lcklkID0gXCJwcmVwYXJlIFwiICsgKHBvaW50cy5sZW5ndGgpICsgXCIgcG9pbnRzXCI7XG4gICAgaWYgKGxvZykgeyBjb25zb2xlLnRpbWUodGltZXJJZCk7IH1cblxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgLy8gZ2VuZXJhdGUgYSBjbHVzdGVyIG9iamVjdCBmb3IgZWFjaCBwb2ludCBhbmQgaW5kZXggaW5wdXQgcG9pbnRzIGludG8gYSBLRC10cmVlXG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFwb2ludHNbaV0uZ2VvbWV0cnkpIHsgY29udGludWU7IH1cbiAgICAgICAgY2x1c3RlcnMucHVzaChjcmVhdGVQb2ludENsdXN0ZXIocG9pbnRzW2ldLCBpKSk7XG4gICAgfVxuICAgIHRoaXMudHJlZXNbbWF4Wm9vbSArIDFdID0gbmV3IEtEQnVzaChjbHVzdGVycywgZ2V0WCwgZ2V0WSwgbm9kZVNpemUsIEZsb2F0MzJBcnJheSk7XG5cbiAgICBpZiAobG9nKSB7IGNvbnNvbGUudGltZUVuZCh0aW1lcklkKTsgfVxuXG4gICAgLy8gY2x1c3RlciBwb2ludHMgb24gbWF4IHpvb20sIHRoZW4gY2x1c3RlciB0aGUgcmVzdWx0cyBvbiBwcmV2aW91cyB6b29tLCBldGMuO1xuICAgIC8vIHJlc3VsdHMgaW4gYSBjbHVzdGVyIGhpZXJhcmNoeSBhY3Jvc3Mgem9vbSBsZXZlbHNcbiAgICBmb3IgKHZhciB6ID0gbWF4Wm9vbTsgeiA+PSBtaW5ab29tOyB6LS0pIHtcbiAgICAgICAgdmFyIG5vdyA9ICtEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzZXQgb2YgY2x1c3RlcnMgZm9yIHRoZSB6b29tIGFuZCBpbmRleCB0aGVtIHdpdGggYSBLRC10cmVlXG4gICAgICAgIGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcihjbHVzdGVycywgeik7XG4gICAgICAgIHRoaXMudHJlZXNbel0gPSBuZXcgS0RCdXNoKGNsdXN0ZXJzLCBnZXRYLCBnZXRZLCBub2RlU2l6ZSwgRmxvYXQzMkFycmF5KTtcblxuICAgICAgICBpZiAobG9nKSB7IGNvbnNvbGUubG9nKCd6JWQ6ICVkIGNsdXN0ZXJzIGluICVkbXMnLCB6LCBjbHVzdGVycy5sZW5ndGgsICtEYXRlLm5vdygpIC0gbm93KTsgfVxuICAgIH1cblxuICAgIGlmIChsb2cpIHsgY29uc29sZS50aW1lRW5kKCd0b3RhbCB0aW1lJyk7IH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uIGdldENsdXN0ZXJzIChiYm94LCB6b29tKSB7XG4gICAgdmFyIG1pbkxuZyA9ICgoYmJveFswXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIHZhciBtaW5MYXQgPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBiYm94WzFdKSk7XG4gICAgdmFyIG1heExuZyA9IGJib3hbMl0gPT09IDE4MCA/IDE4MCA6ICgoYmJveFsyXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIHZhciBtYXhMYXQgPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBiYm94WzNdKSk7XG5cbiAgICBpZiAoYmJveFsyXSAtIGJib3hbMF0gPj0gMzYwKSB7XG4gICAgICAgIG1pbkxuZyA9IC0xODA7XG4gICAgICAgIG1heExuZyA9IDE4MDtcbiAgICB9IGVsc2UgaWYgKG1pbkxuZyA+IG1heExuZykge1xuICAgICAgICB2YXIgZWFzdGVybkhlbSA9IHRoaXMuZ2V0Q2x1c3RlcnMoW21pbkxuZywgbWluTGF0LCAxODAsIG1heExhdF0sIHpvb20pO1xuICAgICAgICB2YXIgd2VzdGVybkhlbSA9IHRoaXMuZ2V0Q2x1c3RlcnMoWy0xODAsIG1pbkxhdCwgbWF4TG5nLCBtYXhMYXRdLCB6b29tKTtcbiAgICAgICAgcmV0dXJuIGVhc3Rlcm5IZW0uY29uY2F0KHdlc3Rlcm5IZW0pO1xuICAgIH1cblxuICAgIHZhciB0cmVlID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oem9vbSldO1xuICAgIHZhciBpZHMgPSB0cmVlLnJhbmdlKGxuZ1gobWluTG5nKSwgbGF0WShtYXhMYXQpLCBsbmdYKG1heExuZyksIGxhdFkobWluTGF0KSk7XG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBpZHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBpZCA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIHZhciBjID0gdHJlZS5wb2ludHNbaWRdO1xuICAgICAgICBjbHVzdGVycy5wdXNoKGMubnVtUG9pbnRzID8gZ2V0Q2x1c3RlckpTT04oYykgOiB0aGlzLnBvaW50c1tjLmluZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiBjbHVzdGVycztcbn07XG5cblN1cGVyY2x1c3Rlci5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbiAoY2x1c3RlcklkKSB7XG4gICAgdmFyIG9yaWdpbklkID0gdGhpcy5fZ2V0T3JpZ2luSWQoY2x1c3RlcklkKTtcbiAgICB2YXIgb3JpZ2luWm9vbSA9IHRoaXMuX2dldE9yaWdpblpvb20oY2x1c3RlcklkKTtcbiAgICB2YXIgZXJyb3JNc2cgPSAnTm8gY2x1c3RlciB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuJztcblxuICAgIHZhciBpbmRleCA9IHRoaXMudHJlZXNbb3JpZ2luWm9vbV07XG4gICAgaWYgKCFpbmRleCkgeyB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpOyB9XG5cbiAgICB2YXIgb3JpZ2luID0gaW5kZXgucG9pbnRzW29yaWdpbklkXTtcbiAgICBpZiAoIW9yaWdpbikgeyB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpOyB9XG5cbiAgICB2YXIgciA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyAodGhpcy5vcHRpb25zLmV4dGVudCAqIE1hdGgucG93KDIsIG9yaWdpblpvb20gLSAxKSk7XG4gICAgdmFyIGlkcyA9IGluZGV4LndpdGhpbihvcmlnaW4ueCwgb3JpZ2luLnksIHIpO1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaWRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgaWQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICB2YXIgYyA9IGluZGV4LnBvaW50c1tpZF07XG4gICAgICAgIGlmIChjLnBhcmVudElkID09PSBjbHVzdGVySWQpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYy5udW1Qb2ludHMgPyBnZXRDbHVzdGVySlNPTihjKSA6IHRoaXMucG9pbnRzW2MuaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTsgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5nZXRMZWF2ZXMgPSBmdW5jdGlvbiBnZXRMZWF2ZXMgKGNsdXN0ZXJJZCwgbGltaXQsIG9mZnNldCkge1xuICAgIGxpbWl0ID0gbGltaXQgfHwgMTA7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICB2YXIgbGVhdmVzID0gW107XG4gICAgdGhpcy5fYXBwZW5kTGVhdmVzKGxlYXZlcywgY2x1c3RlcklkLCBsaW1pdCwgb2Zmc2V0LCAwKTtcblxuICAgIHJldHVybiBsZWF2ZXM7XG59O1xuXG5TdXBlcmNsdXN0ZXIucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5KSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW3RoaXMuX2xpbWl0Wm9vbSh6KV07XG4gICAgdmFyIHoyID0gTWF0aC5wb3coMiwgeik7XG4gICAgdmFyIHJlZiA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGV4dGVudCA9IHJlZi5leHRlbnQ7XG4gICAgICAgIHZhciByYWRpdXMgPSByZWYucmFkaXVzO1xuICAgIHZhciBwID0gcmFkaXVzIC8gZXh0ZW50O1xuICAgIHZhciB0b3AgPSAoeSAtIHApIC8gejI7XG4gICAgdmFyIGJvdHRvbSA9ICh5ICsgMSArIHApIC8gejI7XG5cbiAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhcbiAgICAgICAgdHJlZS5yYW5nZSgoeCAtIHApIC8gejIsIHRvcCwgKHggKyAxICsgcCkgLyB6MiwgYm90dG9tKSxcbiAgICAgICAgdHJlZS5wb2ludHMsIHgsIHksIHoyLCB0aWxlKTtcblxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhcbiAgICAgICAgICAgIHRyZWUucmFuZ2UoMSAtIHAgLyB6MiwgdG9wLCAxLCBib3R0b20pLFxuICAgICAgICAgICAgdHJlZS5wb2ludHMsIHoyLCB5LCB6MiwgdGlsZSk7XG4gICAgfVxuICAgIGlmICh4ID09PSB6MiAtIDEpIHtcbiAgICAgICAgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKFxuICAgICAgICAgICAgdHJlZS5yYW5nZSgwLCB0b3AsIHAgLyB6MiwgYm90dG9tKSxcbiAgICAgICAgICAgIHRyZWUucG9pbnRzLCAtMSwgeSwgejIsIHRpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aWxlLmZlYXR1cmVzLmxlbmd0aCA/IHRpbGUgOiBudWxsO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbSA9IGZ1bmN0aW9uIGdldENsdXN0ZXJFeHBhbnNpb25ab29tIChjbHVzdGVySWQpIHtcbiAgICB2YXIgZXhwYW5zaW9uWm9vbSA9IHRoaXMuX2dldE9yaWdpblpvb20oY2x1c3RlcklkKSAtIDE7XG4gICAgd2hpbGUgKGV4cGFuc2lvblpvb20gPD0gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbihjbHVzdGVySWQpO1xuICAgICAgICBleHBhbnNpb25ab29tKys7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHsgYnJlYWs7IH1cbiAgICAgICAgY2x1c3RlcklkID0gY2hpbGRyZW5bMF0ucHJvcGVydGllcy5jbHVzdGVyX2lkO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5zaW9uWm9vbTtcbn07XG5cblN1cGVyY2x1c3Rlci5wcm90b3R5cGUuX2FwcGVuZExlYXZlcyA9IGZ1bmN0aW9uIF9hcHBlbmRMZWF2ZXMgKHJlc3VsdCwgY2x1c3RlcklkLCBsaW1pdCwgb2Zmc2V0LCBza2lwcGVkKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbihjbHVzdGVySWQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjaGlsZHJlbjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgdmFyIHByb3BzID0gY2hpbGQucHJvcGVydGllcztcblxuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMuY2x1c3Rlcikge1xuICAgICAgICAgICAgaWYgKHNraXBwZWQgKyBwcm9wcy5wb2ludF9jb3VudCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSB3aG9sZSBjbHVzdGVyXG4gICAgICAgICAgICAgICAgc2tpcHBlZCArPSBwcm9wcy5wb2ludF9jb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZW50ZXIgdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gdGhpcy5fYXBwZW5kTGVhdmVzKHJlc3VsdCwgcHJvcHMuY2x1c3Rlcl9pZCwgbGltaXQsIG9mZnNldCwgc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgLy8gZXhpdCB0aGUgY2x1c3RlclxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNraXBwZWQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHNraXAgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIHNpbmdsZSBwb2ludFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSBsaW1pdCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIHJldHVybiBza2lwcGVkO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5fYWRkVGlsZUZlYXR1cmVzID0gZnVuY3Rpb24gX2FkZFRpbGVGZWF0dXJlcyAoaWRzLCBwb2ludHMsIHgsIHksIHoyLCB0aWxlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IGlkczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBpID0gbGlzdFtpJDFdO1xuXG4gICAgICAgICAgICB2YXIgYyA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGlzQ2x1c3RlciA9IGMubnVtUG9pbnRzO1xuXG4gICAgICAgIHZhciB0YWdzID0gKHZvaWQgMCksIHB4ID0gKHZvaWQgMCksIHB5ID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChpc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIHRhZ3MgPSBnZXRDbHVzdGVyUHJvcGVydGllcyhjKTtcbiAgICAgICAgICAgIHB4ID0gYy54O1xuICAgICAgICAgICAgcHkgPSBjLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzW2MuaW5kZXhdO1xuICAgICAgICAgICAgdGFncyA9IHAucHJvcGVydGllcztcbiAgICAgICAgICAgIHB4ID0gbG5nWChwLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcbiAgICAgICAgICAgIHB5ID0gbGF0WShwLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0ge1xuICAgICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBbW1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChweCAqIHoyIC0geCkpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChweSAqIHoyIC0geSkpXG4gICAgICAgICAgICBdXSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhc3NpZ24gaWRcbiAgICAgICAgdmFyIGlkID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChpc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIGlkID0gYy5pZDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2VuZXJhdGVJZCkge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBnZW5lcmF0ZSBpZFxuICAgICAgICAgICAgaWQgPSBjLmluZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG9pbnRzW2MuaW5kZXhdLmlkKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGlkIGlmIGFscmVhZHkgYXNzaWduZWRcbiAgICAgICAgICAgIGlkID0gdGhpcy5wb2ludHNbYy5pbmRleF0uaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkgeyBmLmlkID0gaWQ7IH1cblxuICAgICAgICB0aWxlLmZlYXR1cmVzLnB1c2goZik7XG4gICAgfVxufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5fbGltaXRab29tID0gZnVuY3Rpb24gX2xpbWl0Wm9vbSAoeikge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluWm9vbSwgTWF0aC5taW4oK3osIHRoaXMub3B0aW9ucy5tYXhab29tICsgMSkpO1xufTtcblxuU3VwZXJjbHVzdGVyLnByb3RvdHlwZS5fY2x1c3RlciA9IGZ1bmN0aW9uIF9jbHVzdGVyIChwb2ludHMsIHpvb20pIHtcbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICB2YXIgcmVmID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgcmFkaXVzID0gcmVmLnJhZGl1cztcbiAgICAgICAgdmFyIGV4dGVudCA9IHJlZi5leHRlbnQ7XG4gICAgICAgIHZhciByZWR1Y2UgPSByZWYucmVkdWNlO1xuICAgICAgICB2YXIgbWluUG9pbnRzID0gcmVmLm1pblBvaW50cztcbiAgICB2YXIgciA9IHJhZGl1cyAvIChleHRlbnQgKiBNYXRoLnBvdygyLCB6b29tKSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlIHBvaW50IGF0IHRoaXMgem9vbSBsZXZlbCwgc2tpcCBpdFxuICAgICAgICBpZiAocC56b29tIDw9IHpvb20pIHsgY29udGludWU7IH1cbiAgICAgICAgcC56b29tID0gem9vbTtcblxuICAgICAgICAvLyBmaW5kIGFsbCBuZWFyYnkgcG9pbnRzXG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlc1t6b29tICsgMV07XG4gICAgICAgIHZhciBuZWlnaGJvcklkcyA9IHRyZWUud2l0aGluKHAueCwgcC55LCByKTtcblxuICAgICAgICB2YXIgbnVtUG9pbnRzT3JpZ2luID0gcC5udW1Qb2ludHMgfHwgMTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IG51bVBvaW50c09yaWdpbjtcblxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvdGVudGlhbCBjbHVzdGVyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSBuZWlnaGJvcklkczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3JJZCA9IGxpc3RbaSQxXTtcblxuICAgICAgICAgICAgICAgIHZhciBiID0gdHJlZS5wb2ludHNbbmVpZ2hib3JJZF07XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IG5laWdoYm9ycyB0aGF0IGFyZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgaWYgKGIuem9vbSA+IHpvb20pIHsgbnVtUG9pbnRzICs9IGIubnVtUG9pbnRzIHx8IDE7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdlcmUgbmVpZ2hib3JzIHRvIG1lcmdlLCBhbmQgdGhlcmUgYXJlIGVub3VnaCBwb2ludHMgdG8gZm9ybSBhIGNsdXN0ZXJcbiAgICAgICAgaWYgKG51bVBvaW50cyA+IG51bVBvaW50c09yaWdpbiAmJiBudW1Qb2ludHMgPj0gbWluUG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgd3ggPSBwLnggKiBudW1Qb2ludHNPcmlnaW47XG4gICAgICAgICAgICB2YXIgd3kgPSBwLnkgKiBudW1Qb2ludHNPcmlnaW47XG5cbiAgICAgICAgICAgIHZhciBjbHVzdGVyUHJvcGVydGllcyA9IHJlZHVjZSAmJiBudW1Qb2ludHNPcmlnaW4gPiAxID8gdGhpcy5fbWFwKHAsIHRydWUpIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gZW5jb2RlIGJvdGggem9vbSBhbmQgcG9pbnQgaW5kZXggb24gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZCAtLSBvZmZzZXQgYnkgdG90YWwgbGVuZ3RoIG9mIGZlYXR1cmVzXG4gICAgICAgICAgICB2YXIgaWQgPSAoaSA8PCA1KSArICh6b29tICsgMSkgKyB0aGlzLnBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMSA9IG5laWdoYm9ySWRzOyBpJDIgPCBsaXN0JDEubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvcklkJDEgPSBsaXN0JDFbaSQyXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYiQxID0gdHJlZS5wb2ludHNbbmVpZ2hib3JJZCQxXTtcblxuICAgICAgICAgICAgICAgIGlmIChiJDEuem9vbSA8PSB6b29tKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgYiQxLnpvb20gPSB6b29tOyAvLyBzYXZlIHRoZSB6b29tIChzbyBpdCBkb2Vzbid0IGdldCBwcm9jZXNzZWQgdHdpY2UpXG5cbiAgICAgICAgICAgICAgICB2YXIgbnVtUG9pbnRzMiA9IGIkMS5udW1Qb2ludHMgfHwgMTtcbiAgICAgICAgICAgICAgICB3eCArPSBiJDEueCAqIG51bVBvaW50czI7IC8vIGFjY3VtdWxhdGUgY29vcmRpbmF0ZXMgZm9yIGNhbGN1bGF0aW5nIHdlaWdodGVkIGNlbnRlclxuICAgICAgICAgICAgICAgIHd5ICs9IGIkMS55ICogbnVtUG9pbnRzMjtcblxuICAgICAgICAgICAgICAgIGIkMS5wYXJlbnRJZCA9IGlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsdXN0ZXJQcm9wZXJ0aWVzKSB7IGNsdXN0ZXJQcm9wZXJ0aWVzID0gdGhpcy5fbWFwKHAsIHRydWUpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZShjbHVzdGVyUHJvcGVydGllcywgdGhpcy5fbWFwKGIkMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXJlbnRJZCA9IGlkO1xuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChjcmVhdGVDbHVzdGVyKHd4IC8gbnVtUG9pbnRzLCB3eSAvIG51bVBvaW50cywgaWQsIG51bVBvaW50cywgY2x1c3RlclByb3BlcnRpZXMpKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBsZWZ0IHBvaW50cyBhcyB1bmNsdXN0ZXJlZFxuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChwKTtcblxuICAgICAgICAgICAgaWYgKG51bVBvaW50cyA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwLCBsaXN0JDIgPSBuZWlnaGJvcklkczsgaSQzIDwgbGlzdCQyLmxlbmd0aDsgaSQzICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9ySWQkMiA9IGxpc3QkMltpJDNdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiQyID0gdHJlZS5wb2ludHNbbmVpZ2hib3JJZCQyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIkMi56b29tIDw9IHpvb20pIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgYiQyLnpvb20gPSB6b29tO1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKGIkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxuLy8gZ2V0IGluZGV4IG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRoZSBjbHVzdGVyIG9yaWdpbmF0ZWRcblN1cGVyY2x1c3Rlci5wcm90b3R5cGUuX2dldE9yaWdpbklkID0gZnVuY3Rpb24gX2dldE9yaWdpbklkIChjbHVzdGVySWQpIHtcbiAgICByZXR1cm4gKGNsdXN0ZXJJZCAtIHRoaXMucG9pbnRzLmxlbmd0aCkgPj4gNTtcbn07XG5cbi8vIGdldCB6b29tIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRoZSBjbHVzdGVyIG9yaWdpbmF0ZWRcblN1cGVyY2x1c3Rlci5wcm90b3R5cGUuX2dldE9yaWdpblpvb20gPSBmdW5jdGlvbiBfZ2V0T3JpZ2luWm9vbSAoY2x1c3RlcklkKSB7XG4gICAgcmV0dXJuIChjbHVzdGVySWQgLSB0aGlzLnBvaW50cy5sZW5ndGgpICUgMzI7XG59O1xuXG5TdXBlcmNsdXN0ZXIucHJvdG90eXBlLl9tYXAgPSBmdW5jdGlvbiBfbWFwIChwb2ludCwgY2xvbmUpIHtcbiAgICBpZiAocG9pbnQubnVtUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBjbG9uZSA/IGV4dGVuZCh7fSwgcG9pbnQucHJvcGVydGllcykgOiBwb2ludC5wcm9wZXJ0aWVzO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnBvaW50c1twb2ludC5pbmRleF0ucHJvcGVydGllcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm1hcChvcmlnaW5hbCk7XG4gICAgcmV0dXJuIGNsb25lICYmIHJlc3VsdCA9PT0gb3JpZ2luYWwgPyBleHRlbmQoe30sIHJlc3VsdCkgOiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDbHVzdGVyKHgsIHksIGlkLCBudW1Qb2ludHMsIHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBmcm91bmQoeCksIC8vIHdlaWdodGVkIGNsdXN0ZXIgY2VudGVyOyByb3VuZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBGbG9hdDMyQXJyYXkgaW5kZXhcbiAgICAgICAgeTogZnJvdW5kKHkpLFxuICAgICAgICB6b29tOiBJbmZpbml0eSwgLy8gdGhlIGxhc3Qgem9vbSB0aGUgY2x1c3RlciB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICAgIGlkOiBpZCwgLy8gZW5jb2RlcyBpbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGNsdXN0ZXIgYW5kIGl0cyB6b29tIGxldmVsXG4gICAgICAgIHBhcmVudElkOiAtMSwgLy8gcGFyZW50IGNsdXN0ZXIgaWRcbiAgICAgICAgbnVtUG9pbnRzOiBudW1Qb2ludHMsXG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludENsdXN0ZXIocCwgaWQpIHtcbiAgICB2YXIgcmVmID0gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB2YXIgeCA9IHJlZlswXTtcbiAgICB2YXIgeSA9IHJlZlsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBmcm91bmQobG5nWCh4KSksIC8vIHByb2plY3RlZCBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICB5OiBmcm91bmQobGF0WSh5KSksXG4gICAgICAgIHpvb206IEluZmluaXR5LCAvLyB0aGUgbGFzdCB6b29tIHRoZSBwb2ludCB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICAgIGluZGV4OiBpZCwgLy8gaW5kZXggb2YgdGhlIHNvdXJjZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBhcnJheSxcbiAgICAgICAgcGFyZW50SWQ6IC0xIC8vIHBhcmVudCBjbHVzdGVyIGlkXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlckpTT04oY2x1c3Rlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgaWQ6IGNsdXN0ZXIuaWQsXG4gICAgICAgIHByb3BlcnRpZXM6IGdldENsdXN0ZXJQcm9wZXJ0aWVzKGNsdXN0ZXIpLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbeExuZyhjbHVzdGVyLngpLCB5TGF0KGNsdXN0ZXIueSldXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbHVzdGVyUHJvcGVydGllcyhjbHVzdGVyKSB7XG4gICAgdmFyIGNvdW50ID0gY2x1c3Rlci5udW1Qb2ludHM7XG4gICAgdmFyIGFiYnJldiA9XG4gICAgICAgIGNvdW50ID49IDEwMDAwID8gKChNYXRoLnJvdW5kKGNvdW50IC8gMTAwMCkpICsgXCJrXCIpIDpcbiAgICAgICAgY291bnQgPj0gMTAwMCA/ICgoTWF0aC5yb3VuZChjb3VudCAvIDEwMCkgLyAxMCkgKyBcImtcIikgOiBjb3VudDtcbiAgICByZXR1cm4gZXh0ZW5kKGV4dGVuZCh7fSwgY2x1c3Rlci5wcm9wZXJ0aWVzKSwge1xuICAgICAgICBjbHVzdGVyOiB0cnVlLFxuICAgICAgICBjbHVzdGVyX2lkOiBjbHVzdGVyLmlkLFxuICAgICAgICBwb2ludF9jb3VudDogY291bnQsXG4gICAgICAgIHBvaW50X2NvdW50X2FiYnJldmlhdGVkOiBhYmJyZXZcbiAgICB9KTtcbn1cblxuLy8gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIHNwaGVyaWNhbCBtZXJjYXRvciBpbiBbMC4uMV0gcmFuZ2VcbmZ1bmN0aW9uIGxuZ1gobG5nKSB7XG4gICAgcmV0dXJuIGxuZyAvIDM2MCArIDAuNTtcbn1cbmZ1bmN0aW9uIGxhdFkobGF0KSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKGxhdCAqIE1hdGguUEkgLyAxODApO1xuICAgIHZhciB5ID0gKDAuNSAtIDAuMjUgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gTWF0aC5QSSk7XG4gICAgcmV0dXJuIHkgPCAwID8gMCA6IHkgPiAxID8gMSA6IHk7XG59XG5cbi8vIHNwaGVyaWNhbCBtZXJjYXRvciB0byBsb25naXR1ZGUvbGF0aXR1ZGVcbmZ1bmN0aW9uIHhMbmcoeCkge1xuICAgIHJldHVybiAoeCAtIDAuNSkgKiAzNjA7XG59XG5mdW5jdGlvbiB5TGF0KHkpIHtcbiAgICB2YXIgeTIgPSAoMTgwIC0geSAqIDM2MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHJldHVybiAzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIpKSAvIE1hdGguUEkgLSA5MDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGlkIGluIHNyYykgeyBkZXN0W2lkXSA9IHNyY1tpZF07IH1cbiAgICByZXR1cm4gZGVzdDtcbn1cblxuZnVuY3Rpb24gZ2V0WChwKSB7XG4gICAgcmV0dXJuIHAueDtcbn1cbmZ1bmN0aW9uIGdldFkocCkge1xuICAgIHJldHVybiBwLnk7XG59XG5cbnJldHVybiBTdXBlcmNsdXN0ZXI7XG5cbn0pKTtcbn0oc3VwZXJjbHVzdGVyKSk7XG5cbnZhciBTdXBlckNsdXN0ZXIgPSBzdXBlcmNsdXN0ZXIuZXhwb3J0cztcblxudmFyIGVzNiA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKChhIGluc3RhbmNlb2YgTWFwKSAmJiAoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWIuaGFzKGlbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghZXF1YWwoaVsxXSwgYi5nZXQoaVswXSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKGEgaW5zdGFuY2VvZiBTZXQpICYmIChiIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghYi5oYXMoaVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBDbHVzdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgbWFya2VycywgcG9zaXRpb24gfSkge1xyXG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMubGVuZ3RoID09PSAwICYmICF0aGlzLl9wb3NpdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzLnJlZHVjZSgoYm91bmRzLCBtYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcy5leHRlbmQobWFya2VyLmdldFBvc2l0aW9uKCkpO1xyXG4gICAgICAgIH0sIG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5fcG9zaXRpb24sIHRoaXMuX3Bvc2l0aW9uKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uIHx8IHRoaXMuYm91bmRzLmdldENlbnRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvdW50IG9mICoqdmlzaWJsZSoqIG1hcmtlcnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzLmZpbHRlcigobSkgPT4gbS5nZXRWaXNpYmxlKCkpXHJcbiAgICAgICAgICAgIC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIG1hcmtlciB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqL1xyXG4gICAgcHVzaChtYXJrZXIpIHtcclxuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnVwIHJlZmVyZW5jZXMgYW5kIHJlbW92ZSBtYXJrZXIgZnJvbSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFya2Vycy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGZpbHRlck1hcmtlcnNUb1BhZGRlZFZpZXdwb3J0ID0gKG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgbWFya2Vycywgdmlld3BvcnRQYWRkaW5nKSA9PiB7XHJcbiAgICBjb25zdCBleHRlbmRlZE1hcEJvdW5kcyA9IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQobWFwLmdldEJvdW5kcygpLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB2aWV3cG9ydFBhZGRpbmcpO1xyXG4gICAgcmV0dXJuIG1hcmtlcnMuZmlsdGVyKChtYXJrZXIpID0+IGV4dGVuZGVkTWFwQm91bmRzLmNvbnRhaW5zKG1hcmtlci5nZXRQb3NpdGlvbigpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBFeHRlbmRzIGEgYm91bmRzIGJ5IGEgbnVtYmVyIG9mIHBpeGVscyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICovXHJcbmNvbnN0IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQgPSAoYm91bmRzLCBwcm9qZWN0aW9uLCBwaXhlbHMpID0+IHtcclxuICAgIGNvbnN0IHsgbm9ydGhFYXN0LCBzb3V0aFdlc3QgfSA9IGxhdExuZ0JvdW5kc1RvUGl4ZWxCb3VuZHMoYm91bmRzLCBwcm9qZWN0aW9uKTtcclxuICAgIGNvbnN0IGV4dGVuZGVkUGl4ZWxCb3VuZHMgPSBleHRlbmRQaXhlbEJvdW5kcyh7IG5vcnRoRWFzdCwgc291dGhXZXN0IH0sIHBpeGVscyk7XHJcbiAgICByZXR1cm4gcGl4ZWxCb3VuZHNUb0xhdExuZ0JvdW5kcyhleHRlbmRlZFBpeGVsQm91bmRzLCBwcm9qZWN0aW9uKTtcclxufTtcclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNvbnN0IGRpc3RhbmNlQmV0d2VlblBvaW50cyA9IChwMSwgcDIpID0+IHtcclxuICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIEVhcnRoIGluIGttXHJcbiAgICBjb25zdCBkTGF0ID0gKChwMi5sYXQgLSBwMS5sYXQpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICBjb25zdCBkTG9uID0gKChwMi5sbmcgLSBwMS5sbmcpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICBjb25zdCBhID0gTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcclxuICAgICAgICBNYXRoLmNvcygocDEubGF0ICogTWF0aC5QSSkgLyAxODApICpcclxuICAgICAgICAgICAgTWF0aC5jb3MoKHAyLmxhdCAqIE1hdGguUEkpIC8gMTgwKSAqXHJcbiAgICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKSAqXHJcbiAgICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKTtcclxuICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgcmV0dXJuIFIgKiBjO1xyXG59O1xyXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cclxuY29uc3QgbGF0TG5nQm91bmRzVG9QaXhlbEJvdW5kcyA9IChib3VuZHMsIHByb2plY3Rpb24pID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9ydGhFYXN0OiBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXROb3J0aEVhc3QoKSksXHJcbiAgICAgICAgc291dGhXZXN0OiBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSksXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cclxuY29uc3QgZXh0ZW5kUGl4ZWxCb3VuZHMgPSAoeyBub3J0aEVhc3QsIHNvdXRoV2VzdCB9LCBwaXhlbHMpID0+IHtcclxuICAgIG5vcnRoRWFzdC54ICs9IHBpeGVscztcclxuICAgIG5vcnRoRWFzdC55IC09IHBpeGVscztcclxuICAgIHNvdXRoV2VzdC54IC09IHBpeGVscztcclxuICAgIHNvdXRoV2VzdC55ICs9IHBpeGVscztcclxuICAgIHJldHVybiB7IG5vcnRoRWFzdCwgc291dGhXZXN0IH07XHJcbn07XHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5jb25zdCBwaXhlbEJvdW5kc1RvTGF0TG5nQm91bmRzID0gKHsgbm9ydGhFYXN0LCBzb3V0aFdlc3QgfSwgcHJvamVjdGlvbikgPT4ge1xyXG4gICAgY29uc3QgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xyXG4gICAgYm91bmRzLmV4dGVuZChwcm9qZWN0aW9uLmZyb21EaXZQaXhlbFRvTGF0TG5nKG5vcnRoRWFzdCkpO1xyXG4gICAgYm91bmRzLmV4dGVuZChwcm9qZWN0aW9uLmZyb21EaXZQaXhlbFRvTGF0TG5nKHNvdXRoV2VzdCkpO1xyXG4gICAgcmV0dXJuIGJvdW5kcztcclxufTtcblxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0QWxnb3JpdGhtIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgbWF4Wm9vbSA9IDE2IH0pIHtcclxuICAgICAgICB0aGlzLm1heFpvb20gPSBtYXhab29tO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnlwYXNzIGNsdXN0ZXJpbmcgYmFzZWQgdXBvbiBzb21lIG1hcCBzdGF0ZSBzdWNoIGFzXHJcbiAgICAgKiB6b29tLCBudW1iZXIgb2YgbWFya2VycywgZXRjLlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqICBjbHVzdGVyKHttYXJrZXJzLCBtYXB9OiBBbGdvcml0aG1JbnB1dCk6IENsdXN0ZXJbXSB7XHJcbiAgICAgKiAgICBpZiAoc2hvdWxkQnlwYXNzQ2x1c3RlcmluZyhtYXApKSB7XHJcbiAgICAgKiAgICAgIHJldHVybiB0aGlzLm5vb3Aoe21hcmtlcnMsIG1hcH0pXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgbm9vcCh7IG1hcmtlcnMgfSkge1xyXG4gICAgICAgIHJldHVybiBub29wJDEobWFya2Vycyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFic3RyYWN0IHZpZXdwb3J0IGFsZ29yaXRobSBwcm92ZXMgYSBjbGFzcyB0byBmaWx0ZXIgbWFya2VycyBieSBhIHBhZGRlZFxyXG4gKiB2aWV3cG9ydC4gVGhpcyBpcyBhIGNvbW1vbiBvcHRpbWl6YXRpb24uXHJcbiAqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IHZpZXdwb3J0UGFkZGluZyA9IDYwIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1widmlld3BvcnRQYWRkaW5nXCJdKTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0UGFkZGluZyA9IDYwO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRQYWRkaW5nID0gdmlld3BvcnRQYWRkaW5nO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlKHsgbWFya2VycywgbWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB9KSB7XHJcbiAgICAgICAgaWYgKG1hcC5nZXRab29tKCkgPj0gdGhpcy5tYXhab29tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyczogdGhpcy5ub29wKHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcCxcclxuICAgICAgICAgICAgICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMuY2x1c3Rlcih7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcclxuICAgICAgICAgICAgICAgIG1hcCxcclxuICAgICAgICAgICAgICAgIG1hcENhbnZhc1Byb2plY3Rpb24sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNvbnN0IG5vb3AkMSA9IChtYXJrZXJzKSA9PiB7XHJcbiAgICBjb25zdCBjbHVzdGVycyA9IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IG5ldyBDbHVzdGVyKHtcclxuICAgICAgICBwb3NpdGlvbjogbWFya2VyLmdldFBvc2l0aW9uKCksXHJcbiAgICAgICAgbWFya2VyczogW21hcmtlcl0sXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gY2x1c3RlcnM7XHJcbn07XG5cbi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBHcmlkIGFsZ29yaXRobSBoaXN0b3JpY2FsbHkgdXNlZCBpbiBHb29nbGUgTWFwcyBtYXJrZXJcclxuICogY2x1c3RlcmluZy5cclxuICpcclxuICogVGhlIEdyaWQgYWxnb3JpdGhtIGRvZXMgbm90IGltcGxlbWVudCBjYWNoaW5nIGFuZCBtYXJrZXJzIG1heSBmbGFzaCBhcyB0aGVcclxuICogdmlld3BvcnQgY2hhbmdlcy4gSW5zdGVhZCB1c2Uge0BsaW5rIFN1cGVyQ2x1c3RlckFsZ29yaXRobX0uXHJcbiAqL1xyXG5jbGFzcyBHcmlkQWxnb3JpdGhtIGV4dGVuZHMgQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IG1heERpc3RhbmNlID0gNDAwMDAsIGdyaWRTaXplID0gNDAgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJtYXhEaXN0YW5jZVwiLCBcImdyaWRTaXplXCJdKTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcclxuICAgIH1cclxuICAgIGNsdXN0ZXIoeyBtYXJrZXJzLCBtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIH0pIHtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XHJcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyKG1hcmtlciwgbWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcclxuICAgIH1cclxuICAgIGFkZFRvQ2xvc2VzdENsdXN0ZXIobWFya2VyLCBtYXAsIHByb2plY3Rpb24pIHtcclxuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlOyAvLyBTb21lIGxhcmdlIG51bWJlclxyXG4gICAgICAgIGxldCBjbHVzdGVyID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5jbHVzdGVyc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY2FuZGlkYXRlLmJvdW5kcy5nZXRDZW50ZXIoKS50b0pTT04oKSwgbWFya2VyLmdldFBvc2l0aW9uKCkudG9KU09OKCkpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsdXN0ZXIgJiZcclxuICAgICAgICAgICAgZXh0ZW5kQm91bmRzVG9QYWRkZWRWaWV3cG9ydChjbHVzdGVyLmJvdW5kcywgcHJvamVjdGlvbiwgdGhpcy5ncmlkU2l6ZSkuY29udGFpbnMobWFya2VyLmdldFBvc2l0aW9uKCkpKSB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXIucHVzaChtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2x1c3RlciA9IG5ldyBDbHVzdGVyKHsgbWFya2VyczogW21hcmtlcl0gfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcnMucHVzaChjbHVzdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE5vb3AgYWxnb3JpdGhtIGRvZXMgbm90IGdlbmVyYXRlIGFueSBjbHVzdGVycyBvciBmaWx0ZXIgbWFya2VycyBieSB0aGUgYW4gZXh0ZW5kZWQgdmlld3BvcnQuXHJcbiAqL1xyXG5jbGFzcyBOb29wQWxnb3JpdGhtIGV4dGVuZHMgQWJzdHJhY3RBbGdvcml0aG0ge1xyXG4gICAgY29uc3RydWN0b3IoX2EpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IF9fcmVzdChfYSwgW10pO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlKHsgbWFya2VycywgbWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMuY2x1c3Rlcih7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiB9KSxcclxuICAgICAgICAgICAgY2hhbmdlZDogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNsdXN0ZXIoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub29wKGlucHV0KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXhwZXJpbWVudGFsIGFsZ29yaXRobSB1c2luZyBLbWVhbnMuXHJcbiAqXHJcbiAqIFRoZSBHcmlkIGFsZ29yaXRobSBkb2VzIG5vdCBpbXBsZW1lbnQgY2FjaGluZyBhbmQgbWFya2VycyBtYXkgZmxhc2ggYXMgdGhlXHJcbiAqIHZpZXdwb3J0IGNoYW5nZXMuIEluc3RlYWQgdXNlIHtAbGluayBTdXBlckNsdXN0ZXJBbGdvcml0aG19LlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0B0dXJmL2NsdXN0ZXJzLWttZWFuc1xyXG4gKi9cclxuY2xhc3MgS21lYW5zQWxnb3JpdGhtIGV4dGVuZHMgQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IG51bWJlck9mQ2x1c3RlcnMgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJudW1iZXJPZkNsdXN0ZXJzXCJdKTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm51bWJlck9mQ2x1c3RlcnMgPSBudW1iZXJPZkNsdXN0ZXJzO1xyXG4gICAgfVxyXG4gICAgY2x1c3Rlcih7IG1hcmtlcnMsIG1hcCB9KSB7XHJcbiAgICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXTtcclxuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb2ludHMgPSBmZWF0dXJlQ29sbGVjdGlvbihtYXJrZXJzLm1hcCgobWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludChbbWFya2VyLmdldFBvc2l0aW9uKCkubG5nKCksIG1hcmtlci5nZXRQb3NpdGlvbigpLmxhdCgpXSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGxldCBudW1iZXJPZkNsdXN0ZXJzO1xyXG4gICAgICAgIGlmICh0aGlzLm51bWJlck9mQ2x1c3RlcnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICBudW1iZXJPZkNsdXN0ZXJzID0gdGhpcy5udW1iZXJPZkNsdXN0ZXJzKG1hcmtlcnMubGVuZ3RoLCBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG51bWJlck9mQ2x1c3RlcnMgPSB0aGlzLm51bWJlck9mQ2x1c3RlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsdXN0ZXJzS21lYW5zKHBvaW50cywgeyBudW1iZXJPZkNsdXN0ZXJzIH0pLmZlYXR1cmVzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2x1c3RlcnNbcG9pbnQucHJvcGVydGllcy5jbHVzdGVyXSkge1xyXG4gICAgICAgICAgICAgICAgY2x1c3RlcnNbcG9pbnQucHJvcGVydGllcy5jbHVzdGVyXSA9IG5ldyBDbHVzdGVyKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsbmc6IHBvaW50LnByb3BlcnRpZXMuY2VudHJvaWRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogcG9pbnQucHJvcGVydGllcy5jZW50cm9pZFsxXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2x1c3RlcnNbcG9pbnQucHJvcGVydGllcy5jbHVzdGVyXS5wdXNoKG1hcmtlcnNbaV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjbHVzdGVycztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0lOVEVSTkFMX0RCU0NBTl9PUFRJT04gPSB7XHJcbiAgICB1bml0czogXCJraWxvbWV0ZXJzXCIsXHJcbiAgICBtdXRhdGU6IGZhbHNlLFxyXG4gICAgbWluUG9pbnRzOiAxLFxyXG59O1xyXG4vKipcclxuICpcclxuICogKipUaGlzIGFsZ29yaXRobSBpcyBub3QgeWV0IHJlYWR5IGZvciB1c2UhKipcclxuICpcclxuICogRXhwZXJpbWVudGFsIGFsZ29yaXRobSB1c2luZyBEQlNjYW4uXHJcbiAqXHJcbiAqIFRoZSBHcmlkIGFsZ29yaXRobSBkb2VzIG5vdCBpbXBsZW1lbnQgY2FjaGluZyBhbmQgbWFya2VycyBtYXkgZmxhc2ggYXMgdGhlXHJcbiAqIHZpZXdwb3J0IGNoYW5nZXMuIEluc3RlYWQgdXNlIHtAbGluayBTdXBlckNsdXN0ZXJBbGdvcml0aG19LlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0B0dXJmL2NsdXN0ZXJzLWRic2NhblxyXG4gKi9cclxuY2xhc3MgREJTY2FuQWxnb3JpdGhtIGV4dGVuZHMgQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IG1heERpc3RhbmNlID0gMjAwLCBtaW5Qb2ludHMgPSBERUZBVUxUX0lOVEVSTkFMX0RCU0NBTl9PUFRJT04ubWluUG9pbnRzIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wibWF4RGlzdGFuY2VcIiwgXCJtaW5Qb2ludHNcIl0pO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfSU5URVJOQUxfREJTQ0FOX09QVElPTiksIHsgbWluUG9pbnRzIH0pO1xyXG4gICAgfVxyXG4gICAgY2x1c3Rlcih7IG1hcmtlcnMsIG1hcENhbnZhc1Byb2plY3Rpb24sIH0pIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBmZWF0dXJlQ29sbGVjdGlvbihtYXJrZXJzLm1hcCgobWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RlZFBvaW50ID0gbWFwQ2FudmFzUHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbChtYXJrZXIuZ2V0UG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludChbcHJvamVjdGVkUG9pbnQueCwgcHJvamVjdGVkUG9pbnQueV0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBncm91cGVkID0gW107XHJcbiAgICAgICAgY2x1c3RlcnNEYnNjYW4ocG9pbnRzLCB0aGlzLm1heERpc3RhbmNlLCB0aGlzLm9wdGlvbnMpLmZlYXR1cmVzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZ3JvdXBlZFtwb2ludC5wcm9wZXJ0aWVzLmNsdXN0ZXJdKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cGVkW3BvaW50LnByb3BlcnRpZXMuY2x1c3Rlcl0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncm91cGVkW3BvaW50LnByb3BlcnRpZXMuY2x1c3Rlcl0ucHVzaChtYXJrZXJzW2ldKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBlZC5tYXAoKG1hcmtlcnMpID0+IG5ldyBDbHVzdGVyKHsgbWFya2VycyB9KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdmVyeSBmYXN0IEphdmFTY3JpcHQgYWxnb3JpdGhtIGZvciBnZW9zcGF0aWFsIHBvaW50IGNsdXN0ZXJpbmcgdXNpbmcgS0QgdHJlZXMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3VwZXJjbHVzdGVyIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBTdXBlckNsdXN0ZXJBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IG1heFpvb20sIHJhZGl1cyA9IDYwIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wibWF4Wm9vbVwiLCBcInJhZGl1c1wiXSk7XHJcbiAgICAgICAgc3VwZXIoeyBtYXhab29tIH0pO1xyXG4gICAgICAgIHRoaXMuc3VwZXJDbHVzdGVyID0gbmV3IFN1cGVyQ2x1c3RlcihPYmplY3QuYXNzaWduKHsgbWF4Wm9vbTogdGhpcy5tYXhab29tLCByYWRpdXMgfSwgb3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IHpvb206IG51bGwgfTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZShpbnB1dCkge1xyXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFlczYoaW5wdXQubWFya2VycywgdGhpcy5tYXJrZXJzKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gVE9ETyB1c2UgcHJveHkgdG8gYXZvaWQgY29weT9cclxuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gWy4uLmlucHV0Lm1hcmtlcnNdO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLm1hcmtlcnMubWFwKChtYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLmdldFBvc2l0aW9uKCkubG5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sYXQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgbWFya2VyIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zdXBlckNsdXN0ZXIubG9hZChwb2ludHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgem9vbTogaW5wdXQubWFwLmdldFpvb20oKSB9O1xyXG4gICAgICAgIGlmICghY2hhbmdlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS56b29tID4gdGhpcy5tYXhab29tICYmIHN0YXRlLnpvb20gPiB0aGlzLm1heFpvb20pIDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCAhZXM2KHRoaXMuc3RhdGUsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jbHVzdGVycyA9IHRoaXMuY2x1c3RlcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGNsdXN0ZXJzOiB0aGlzLmNsdXN0ZXJzLCBjaGFuZ2VkIH07XHJcbiAgICB9XHJcbiAgICBjbHVzdGVyKHsgbWFwIH0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsdXN0ZXJcclxuICAgICAgICAgICAgLmdldENsdXN0ZXJzKFstMTgwLCAtOTAsIDE4MCwgOTBdLCBtYXAuZ2V0Wm9vbSgpKVxyXG4gICAgICAgICAgICAubWFwKHRoaXMudHJhbnNmb3JtQ2x1c3Rlci5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybUNsdXN0ZXIoeyBnZW9tZXRyeTogeyBjb29yZGluYXRlczogW2xuZywgbGF0XSwgfSwgcHJvcGVydGllcywgfSkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsdXN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbHVzdGVyKHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcnM6IHRoaXMuc3VwZXJDbHVzdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldExlYXZlcyhwcm9wZXJ0aWVzLmNsdXN0ZXJfaWQsIEluZmluaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGxlYWYpID0+IGxlYWYucHJvcGVydGllcy5tYXJrZXIpLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeyBsYXQsIGxuZyB9KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBwcm9wZXJ0aWVzLm1hcmtlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbHVzdGVyKHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcnM6IFttYXJrZXJdLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG1hcmtlci5nZXRQb3NpdGlvbigpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHN0YXRpc3RpY3Mgb24gYWxsIGNsdXN0ZXJzIGluIHRoZSBjdXJyZW50IHJlbmRlciBjeWNsZSBmb3IgdXNlIGluIHtAbGluayBSZW5kZXJlci5yZW5kZXJ9LlxyXG4gKi9cclxuY2xhc3MgQ2x1c3RlclN0YXRzIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcmtlcnMsIGNsdXN0ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzID0geyBzdW06IG1hcmtlcnMubGVuZ3RoIH07XHJcbiAgICAgICAgY29uc3QgY2x1c3Rlck1hcmtlckNvdW50cyA9IGNsdXN0ZXJzLm1hcCgoYSkgPT4gYS5jb3VudCk7XHJcbiAgICAgICAgY29uc3QgY2x1c3Rlck1hcmtlclN1bSA9IGNsdXN0ZXJNYXJrZXJDb3VudHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IHtcclxuICAgICAgICAgICAgY291bnQ6IGNsdXN0ZXJzLmxlbmd0aCxcclxuICAgICAgICAgICAgbWFya2Vyczoge1xyXG4gICAgICAgICAgICAgICAgbWVhbjogY2x1c3Rlck1hcmtlclN1bSAvIGNsdXN0ZXJzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHN1bTogY2x1c3Rlck1hcmtlclN1bSxcclxuICAgICAgICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4uY2x1c3Rlck1hcmtlckNvdW50cyksXHJcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLmNsdXN0ZXJNYXJrZXJDb3VudHMpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmYXVsdFJlbmRlcmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgbGlicmFyeSB1c2VkIGJ5IHtAbGluayBNYXJrZXJDbHVzdGVyZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEN1cnJlbnRseSBzZXQgdG8gdXNlIHRoZSBmb2xsb3dpbmc6XHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gY2hhbmdlIGNvbG9yIGlmIHRoaXMgY2x1c3RlciBoYXMgbW9yZSBtYXJrZXJzIHRoYW4gdGhlIG1lYW4gY2x1c3RlclxyXG4gICAgICogY29uc3QgY29sb3IgPVxyXG4gICAgICogICBjb3VudCA+IE1hdGgubWF4KDEwLCBzdGF0cy5jbHVzdGVycy5tYXJrZXJzLm1lYW4pXHJcbiAgICAgKiAgICAgPyBcIiNmZjAwMDBcIlxyXG4gICAgICogICAgIDogXCIjMDAwMGZmXCI7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3JlYXRlIHN2ZyB1cmwgd2l0aCBmaWxsIGNvbG9yXHJcbiAgICAgKiBjb25zdCBzdmcgPSB3aW5kb3cuYnRvYShgXHJcbiAgICAgKiA8c3ZnIGZpbGw9XCIke2NvbG9yfVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0MCAyNDBcIj5cclxuICAgICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi42XCIgcj1cIjcwXCIgLz5cclxuICAgICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4zXCIgcj1cIjkwXCIgLz5cclxuICAgICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4yXCIgcj1cIjExMFwiIC8+XHJcbiAgICAgKiAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuMVwiIHI9XCIxMzBcIiAvPlxyXG4gICAgICogPC9zdmc+YCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3JlYXRlIG1hcmtlciB1c2luZyBzdmcgaWNvblxyXG4gICAgICogcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xyXG4gICAgICogICBwb3NpdGlvbixcclxuICAgICAqICAgaWNvbjoge1xyXG4gICAgICogICAgIHVybDogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtzdmd9YCxcclxuICAgICAqICAgICBzY2FsZWRTaXplOiBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSg0NSwgNDUpLFxyXG4gICAgICogICB9LFxyXG4gICAgICogICBsYWJlbDoge1xyXG4gICAgICogICAgIHRleHQ6IFN0cmluZyhjb3VudCksXHJcbiAgICAgKiAgICAgY29sb3I6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCIsXHJcbiAgICAgKiAgICAgZm9udFNpemU6IFwiMTJweFwiLFxyXG4gICAgICogICB9LFxyXG4gICAgICogICAvLyBhZGp1c3QgekluZGV4IHRvIGJlIGFib3ZlIG90aGVyIG1hcmtlcnNcclxuICAgICAqICAgekluZGV4OiAxMDAwICsgY291bnQsXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICByZW5kZXIoeyBjb3VudCwgcG9zaXRpb24gfSwgc3RhdHMpIHtcclxuICAgICAgICAvLyBjaGFuZ2UgY29sb3IgaWYgdGhpcyBjbHVzdGVyIGhhcyBtb3JlIG1hcmtlcnMgdGhhbiB0aGUgbWVhbiBjbHVzdGVyXHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb3VudCA+IE1hdGgubWF4KDEwLCBzdGF0cy5jbHVzdGVycy5tYXJrZXJzLm1lYW4pID8gXCIjZmYwMDAwXCIgOiBcIiMwMDAwZmZcIjtcclxuICAgICAgICAvLyBjcmVhdGUgc3ZnIHVybCB3aXRoIGZpbGwgY29sb3JcclxuICAgICAgICBjb25zdCBzdmcgPSB3aW5kb3cuYnRvYShgXG4gIDxzdmcgZmlsbD1cIiR7Y29sb3J9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQwIDI0MFwiPlxuICAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuNlwiIHI9XCI3MFwiIC8+XG4gICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4zXCIgcj1cIjkwXCIgLz5cbiAgICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjJcIiByPVwiMTEwXCIgLz5cbiAgPC9zdmc+YCk7XHJcbiAgICAgICAgLy8gY3JlYXRlIG1hcmtlciB1c2luZyBzdmcgaWNvblxyXG4gICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIGljb246IHtcclxuICAgICAgICAgICAgICAgIHVybDogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtzdmd9YCxcclxuICAgICAgICAgICAgICAgIHNjYWxlZFNpemU6IG5ldyBnb29nbGUubWFwcy5TaXplKDQ1LCA0NSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBTdHJpbmcoY291bnQpLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCIsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGFkanVzdCB6SW5kZXggdG8gYmUgYWJvdmUgb3RoZXIgbWFya2Vyc1xyXG4gICAgICAgICAgICB6SW5kZXg6IE51bWJlcihnb29nbGUubWFwcy5NYXJrZXIuTUFYX1pJTkRFWCkgKyBjb3VudCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV4dGVuZHMgYW4gb2JqZWN0J3MgcHJvdG90eXBlIGJ5IGFub3RoZXIncy5cclxuICpcclxuICogQHBhcmFtIHR5cGUxIFRoZSBUeXBlIHRvIGJlIGV4dGVuZGVkLlxyXG4gKiBAcGFyYW0gdHlwZTIgVGhlIFR5cGUgdG8gZXh0ZW5kIHdpdGguXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmZ1bmN0aW9uIGV4dGVuZCh0eXBlMSwgdHlwZTIpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0eXBlMi5wcm90b3R5cGUpIHtcclxuICAgICAgICB0eXBlMS5wcm90b3R5cGVbcHJvcGVydHldID0gdHlwZTIucHJvdG90eXBlW3Byb3BlcnR5XTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgT3ZlcmxheVZpZXdTYWZlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIE1hcmtlckNsdXN0ZXJlciBpbXBsZW1lbnRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3IGludGVyZmFjZS4gV2UgdXNlIHRoZVxyXG4gICAgICAgIC8vIGV4dGVuZCBmdW5jdGlvbiB0byBleHRlbmQgTWFya2VyQ2x1c3RlcmVyIHdpdGggZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXdcclxuICAgICAgICAvLyBiZWNhdXNlIGl0IG1pZ2h0IG5vdCBhbHdheXMgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIGNvZGUgaXMgZGVmaW5lZCBzbyB3ZVxyXG4gICAgICAgIC8vIGxvb2sgZm9yIGl0IGF0IHRoZSBsYXN0IHBvc3NpYmxlIG1vbWVudC4gSWYgaXQgZG9lc24ndCBleGlzdCBub3cgdGhlblxyXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGdvaW5nIGFoZWFkIDopXHJcbiAgICAgICAgZXh0ZW5kKE92ZXJsYXlWaWV3U2FmZSwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBNYXJrZXJDbHVzdGVyZXJFdmVudHM7XHJcbihmdW5jdGlvbiAoTWFya2VyQ2x1c3RlcmVyRXZlbnRzKSB7XHJcbiAgICBNYXJrZXJDbHVzdGVyZXJFdmVudHNbXCJDTFVTVEVSSU5HX0JFR0lOXCJdID0gXCJjbHVzdGVyaW5nYmVnaW5cIjtcclxuICAgIE1hcmtlckNsdXN0ZXJlckV2ZW50c1tcIkNMVVNURVJJTkdfRU5EXCJdID0gXCJjbHVzdGVyaW5nZW5kXCI7XHJcbiAgICBNYXJrZXJDbHVzdGVyZXJFdmVudHNbXCJDTFVTVEVSX0NMSUNLXCJdID0gXCJjbGlja1wiO1xyXG59KShNYXJrZXJDbHVzdGVyZXJFdmVudHMgfHwgKE1hcmtlckNsdXN0ZXJlckV2ZW50cyA9IHt9KSk7XHJcbmNvbnN0IGRlZmF1bHRPbkNsdXN0ZXJDbGlja0hhbmRsZXIgPSAoXywgY2x1c3RlciwgbWFwKSA9PiB7XHJcbiAgICBtYXAuZml0Qm91bmRzKGNsdXN0ZXIuYm91bmRzKTtcclxufTtcclxuLyoqXHJcbiAqIE1hcmtlckNsdXN0ZXJlciBjcmVhdGVzIGFuZCBtYW5hZ2VzIHBlci16b29tLWxldmVsIGNsdXN0ZXJzIGZvciBsYXJnZSBhbW91bnRzXHJcbiAqIG9mIG1hcmtlcnMuIFNlZSB7QGxpbmsgTWFya2VyQ2x1c3RlcmVyT3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogPGlmcmFtZSBzcmM9XCJodHRwczovL2dvb2dsZW1hcHMuZ2l0aHViLmlvL2pzLXRocmVlL3B1YmxpYy9hbmNob3IvaW5kZXguaHRtbFwiPjwvaWZyYW1lPlxyXG4gKi9cclxuY2xhc3MgTWFya2VyQ2x1c3RlcmVyIGV4dGVuZHMgT3ZlcmxheVZpZXdTYWZlIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgbWFwLCBtYXJrZXJzID0gW10sIGFsZ29yaXRobSA9IG5ldyBTdXBlckNsdXN0ZXJBbGdvcml0aG0oe30pLCByZW5kZXJlciA9IG5ldyBEZWZhdWx0UmVuZGVyZXIoKSwgb25DbHVzdGVyQ2xpY2sgPSBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyLCB9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbLi4ubWFya2Vyc107XHJcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICB0aGlzLm9uQ2x1c3RlckNsaWNrID0gb25DbHVzdGVyQ2xpY2s7XHJcbiAgICAgICAgaWYgKG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE1hcChtYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZE1hcmtlcihtYXJrZXIsIG5vRHJhdykge1xyXG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMuaW5jbHVkZXMobWFya2VyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFya2Vycy5wdXNoKG1hcmtlcik7XHJcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRNYXJrZXJzKG1hcmtlcnMsIG5vRHJhdykge1xyXG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyKG1hcmtlciwgdHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVNYXJrZXIobWFya2VyLCBub0RyYXcpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWFya2Vycy5pbmRleE9mKG1hcmtlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMsIHNvIGRvIG5vdGhpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcclxuICAgICAgICB0aGlzLm1hcmtlcnMuc3BsaWNlKGluZGV4LCAxKTsgLy8gUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgbGlzdCBvZiBtYW5hZ2VkIG1hcmtlcnNcclxuICAgICAgICBpZiAoIW5vRHJhdykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlbW92ZU1hcmtlcnMobWFya2Vycywgbm9EcmF3KSB7XHJcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gdGhpcy5yZW1vdmVNYXJrZXIobWFya2VyLCB0cnVlKSB8fCByZW1vdmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZW1vdmVkICYmICFub0RyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICB9XHJcbiAgICBjbGVhck1hcmtlcnMobm9EcmF3KSB7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBhbmQgZHJhd3MgYWxsIHRoZSBtYXJrZXIgY2x1c3RlcnMuXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xyXG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5NYXAgJiYgdGhpcy5nZXRQcm9qZWN0aW9uKCkpIHtcclxuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBNYXJrZXJDbHVzdGVyZXJFdmVudHMuQ0xVU1RFUklOR19CRUdJTiwgdGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2x1c3RlcnMsIGNoYW5nZWQgfSA9IHRoaXMuYWxnb3JpdGhtLmNhbGN1bGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiB0aGlzLm1hcmtlcnMsXHJcbiAgICAgICAgICAgICAgICBtYXAsXHJcbiAgICAgICAgICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uOiB0aGlzLmdldFByb2plY3Rpb24oKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IGFsZ29yaXRobXMgdG8gcmV0dXJuIGZsYWcgb24gd2hldGhlciB0aGUgY2x1c3RlcnMvbWFya2VycyBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgaWYgKGNoYW5nZWQgfHwgY2hhbmdlZCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHZpc2liaWxpdHkgb2YgbWFya2VycyBhbmQgY2x1c3RlcnNcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG5ldyBjbHVzdGVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVycyA9IGNsdXN0ZXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDbHVzdGVycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgTWFya2VyQ2x1c3RlcmVyRXZlbnRzLkNMVVNURVJJTkdfRU5ELCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkFkZCgpIHtcclxuICAgICAgICB0aGlzLmlkbGVMaXN0ZW5lciA9IHRoaXMuZ2V0TWFwKCkuYWRkTGlzdGVuZXIoXCJpZGxlXCIsIHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgICBvblJlbW92ZSgpIHtcclxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmlkbGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4gbWFya2VyLnNldE1hcChudWxsKSk7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKChjbHVzdGVyKSA9PiBjbHVzdGVyLmRlbGV0ZSgpKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XHJcbiAgICB9XHJcbiAgICByZW5kZXJDbHVzdGVycygpIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBzdGF0cyB0byBwYXNzIHRvIHJlbmRlcmVyc1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gbmV3IENsdXN0ZXJTdGF0cyh0aGlzLm1hcmtlcnMsIHRoaXMuY2x1c3RlcnMpO1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKChjbHVzdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjbHVzdGVyLm1hcmtlcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyLm1hcmtlciA9IGNsdXN0ZXIubWFya2Vyc1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXIubWFya2VyID0gdGhpcy5yZW5kZXJlci5yZW5kZXIoY2x1c3Rlciwgc3RhdHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbHVzdGVyQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLm1hcmtlci5hZGRMaXN0ZW5lcihcImNsaWNrXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgTWFya2VyQ2x1c3RlcmVyRXZlbnRzLkNMVVNURVJfQ0xJQ0ssIGNsdXN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2x1c3RlckNsaWNrKGV2ZW50LCBjbHVzdGVyLCBtYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsdXN0ZXIubWFya2VyLnNldE1hcChtYXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbnZhciBpbmRleF9lc20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QWJzdHJhY3RBbGdvcml0aG06IEFic3RyYWN0QWxnb3JpdGhtLFxuXHRBYnN0cmFjdFZpZXdwb3J0QWxnb3JpdGhtOiBBYnN0cmFjdFZpZXdwb3J0QWxnb3JpdGhtLFxuXHRDbHVzdGVyOiBDbHVzdGVyLFxuXHRDbHVzdGVyU3RhdHM6IENsdXN0ZXJTdGF0cyxcblx0REJTY2FuQWxnb3JpdGhtOiBEQlNjYW5BbGdvcml0aG0sXG5cdERlZmF1bHRSZW5kZXJlcjogRGVmYXVsdFJlbmRlcmVyLFxuXHRHcmlkQWxnb3JpdGhtOiBHcmlkQWxnb3JpdGhtLFxuXHRLbWVhbnNBbGdvcml0aG06IEttZWFuc0FsZ29yaXRobSxcblx0TWFya2VyQ2x1c3RlcmVyOiBNYXJrZXJDbHVzdGVyZXIsXG5cdGdldCBNYXJrZXJDbHVzdGVyZXJFdmVudHMgKCkgeyByZXR1cm4gTWFya2VyQ2x1c3RlcmVyRXZlbnRzOyB9LFxuXHROb29wQWxnb3JpdGhtOiBOb29wQWxnb3JpdGhtLFxuXHRTdXBlckNsdXN0ZXJBbGdvcml0aG06IFN1cGVyQ2x1c3RlckFsZ29yaXRobSxcblx0ZGVmYXVsdE9uQ2x1c3RlckNsaWNrSGFuZGxlcjogZGVmYXVsdE9uQ2x1c3RlckNsaWNrSGFuZGxlcixcblx0ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzOiBkaXN0YW5jZUJldHdlZW5Qb2ludHMsXG5cdGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQ6IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQsXG5cdGV4dGVuZFBpeGVsQm91bmRzOiBleHRlbmRQaXhlbEJvdW5kcyxcblx0ZmlsdGVyTWFya2Vyc1RvUGFkZGVkVmlld3BvcnQ6IGZpbHRlck1hcmtlcnNUb1BhZGRlZFZpZXdwb3J0LFxuXHRub29wOiBub29wJDEsXG5cdHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHM6IHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHNcbn0pO1xuXG5jb25zdCB1c2VHb29nbGVNYXJrZXJDbHVzdGVyZXIgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG1hcCA9IHVzZUdvb2dsZU1hcCgpO1xuICAgIGNvbnN0IFttYXJrZXJDbHVzdGVyZXIsIHNldE1hcmtlckNsdXN0ZXJlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFwICYmIG1hcmtlckNsdXN0ZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWFya2VyQ2x1c3RlciA9IG5ldyBNYXJrZXJDbHVzdGVyZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtYXAgfSkpO1xuICAgICAgICAgICAgc2V0TWFya2VyQ2x1c3RlcmVyKG1hcmtlckNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJldHVybiBtYXJrZXJDbHVzdGVyZXI7XG59O1xuLyoqIFdyYXBwZXIgYXJvdW5kIFtAZ29vZ2xlbWFwcy9tYXJrZXJjbHVzdGVyZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVtYXBzL2pzLW1hcmtlcmNsdXN0ZXJlcilcbiAqXG4gKiBBY2NlcHRzIHtAbGluayAgTWFya2VyQ2x1c3RlcmVyT3B0aW9uc1N1YnNldH0gd2hpY2ggaXMgYSBzdWJzZXQgb2YgIHtAbGluayBNYXJrZXJDbHVzdGVyZXJPcHRpb25zfVxuICovXG5jb25zdCBHb29nbGVNYXJrZXJDbHVzdGVyZXIgPSAoeyBjaGlsZHJlbiwgb3B0aW9ucyB9KSA9PiB7XG4gICAgY29uc3QgbWFya2VyQ2x1c3RlcmVyID0gdXNlR29vZ2xlTWFya2VyQ2x1c3RlcmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBtYXJrZXJDbHVzdGVyZXIgIT09IG51bGwgPyBjaGlsZHJlbihtYXJrZXJDbHVzdGVyZXIpIDogbnVsbDtcbn07XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbmNvbnN0IGV2ZW50TWFwJGMgPSB7XG4gICAgb25DbG9zZUNsaWNrOiAnY2xvc2VjbGljaycsXG4gICAgb25Db250ZW50Q2hhbmdlZDogJ2NvbnRlbnRfY2hhbmdlZCcsXG4gICAgb25Eb21SZWFkeTogJ2RvbXJlYWR5JyxcbiAgICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICAgIG9uWmluZGV4Q2hhbmdlZDogJ3ppbmRleF9jaGFuZ2VkJyxcbn07XG5jb25zdCB1cGRhdGVyTWFwJGMgPSB7XG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcG9zaXRpb24oaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHpJbmRleChpbnN0YW5jZSwgekluZGV4KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFpJbmRleCh6SW5kZXgpO1xuICAgIH0sXG59O1xuY2xhc3MgSW5mb1dpbmRvdyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZm9XaW5kb3c6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3BlbiA9IChpbmZvV2luZG93LCBhbmNob3IpID0+IHtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpbmZvV2luZG93Lm9wZW4odGhpcy5jb250ZXh0LCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5mb1dpbmRvdy5nZXRQb3NpdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnRfMShmYWxzZSwgYFlvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGFuY2hvciAodHlwaWNhbGx5IHJlbmRlciBpdCBpbnNpZGUgYSA8TWFya2VyPikgb3IgYSBwb3NpdGlvbiBwcm9wcyBmb3IgPEluZm9XaW5kb3c+LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEluZm9XaW5kb3dDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwgJiYgdGhpcy5jb250YWluZXJFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbmZvV2luZG93LnNldENvbnRlbnQodGhpcy5jb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4odGhpcy5zdGF0ZS5pbmZvV2luZG93LCB0aGlzLnByb3BzLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgaW5mb1dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KE9iamVjdC5hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRjLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbmZvV2luZG93LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRJbmZvV2luZG93KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmZvV2luZG93LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRJbmZvV2luZG93Q2FsbGJhY2spO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmluZm9XaW5kb3csXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5mb1dpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbmZvV2luZG93LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbGVtZW50ID8gKFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB0aGlzLmNvbnRhaW5lckVsZW1lbnQpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKSk7XG4gICAgfVxufVxuSW5mb1dpbmRvdy5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmNvbnN0IGV2ZW50TWFwJGIgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkYiA9IHtcbiAgICBkcmFnZ2FibGUoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBhdGgoaW5zdGFuY2UsIHBhdGgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICB9LFxuICAgIHZpc2libGUoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxufTtcbmNsYXNzIFBvbHlsaW5lIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9seWxpbmU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0UG9seWxpbmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbHlsaW5lICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5wb2x5bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBwb2x5bGluZSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRiLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGIsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHBvbHlsaW5lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRQb2x5bGluZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9seWxpbmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFBvbHlsaW5lQ2FsbGJhY2spO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbHlsaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGIsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGIsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5wb2x5bGluZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5wb2x5bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvbHlsaW5lLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbiAgICB9XG59XG5Qb2x5bGluZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbmNvbnN0IGV2ZW50TWFwJGEgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkYSA9IHtcbiAgICBkcmFnZ2FibGUoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBhdGgoaW5zdGFuY2UsIHBhdGgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICB9LFxuICAgIHBhdGhzKGluc3RhbmNlLCBwYXRocykge1xuICAgICAgICBpbnN0YW5jZS5zZXRQYXRocyhwYXRocyk7XG4gICAgfSxcbiAgICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9seWdvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRQb2x5Z29uQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5Z29uICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5wb2x5Z29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWdvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRhLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGEsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHBvbHlnb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFBvbHlnb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvbHlnb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFBvbHlnb25DYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9seWdvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRhLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRhLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUucG9seWdvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5Z29uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnBvbHlnb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wb2x5Z29uICYmIHRoaXMuc3RhdGUucG9seWdvbi5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5Qb2x5Z29uLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcblxuY29uc3QgZXZlbnRNYXAkOSA9IHtcbiAgICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkOSA9IHtcbiAgICBib3VuZHMoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICB9LFxuICAgIGRyYWdnYWJsZShpbnN0YW5jZSwgZHJhZ2dhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH0sXG4gICAgZWRpdGFibGUoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdmlzaWJsZShpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH0sXG59O1xuY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVjdGFuZ2xlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFJlY3RhbmdsZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVjdGFuZ2xlICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5yZWN0YW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IGdvb2dsZS5tYXBzLlJlY3RhbmdsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ5LFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDksXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHJlY3RhbmdsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0UmVjdGFuZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWN0YW5nbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFJlY3RhbmdsZUNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWN0YW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkOSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnJlY3RhbmdsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWN0YW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjdGFuZ2xlLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbiAgICB9XG59XG5SZWN0YW5nbGUuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG5jb25zdCBldmVudE1hcCQ4ID0ge1xuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25SYWRpdXNDaGFuZ2VkOiAncmFkaXVzX2NoYW5nZWQnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkOCA9IHtcbiAgICBjZW50ZXIoaW5zdGFuY2UsIGNlbnRlcikge1xuICAgICAgICBpbnN0YW5jZS5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9LFxuICAgIGRyYWdnYWJsZShpbnN0YW5jZSwgZHJhZ2dhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH0sXG4gICAgZWRpdGFibGUoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcmFkaXVzKGluc3RhbmNlLCByYWRpdXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgfSxcbiAgICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaXJjbGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0Q2lyY2xlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jaXJjbGUgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmNpcmNsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBjaXJjbGUgPSBuZXcgZ29vZ2xlLm1hcHMuQ2lyY2xlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogY2lyY2xlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRDaXJjbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNpcmNsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0Q2lyY2xlQ2FsbGJhY2spO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ4LFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ4LFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuY2lyY2xlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5jaXJjbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jaXJjbGUgJiYgdGhpcy5zdGF0ZS5jaXJjbGUuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xuICAgIH1cbn1cbkNpcmNsZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmNvbnN0IGV2ZW50TWFwJDcgPSB7XG4gICAgb25BZGRGZWF0dXJlOiAnYWRkZmVhdHVyZScsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgICBvblJlbW92ZUZlYXR1cmU6ICdyZW1vdmVmZWF0dXJlJyxcbiAgICBvblJlbW92ZVByb3BlcnR5OiAncmVtb3ZlcHJvcGVydHknLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxuICAgIG9uU2V0R2VvbWV0cnk6ICdzZXRnZW9tZXRyeScsXG4gICAgb25TZXRQcm9wZXJ0eTogJ3NldHByb3BlcnR5Jyxcbn07XG5jb25zdCB1cGRhdGVyTWFwJDcgPSB7XG4gICAgYWRkKGluc3RhbmNlLCBmZWF0dXJlcykge1xuICAgICAgICBpbnN0YW5jZS5hZGQoZmVhdHVyZXMpO1xuICAgIH0sXG4gICAgYWRkZ2VvanNvbihpbnN0YW5jZSwgZ2VvanNvbiwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5hZGRHZW9Kc29uKGdlb2pzb24sIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY29udGFpbnMoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UuY29udGFpbnMoZmVhdHVyZSk7XG4gICAgfSxcbiAgICBmb3JlYWNoKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGxvYWRnZW9qc29uKGluc3RhbmNlLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGluc3RhbmNlLmxvYWRHZW9Kc29uKHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb3ZlcnJpZGVzdHlsZShpbnN0YW5jZSwgZmVhdHVyZSwgc3R5bGUpIHtcbiAgICAgICAgaW5zdGFuY2Uub3ZlcnJpZGVTdHlsZShmZWF0dXJlLCBzdHlsZSk7XG4gICAgfSxcbiAgICByZW1vdmUoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UucmVtb3ZlKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgcmV2ZXJ0c3R5bGUoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UucmV2ZXJ0U3R5bGUoZmVhdHVyZSk7XG4gICAgfSxcbiAgICBjb250cm9scG9zaXRpb24oaW5zdGFuY2UsIGNvbnRyb2xQb3NpdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250cm9sUG9zaXRpb24oY29udHJvbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGNvbnRyb2xzKGluc3RhbmNlLCBjb250cm9scykge1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250cm9scyhjb250cm9scyk7XG4gICAgfSxcbiAgICBkcmF3aW5nbW9kZShpbnN0YW5jZSwgbW9kZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmF3aW5nTW9kZShtb2RlKTtcbiAgICB9LFxuICAgIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgc3R5bGUoaW5zdGFuY2UsIHN0eWxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9LFxuICAgIHRvZ2VvanNvbihpbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaW5zdGFuY2UudG9HZW9Kc29uKGNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNsYXNzIERhdGEgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldERhdGFDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBnb29nbGUubWFwcy5EYXRhKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDcsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNyxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0RGF0YUNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDcsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDcsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbkRhdGEuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG5jb25zdCBldmVudE1hcCQ2ID0ge1xuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25EZWZhdWx0Vmlld3BvcnRDaGFuZ2VkOiAnZGVmYXVsdHZpZXdwb3J0X2NoYW5nZWQnLFxuICAgIG9uU3RhdHVzQ2hhbmdlZDogJ3N0YXR1c19jaGFuZ2VkJyxcbn07XG5jb25zdCB1cGRhdGVyTWFwJDYgPSB7XG4gICAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdXJsKGluc3RhbmNlLCB1cmwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VXJsKHVybCk7XG4gICAgfSxcbiAgICB6SW5kZXgoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9LFxufTtcbmNsYXNzIEttbExheWVyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAga21sTGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0S21sTGF5ZXJDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmttbExheWVyICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5rbWxMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBrbWxMYXllciA9IG5ldyBnb29nbGUubWFwcy5LbWxMYXllcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNixcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ2LFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBrbWxMYXllcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG1sTGF5ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGttbExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRLbWxMYXllckNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5rbWxMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ2LFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ2LFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUua21sTGF5ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUua21sTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5rbWxMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5LbWxMYXllci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbi8qIGVzbGludC1kaXNhYmxlIGZpbGVuYW1lcy9tYXRjaC1yZWdleCAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0T3ZlcnJpZGUoY29udGFpbmVyRWxlbWVudCwgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCkge1xuICAgIHJldHVybiB0eXBlb2YgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGdldFBpeGVsUG9zaXRpb25PZmZzZXQoY29udGFpbmVyRWxlbWVudC5vZmZzZXRXaWR0aCwgY29udGFpbmVyRWxlbWVudC5vZmZzZXRIZWlnaHQpXG4gICAgICAgIDoge307XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgY3JlYXRlTGF0TG5nID0gKGluc3QsIFR5cGUpID0+IG5ldyBUeXBlKGluc3QubGF0LCBpbnN0LmxuZyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgY3JlYXRlTGF0TG5nQm91bmRzID0gKGluc3QsIFR5cGUpID0+IG5ldyBUeXBlKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoaW5zdC5uZS5sYXQsIGluc3QubmUubG5nKSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhpbnN0LnN3LmxhdCwgaW5zdC5zdy5sbmcpKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBlbnN1cmVPZlR5cGUgPSAoaW5zdCwgdHlwZSwgZmFjdG9yeSkgPT4ge1xuICAgIHJldHVybiBpbnN0IGluc3RhbmNlb2YgdHlwZSA/IGluc3QgOiBmYWN0b3J5KGluc3QsIHR5cGUpO1xufTtcbmNvbnN0IGdldExheW91dFN0eWxlc0J5Qm91bmRzID0gKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgbmUgPSBtYXBDYW52YXNQcm9qZWN0aW9uICYmIG1hcENhbnZhc1Byb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcbiAgICBjb25zdCBzdyA9IG1hcENhbnZhc1Byb2plY3Rpb24gJiYgbWFwQ2FudmFzUHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChib3VuZHMuZ2V0U291dGhXZXN0KCkpO1xuICAgIGlmIChuZSAmJiBzdykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogYCR7c3cueCArIG9mZnNldC54fXB4YCxcbiAgICAgICAgICAgIHRvcDogYCR7bmUueSArIG9mZnNldC55fXB4YCxcbiAgICAgICAgICAgIHdpZHRoOiBgJHtuZS54IC0gc3cueCAtIG9mZnNldC54fXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7c3cueSAtIG5lLnkgLSBvZmZzZXQueX1weGAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICctOTk5OXB4JyxcbiAgICAgICAgdG9wOiAnLTk5OTlweCcsXG4gICAgfTtcbn07XG5jb25zdCBnZXRMYXlvdXRTdHlsZXNCeVBvc2l0aW9uID0gKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBwb2ludCA9IG1hcENhbnZhc1Byb2plY3Rpb24gJiYgbWFwQ2FudmFzUHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChwb3NpdGlvbik7XG4gICAgaWYgKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBgJHt4ICsgb2Zmc2V0Lnh9cHhgLFxuICAgICAgICAgICAgdG9wOiBgJHt5ICsgb2Zmc2V0Lnl9cHhgLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAnLTk5OTlweCcsXG4gICAgICAgIHRvcDogJy05OTk5cHgnLFxuICAgIH07XG59O1xuY29uc3QgZ2V0TGF5b3V0U3R5bGVzID0gKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgYm91bmRzLCBwb3NpdGlvbikgPT4ge1xuICAgIHJldHVybiBib3VuZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGdldExheW91dFN0eWxlc0J5Qm91bmRzKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgZW5zdXJlT2ZUeXBlKGJvdW5kcywgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzLCBjcmVhdGVMYXRMbmdCb3VuZHMpKVxuICAgICAgICA6IGdldExheW91dFN0eWxlc0J5UG9zaXRpb24obWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCBlbnN1cmVPZlR5cGUocG9zaXRpb24sIGdvb2dsZS5tYXBzLkxhdExuZywgY3JlYXRlTGF0TG5nKSk7XG59O1xuY29uc3QgYXJlUG9zaXRpb25zRXF1YWwgPSAoY3VycmVudFBvc2l0aW9uLCBwcmV2aW91c1Bvc2l0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbi5sZWZ0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmxlZnRcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLnRvcCA9PT0gcHJldmlvdXNQb3NpdGlvbi50b3BcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLndpZHRoID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodFxuICAgICAgICAmJiBjdXJyZW50UG9zaXRpb24uaGVpZ2h0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodDtcbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhdExuZ1N0cmluZyhsYXRMbmdMaWtlKSB7XG4gICAgaWYgKCFsYXRMbmdMaWtlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgbGF0TG5nID0gbGF0TG5nTGlrZSBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZ1xuICAgICAgICA/IGxhdExuZ0xpa2VcbiAgICAgICAgOiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdExuZ0xpa2UubGF0LCBsYXRMbmdMaWtlLmxuZyk7XG4gICAgcmV0dXJuIGxhdExuZyArICcnO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGF0TG5nQm91bmRzU3RyaW5nKGxhdExuZ0JvdW5kc0xpa2UpIHtcbiAgICBpZiAoIWxhdExuZ0JvdW5kc0xpa2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBsYXRMbmdCb3VuZHMgPSBsYXRMbmdCb3VuZHNMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzXG4gICAgICAgID8gbGF0TG5nQm91bmRzTGlrZVxuICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmdCb3VuZHNMaWtlLnNvdXRoLCBsYXRMbmdCb3VuZHNMaWtlLmVhc3QpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdExuZ0JvdW5kc0xpa2Uubm9ydGgsIGxhdExuZ0JvdW5kc0xpa2Uud2VzdCkpO1xuICAgIHJldHVybiBsYXRMbmdCb3VuZHMgKyAnJztcbn1cbmNsYXNzIE92ZXJsYXlWaWV3IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGFuZUVsOiBudWxsLFxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBhbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXBQYW5lTmFtZSA9IHRoaXMucHJvcHMubWFwUGFuZU5hbWU7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC8zLmV4cC9yZWZlcmVuY2UjTWFwUGFuZXNcbiAgICAgICAgICAgIGNvbnN0IG1hcFBhbmVzID0gdGhpcy5vdmVybGF5Vmlldy5nZXRQYW5lcygpO1xuICAgICAgICAgICAgaW52YXJpYW50XzEoISFtYXBQYW5lTmFtZSwgYE92ZXJsYXlWaWV3IHJlcXVpcmVzIHByb3BzLm1hcFBhbmVOYW1lIGJ1dCBnb3QgJXNgLCBtYXBQYW5lTmFtZSk7XG4gICAgICAgICAgICBpZiAobWFwUGFuZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZUVsOiBtYXBQYW5lc1ttYXBQYW5lTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwYW5lRWw6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkFkZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhbmUoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLm9uTG9hZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMub3ZlcmxheVZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9zaXRpb25FbGVtZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwQ2FudmFzUHJvamVjdGlvbiA9IHRoaXMub3ZlcmxheVZpZXcuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gT2JqZWN0LmFzc2lnbih7IHg6IDAsIHk6IDAgfSwgKHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGdldE9mZnNldE92ZXJyaWRlKHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldClcbiAgICAgICAgICAgICAgICA6IHt9KSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRTdHlsZXMgPSBnZXRMYXlvdXRTdHlsZXMobWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCB0aGlzLnByb3BzLmJvdW5kcywgdGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zdGF0ZS5jb250YWluZXJTdHlsZTtcbiAgICAgICAgICAgIGlmICghYXJlUG9zaXRpb25zRXF1YWwobGF5b3V0U3R5bGVzLCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJTdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsYXlvdXRTdHlsZXMpLCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyYXcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uUG9zaXRpb25FbGVtZW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICAgICAgICAgIHBhbmVFbDogbnVsbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gdGhpcy5tYXBQYW5lRWwgPSBudWxsXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5vblVubW91bnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLm92ZXJsYXlWaWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250YWluZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgLy8gWW91IG11c3QgaW1wbGVtZW50IHRocmVlIG1ldGhvZHM6IG9uQWRkKCksIGRyYXcoKSwgYW5kIG9uUmVtb3ZlKCkuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlWaWV3ID0gbmV3IGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KCk7XG4gICAgICAgIG92ZXJsYXlWaWV3Lm9uQWRkID0gdGhpcy5vbkFkZDtcbiAgICAgICAgb3ZlcmxheVZpZXcuZHJhdyA9IHRoaXMuZHJhdztcbiAgICAgICAgb3ZlcmxheVZpZXcub25SZW1vdmUgPSB0aGlzLm9uUmVtb3ZlO1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3ID0gb3ZlcmxheVZpZXc7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAvLyBZb3UgbXVzdCBjYWxsIHNldE1hcCgpIHdpdGggYSB2YWxpZCBNYXAgb2JqZWN0IHRvIHRyaWdnZXIgdGhlIGNhbGwgdG9cbiAgICAgICAgLy8gdGhlIG9uQWRkKCkgbWV0aG9kIGFuZCBzZXRNYXAobnVsbCkgaW4gb3JkZXIgdG8gdHJpZ2dlciB0aGUgb25SZW1vdmUoKSBtZXRob2QuXG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXcuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgcHJldlBvc2l0aW9uU3RyaW5nID0gY29udmVydFRvTGF0TG5nU3RyaW5nKHByZXZQcm9wcy5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uU3RyaW5nID0gY29udmVydFRvTGF0TG5nU3RyaW5nKHRoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcmV2Qm91bmRzU3RyaW5nID0gY29udmVydFRvTGF0TG5nQm91bmRzU3RyaW5nKHByZXZQcm9wcy5ib3VuZHMpO1xuICAgICAgICBjb25zdCBib3VuZHNTdHJpbmcgPSBjb252ZXJ0VG9MYXRMbmdCb3VuZHNTdHJpbmcodGhpcy5wcm9wcy5ib3VuZHMpO1xuICAgICAgICBpZiAocHJldlBvc2l0aW9uU3RyaW5nICE9PSBwb3NpdGlvblN0cmluZyB8fCBwcmV2Qm91bmRzU3RyaW5nICE9PSBib3VuZHNTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVZpZXcuZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWFwUGFuZU5hbWUgIT09IHRoaXMucHJvcHMubWFwUGFuZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFuZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnNldE1hcChudWxsKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBwYW5lRWwgPSB0aGlzLnN0YXRlLnBhbmVFbDtcbiAgICAgICAgaWYgKHBhbmVFbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNvbnRhaW5lclJlZiwgc3R5bGU6IHRoaXMuc3RhdGUuY29udGFpbmVyU3R5bGUgfSwgUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSksIHBhbmVFbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbk92ZXJsYXlWaWV3LkZMT0FUX1BBTkUgPSBgZmxvYXRQYW5lYDtcbk92ZXJsYXlWaWV3Lk1BUF9QQU5FID0gYG1hcFBhbmVgO1xuT3ZlcmxheVZpZXcuTUFSS0VSX0xBWUVSID0gYG1hcmtlckxheWVyYDtcbk92ZXJsYXlWaWV3Lk9WRVJMQVlfTEFZRVIgPSBgb3ZlcmxheUxheWVyYDtcbk92ZXJsYXlWaWV3Lk9WRVJMQVlfTU9VU0VfVEFSR0VUID0gYG92ZXJsYXlNb3VzZVRhcmdldGA7XG5PdmVybGF5Vmlldy5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuY29uc3QgZXZlbnRNYXAkNSA9IHtcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uQ2xpY2s6ICdjbGljaycsXG59O1xuY29uc3QgdXBkYXRlck1hcCQ1ID0ge1xuICAgIG9wYWNpdHkoaW5zdGFuY2UsIG9wYWNpdHkpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICB9LFxufTtcbmNsYXNzIEdyb3VuZE92ZXJsYXkgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBncm91bmRPdmVybGF5OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEdyb3VuZE92ZXJsYXlDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaW52YXJpYW50XzEoISF0aGlzLnByb3BzLnVybCB8fCAhIXRoaXMucHJvcHMuYm91bmRzLCBgRm9yIEdyb3VuZE92ZXJsYXksIHVybCBhbmQgYm91bmRzIGFyZSBwYXNzZWQgaW4gdG8gY29uc3RydWN0b3IgYW5kIGFyZSBpbW11dGFibGUgYWZ0ZXIgaW5zdGFudGlhdGVkLiBUaGlzIGlzIHRoZSBiZWhhdmlvciBvZiBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSB2MyAoIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjR3JvdW5kT3ZlcmxheSkgSGVuY2UsIHVzZSB0aGUgY29ycmVzcG9uZGluZyB0d28gcHJvcHMgcHJvdmlkZWQgYnkgXFxgcmVhY3QtZ29vZ2xlLW1hcHMtYXBpXFxgLCB1cmwgYW5kIGJvdW5kcy4gSW4gc29tZSBjYXNlcywgeW91J2xsIG5lZWQgdGhlIEdyb3VuZE92ZXJsYXkgY29tcG9uZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMgb2YgdXJsIGFuZCBib3VuZHMuIFlvdSBjYW4gbGV2ZXJhZ2UgdGhlIFJlYWN0J3Mga2V5IHByb3BlcnR5IHRvIHJlbW91bnQgdGhlIGNvbXBvbmVudC4gVHlwaWNhbGx5LCBqdXN0IFxcYGtleT17dXJsfVxcYCB3b3VsZCBzZXJ2ZSB5b3VyIG5lZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdG9tY2hlbnR3L3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy82NTVgKTtcbiAgICAgICAgY29uc3QgZ3JvdW5kT3ZlcmxheSA9IG5ldyBnb29nbGUubWFwcy5Hcm91bmRPdmVybGF5KHRoaXMucHJvcHMudXJsLCB0aGlzLnByb3BzLmJvdW5kcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLm9wdGlvbnMpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDUsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNSxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogZ3JvdW5kT3ZlcmxheSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0R3JvdW5kT3ZlcmxheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0R3JvdW5kT3ZlcmxheUNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDUsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDUsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuR3JvdW5kT3ZlcmxheS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgb25Mb2FkOiBub29wLFxufTtcbkdyb3VuZE92ZXJsYXkuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG5jb25zdCBldmVudE1hcCQ0ID0ge307XG5jb25zdCB1cGRhdGVyTWFwJDQgPSB7XG4gICAgZGF0YShpbnN0YW5jZSwgZGF0YSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREYXRhKGRhdGEpO1xuICAgIH0sXG4gICAgbWFwKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbn07XG5jbGFzcyBIZWF0bWFwTGF5ZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoZWF0bWFwTGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SGVhdG1hcExheWVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmhlYXRtYXBMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpbnZhcmlhbnRfMSghIWdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24sICdEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1tcInZpc3VhbGl6YXRpb25cIl19IHRvIDxMb2FkU2NyaXB0IC8+PyAlcycsIGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24pO1xuICAgICAgICBpbnZhcmlhbnRfMSghIXRoaXMucHJvcHMuZGF0YSwgJ2RhdGEgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gSGVhdG1hcExheWVyICVzJywgdGhpcy5wcm9wcy5kYXRhKTtcbiAgICAgICAgY29uc3QgaGVhdG1hcExheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uSGVhdG1hcExheWVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IGRhdGE6IHRoaXMucHJvcHMuZGF0YSwgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNCxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ0LFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBoZWF0bWFwTGF5ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldEhlYXRtYXBMYXllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhdG1hcExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRIZWF0bWFwTGF5ZXJDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNCxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ0LFxuICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuaGVhdG1hcExheWVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmhlYXRtYXBMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuSGVhdG1hcExheWVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcblxuY29uc3QgZXZlbnRNYXAkMyA9IHtcbiAgICBvbkNsb3NlQ2xpY2s6ICdjbG9zZWNsaWNrJyxcbiAgICBvblBhbm9DaGFuZ2VkOiAncGFub19jaGFuZ2VkJyxcbiAgICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICAgIG9uUG92Q2hhbmdlZDogJ3Bvdl9jaGFuZ2VkJyxcbiAgICBvblJlc2l6ZTogJ3Jlc2l6ZScsXG4gICAgb25TdGF0dXNDaGFuZ2VkOiAnc3RhdHVzX2NoYW5nZWQnLFxuICAgIG9uVmlzaWJsZUNoYW5nZWQ6ICd2aXNpYmxlX2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkMyA9IHtcbiAgICByZWdpc3RlcihpbnN0YW5jZSwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJQYW5vUHJvdmlkZXIocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgbGlua3MoaW5zdGFuY2UsIGxpbmtzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldExpbmtzKGxpbmtzKTtcbiAgICB9LFxuICAgIG1vdGlvblRyYWNraW5nKGluc3RhbmNlLCBtb3Rpb25UcmFja2luZykge1xuICAgICAgICBpbnN0YW5jZS5zZXRNb3Rpb25UcmFja2luZyhtb3Rpb25UcmFja2luZyk7XG4gICAgfSxcbiAgICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYW5vKGluc3RhbmNlLCBwYW5vKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBhbm8ocGFubyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbihpbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sXG4gICAgcG92KGluc3RhbmNlLCBwb3YpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UG92KHBvdik7XG4gICAgfSxcbiAgICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbiAgICB6b29tKGluc3RhbmNlLCB6b29tKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFpvb20oem9vbSk7XG4gICAgfSxcbn07XG5jbGFzcyBTdHJlZXRWaWV3UGFub3JhbWEgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdHJlZXRWaWV3UGFub3JhbWE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0U3RyZWV0Vmlld1Bhbm9yYW1hQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBzdHJlZXRWaWV3UGFub3JhbWEgPSB0aGlzLmNvbnRleHQuZ2V0U3RyZWV0VmlldygpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMyxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQzLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBzdHJlZXRWaWV3UGFub3JhbWEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFN0cmVldFZpZXdQYW5vcmFtYSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RyZWV0Vmlld1Bhbm9yYW1hLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRTdHJlZXRWaWV3UGFub3JhbWFDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDMsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDMsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYS5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblN0cmVldFZpZXdQYW5vcmFtYS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmNsYXNzIFN0cmVldFZpZXdTZXJ2aWNlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdHJlZXRWaWV3U2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTdHJlZXRWaWV3U2VydmljZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1NlcnZpY2UgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHN0cmVldFZpZXdTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLlN0cmVldFZpZXdTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0U3RyZWV0Vmlld1NlcnZpY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmVldFZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRTdHJlZXRWaWV3U2VydmljZUNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblN0cmVldFZpZXdTZXJ2aWNlLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcblxuY2xhc3MgRGlyZWN0aW9uc1NlcnZpY2UgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbnNTZXJ2aWNlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldERpcmVjdGlvbnNTZXJ2aWNlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaW52YXJpYW50XzEoISF0aGlzLnByb3BzLm9wdGlvbnMsICdEaXJlY3Rpb25zU2VydmljZSBleHBlY3RlZCBvcHRpb25zIG9iamVjdCBhcyBwYXJhbWV0ZXIsIGJ1dCBnb3QgJXMnLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb25zU2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERpcmVjdGlvbnNTZXJ2aWNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zU2VydmljZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0RGlyZWN0aW9uc1NlcnZpY2VDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2Uucm91dGUodGhpcy5wcm9wcy5vcHRpb25zLCB0aGlzLnByb3BzLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xuICAgIH1cbn1cblxuY29uc3QgZXZlbnRNYXAkMiA9IHtcbiAgICBvbkRpcmVjdGlvbnNDaGFuZ2VkOiAnZGlyZWN0aW9uc19jaGFuZ2VkJyxcbn07XG5jb25zdCB1cGRhdGVyTWFwJDIgPSB7XG4gICAgZGlyZWN0aW9ucyhpbnN0YW5jZSwgZGlyZWN0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXREaXJlY3Rpb25zKGRpcmVjdGlvbnMpO1xuICAgIH0sXG4gICAgbWFwKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYW5lbChpbnN0YW5jZSwgcGFuZWwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGFuZWwocGFuZWwpO1xuICAgIH0sXG4gICAgcm91dGVJbmRleChpbnN0YW5jZSwgcm91dGVJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRSb3V0ZUluZGV4KHJvdXRlSW5kZXgpO1xuICAgIH0sXG59O1xuY2xhc3MgRGlyZWN0aW9uc1JlbmRlcmVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldERpcmVjdGlvbnNSZW5kZXJlckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb25zUmVuZGVyZXIgPSBuZXcgZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1JlbmRlcmVyKHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQyLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDIsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGRpcmVjdGlvbnNSZW5kZXJlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RGlyZWN0aW9uc1JlbmRlcmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zUmVuZGVyZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldERpcmVjdGlvbnNSZW5kZXJlckNhbGxiYWNrKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMixcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMixcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbiAgICB9XG59XG5EaXJlY3Rpb25zUmVuZGVyZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG5jbGFzcyBEaXN0YW5jZU1hdHJpeFNlcnZpY2UgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXREaXN0YW5jZU1hdHJpeFNlcnZpY2VDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRpc3RhbmNlTWF0cml4U2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGludmFyaWFudF8xKCEhdGhpcy5wcm9wcy5vcHRpb25zLCAnRGlzdGFuY2VNYXRyaXhTZXJ2aWNlIGV4cGVjdGVkIG9wdGlvbnMgb2JqZWN0IGFzIHBhcmFtZXRlciwgYnV0IGdvICVzJywgdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VNYXRyaXhTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLkRpc3RhbmNlTWF0cml4U2VydmljZSgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERpc3RhbmNlTWF0cml4U2VydmljZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VNYXRyaXhTZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREaXN0YW5jZU1hdHJpeFNlcnZpY2VDYWxsYmFjayk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpc3RhbmNlTWF0cml4U2VydmljZS5nZXREaXN0YW5jZU1hdHJpeCh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IGV2ZW50TWFwJDEgPSB7XG4gICAgb25QbGFjZXNDaGFuZ2VkOiAncGxhY2VzX2NoYW5nZWQnLFxufTtcbmNvbnN0IHVwZGF0ZXJNYXAkMSA9IHtcbiAgICBib3VuZHMoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICB9LFxufTtcbmNsYXNzIFN0YW5kYWxvbmVTZWFyY2hCb3ggZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2VhcmNoQm94OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFNlYXJjaEJveENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5zZWFyY2hCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaW52YXJpYW50XzEoISFnb29nbGUubWFwcy5wbGFjZXMsICdZb3UgbmVlZCB0byBwcm92aWRlIGxpYnJhcmllcz17W1wicGxhY2VzXCJdfSBwcm9wIHRvIDxMb2FkU2NyaXB0IC8+IGNvbXBvbmVudCAlcycsIGdvb2dsZS5tYXBzLnBsYWNlcyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lckVsZW1lbnQgIT09IG51bGwgJiYgdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaEJveCA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuU2VhcmNoQm94KGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQxLFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWFyY2hCb3gsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRTZWFyY2hCb3goKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hCb3gsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRTZWFyY2hCb3hDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWFyY2hCb3ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnNlYXJjaEJveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWFyY2hCb3ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuc2VhcmNoQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNvbnRhaW5lckVsZW1lbnQgfSwgUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuU3RhbmRhbG9uZVNlYXJjaEJveC5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG5cbmNvbnN0IGV2ZW50TWFwID0ge1xuICAgIG9uUGxhY2VDaGFuZ2VkOiAncGxhY2VfY2hhbmdlZCcsXG59O1xuY29uc3QgdXBkYXRlck1hcCA9IHtcbiAgICBib3VuZHMoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICB9LFxuICAgIHJlc3RyaWN0aW9ucyhpbnN0YW5jZSwgcmVzdHJpY3Rpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldENvbXBvbmVudFJlc3RyaWN0aW9ucyhyZXN0cmljdGlvbnMpO1xuICAgIH0sXG4gICAgZmllbGRzKGluc3RhbmNlLCBmaWVsZHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcbiAgICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICB0eXBlcyhpbnN0YW5jZSwgdHlwZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VHlwZXModHlwZXMpO1xuICAgIH0sXG59O1xuY2xhc3MgQXV0b2NvbXBsZXRlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRBdXRvY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGludmFyaWFudF8xKCEhZ29vZ2xlLm1hcHMucGxhY2VzLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBsaWJyYXJpZXM9e1tcInBsYWNlc1wiXX0gcHJvcCB0byA8TG9hZFNjcmlwdCAvPiBjb21wb25lbnQgJXMnLCBnb29nbGUubWFwcy5wbGFjZXMpO1xuICAgICAgICAvLyBUT0RPOiB3aHkgY3VycmVudCBjb3VsZCBiZSBlcXVhbCBudWxsP1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuY29udGFpbmVyRWxlbWVudC5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUoaW5wdXQsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBhdXRvY29tcGxldGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0QXV0b2NvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5zZXRBdXRvY29tcGxldGVDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcCxcbiAgICAgICAgICAgIGV2ZW50TWFwLFxuICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuY29udGFpbmVyRWxlbWVudCwgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCAnJyB9LCBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5BdXRvY29tcGxldGUuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuXG5leHBvcnQgeyBBdXRvY29tcGxldGUsIEJpY3ljbGluZ0xheWVyLCBDaXJjbGUsIERhdGEsIERpcmVjdGlvbnNSZW5kZXJlciwgRGlyZWN0aW9uc1NlcnZpY2UsIERpc3RhbmNlTWF0cml4U2VydmljZSwgRHJhd2luZ01hbmFnZXIsIEdvb2dsZU1hcCwgaW5kZXhfZXNtIGFzIEdvb2dsZU1hcHNNYXJrZXJDbHVzdGVyZXIsIEdvb2dsZU1hcmtlckNsdXN0ZXJlciwgR3JvdW5kT3ZlcmxheSwgSGVhdG1hcExheWVyLCBJbmZvQm94Q29tcG9uZW50IGFzIEluZm9Cb3gsIEluZm9XaW5kb3csIEttbExheWVyLCBMb2FkU2NyaXB0LCBMb2FkU2NyaXB0TmV4dCQxIGFzIExvYWRTY3JpcHROZXh0LCBNYXBDb250ZXh0LCBNYXJrZXIsIENsdXN0ZXJlckNvbXBvbmVudCBhcyBNYXJrZXJDbHVzdGVyZXIsIE92ZXJsYXlWaWV3LCBQb2x5Z29uLCBQb2x5bGluZSwgUmVjdGFuZ2xlLCBTdGFuZGFsb25lU2VhcmNoQm94LCBTdHJlZXRWaWV3UGFub3JhbWEsIFN0cmVldFZpZXdTZXJ2aWNlLCBUcmFmZmljTGF5ZXIsIFRyYW5zaXRMYXllciwgdXNlR29vZ2xlTWFwLCB1c2VKc0FwaUxvYWRlciwgdXNlTG9hZFNjcmlwdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@react-google-maps/api/dist/esm.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) === null || ref === void 0 ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) === null || ref1 === void 0 ? void 0 : ref1.env) === 'object' ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSx5QkFBeUIscUJBQU0sNEVBQTRFLHFCQUFNLDBFQUEwRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsb0ZBQXdCOztBQUU1TyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVmLCByZWYxO1xubW9kdWxlLmV4cG9ydHMgPSAoKHJlZiA9IGdsb2JhbC5wcm9jZXNzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5lbnYpICYmIHR5cGVvZiAoKHJlZjEgPSBnbG9iYWwucHJvY2VzcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5lbnYpID09PSAnb2JqZWN0JyA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZSgnLi4vLi4vY29tcGlsZWQvcHJvY2VzcycpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css":
/*!*****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root {\\n  --reach-combobox: 1;\\n}\\n\\n[data-reach-combobox-popover] {\\n  border: solid 1px hsla(0, 0%, 0%, 0.25);\\n  background: hsla(0, 100%, 100%, 0.99);\\n  font-size: 85%;\\n}\\n\\n[data-reach-combobox-list] {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n}\\n\\n[data-reach-combobox-option] {\\n  cursor: pointer;\\n  margin: 0;\\n  padding: 0.25rem 0.5rem;\\n}\\n\\n[data-reach-combobox-option][aria-selected=\\\"true\\\"] {\\n  background: hsl(211, 10%, 95%);\\n}\\n\\n[data-reach-combobox-option]:hover {\\n  background: hsl(211, 10%, 92%);\\n}\\n\\n[data-reach-combobox-option][aria-selected=\\\"true\\\"]:hover {\\n  background: hsl(211, 10%, 90%);\\n}\\n\\n[data-suggested-value] {\\n  font-weight: bold;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/@reach/combobox/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,mBAAmB;AACrB;;AAEA;EACE,uCAAuC;EACvC,qCAAqC;EACrC,cAAc;AAChB;;AAEA;EACE,gBAAgB;EAChB,SAAS;EACT,UAAU;EACV,yBAAiB;KAAjB,sBAAiB;MAAjB,qBAAiB;UAAjB,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,SAAS;EACT,uBAAuB;AACzB;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,iBAAiB;AACnB\",\"sourcesContent\":[\":root {\\n  --reach-combobox: 1;\\n}\\n\\n[data-reach-combobox-popover] {\\n  border: solid 1px hsla(0, 0%, 0%, 0.25);\\n  background: hsla(0, 100%, 100%, 0.99);\\n  font-size: 85%;\\n}\\n\\n[data-reach-combobox-list] {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n  user-select: none;\\n}\\n\\n[data-reach-combobox-option] {\\n  cursor: pointer;\\n  margin: 0;\\n  padding: 0.25rem 0.5rem;\\n}\\n\\n[data-reach-combobox-option][aria-selected=\\\"true\\\"] {\\n  background: hsl(211, 10%, 95%);\\n}\\n\\n[data-reach-combobox-option]:hover {\\n  background: hsl(211, 10%, 92%);\\n}\\n\\n[data-reach-combobox-option][aria-selected=\\\"true\\\"]:hover {\\n  background: hsl(211, 10%, 90%);\\n}\\n\\n[data-suggested-value] {\\n  font-weight: bold;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls3XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbN10udXNlWzJdIS4vbm9kZV9tb2R1bGVzL0ByZWFjaC9jb21ib2JveC9zdHlsZXMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQzhHO0FBQzlHLDhCQUE4QixxR0FBMkI7QUFDekQ7QUFDQSxpREFBaUQsd0JBQXdCLEdBQUcsbUNBQW1DLDRDQUE0QywwQ0FBMEMsbUJBQW1CLEdBQUcsZ0NBQWdDLHFCQUFxQixjQUFjLGVBQWUsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLEdBQUcsa0NBQWtDLG9CQUFvQixjQUFjLDRCQUE0QixHQUFHLDBEQUEwRCxtQ0FBbUMsR0FBRyx3Q0FBd0MsbUNBQW1DLEdBQUcsZ0VBQWdFLG1DQUFtQyxHQUFHLDRCQUE0QixzQkFBc0IsR0FBRyxTQUFTLHdHQUF3RyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsV0FBVyxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksaUNBQWlDLHdCQUF3QixHQUFHLG1DQUFtQyw0Q0FBNEMsMENBQTBDLG1CQUFtQixHQUFHLGdDQUFnQyxxQkFBcUIsY0FBYyxlQUFlLHNCQUFzQixHQUFHLGtDQUFrQyxvQkFBb0IsY0FBYyw0QkFBNEIsR0FBRywwREFBMEQsbUNBQW1DLEdBQUcsd0NBQXdDLG1DQUFtQyxHQUFHLGdFQUFnRSxtQ0FBbUMsR0FBRyw0QkFBNEIsc0JBQXNCLEdBQUcscUJBQXFCO0FBQ3ArRDtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY2gvY29tYm9ib3gvc3R5bGVzLmNzcz8zMDgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXG4gIC0tcmVhY2gtY29tYm9ib3g6IDE7XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LXBvcG92ZXJdIHtcXG4gIGJvcmRlcjogc29saWQgMXB4IGhzbGEoMCwgMCUsIDAlLCAwLjI1KTtcXG4gIGJhY2tncm91bmQ6IGhzbGEoMCwgMTAwJSwgMTAwJSwgMC45OSk7XFxuICBmb250LXNpemU6IDg1JTtcXG59XFxuXFxuW2RhdGEtcmVhY2gtY29tYm9ib3gtbGlzdF0ge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG5bZGF0YS1yZWFjaC1jb21ib2JveC1vcHRpb25dIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAuMjVyZW0gMC41cmVtO1xcbn1cXG5cXG5bZGF0YS1yZWFjaC1jb21ib2JveC1vcHRpb25dW2FyaWEtc2VsZWN0ZWQ9XFxcInRydWVcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBoc2woMjExLCAxMCUsIDk1JSk7XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LW9wdGlvbl06aG92ZXIge1xcbiAgYmFja2dyb3VuZDogaHNsKDIxMSwgMTAlLCA5MiUpO1xcbn1cXG5cXG5bZGF0YS1yZWFjaC1jb21ib2JveC1vcHRpb25dW2FyaWEtc2VsZWN0ZWQ9XFxcInRydWVcXFwiXTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiBoc2woMjExLCAxMCUsIDkwJSk7XFxufVxcblxcbltkYXRhLXN1Z2dlc3RlZC12YWx1ZV0ge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvQHJlYWNoL2NvbWJvYm94L3N0eWxlcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSx1Q0FBdUM7RUFDdkMscUNBQXFDO0VBQ3JDLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsU0FBUztFQUNULFVBQVU7RUFDVix5QkFBaUI7S0FBakIsc0JBQWlCO01BQWpCLHFCQUFpQjtVQUFqQixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsU0FBUztFQUNULHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLDhCQUE4QjtBQUNoQzs7QUFFQTtFQUNFLDhCQUE4QjtBQUNoQzs7QUFFQTtFQUNFLDhCQUE4QjtBQUNoQzs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI6cm9vdCB7XFxuICAtLXJlYWNoLWNvbWJvYm94OiAxO1xcbn1cXG5cXG5bZGF0YS1yZWFjaC1jb21ib2JveC1wb3BvdmVyXSB7XFxuICBib3JkZXI6IHNvbGlkIDFweCBoc2xhKDAsIDAlLCAwJSwgMC4yNSk7XFxuICBiYWNrZ3JvdW5kOiBoc2xhKDAsIDEwMCUsIDEwMCUsIDAuOTkpO1xcbiAgZm9udC1zaXplOiA4NSU7XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LWxpc3RdIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LW9wdGlvbl0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMC4yNXJlbSAwLjVyZW07XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LW9wdGlvbl1bYXJpYS1zZWxlY3RlZD1cXFwidHJ1ZVxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IGhzbCgyMTEsIDEwJSwgOTUlKTtcXG59XFxuXFxuW2RhdGEtcmVhY2gtY29tYm9ib3gtb3B0aW9uXTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiBoc2woMjExLCAxMCUsIDkyJSk7XFxufVxcblxcbltkYXRhLXJlYWNoLWNvbWJvYm94LW9wdGlvbl1bYXJpYS1zZWxlY3RlZD1cXFwidHJ1ZVxcXCJdOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IGhzbCgyMTEsIDEwJSwgOTAlKTtcXG59XFxuXFxuW2RhdGEtc3VnZ2VzdGVkLXZhbHVlXSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Ffcamara%2FDocuments%2Fsptech%2Fprojetos-sptech%2Fonhome-maps-api%2Fpages%2Findex.tsx!":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Ffcamara%2FDocuments%2Fsptech%2Fprojetos-sptech%2Fonhome-maps-api%2Fpages%2Findex.tsx! ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkYmYWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmZjYW1hcmElMkZEb2N1bWVudHMlMkZzcHRlY2glMkZwcm9qZXRvcy1zcHRlY2glMkZvbmhvbWUtbWFwcy1hcGklMkZwYWdlcyUyRmluZGV4LnRzeCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0Q0FBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzA1YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Ffcamara%2FDocuments%2Fsptech%2Fprojetos-sptech%2Fonhome-maps-api%2Fpages%2Findex.tsx!\n");

/***/ }),

/***/ "./node_modules/@reach/combobox/styles.css":
/*!*************************************************!*\
  !*** ./node_modules/@reach/combobox/styles.css ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./styles.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./styles.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./styles.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[7].use[2]!./node_modules/@reach/combobox/styles.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWNoL2NvbWJvYm94L3N0eWxlcy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLDBNQUE4RjtBQUNoSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBME47O0FBRTVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHVlQUEwTjtBQUNoTztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVlQUEwTjs7QUFFcFA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjaC9jb21ib2JveC9zdHlsZXMuY3NzP2I4ZWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls3XS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbN10udXNlWzJdIS4vc3R5bGVzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls3XS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbN10udXNlWzJdIS4vc3R5bGVzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls3XS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbN10udXNlWzJdIS4vc3R5bGVzLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@reach/combobox/styles.css\n");

/***/ }),

/***/ "./components/distance.tsx":
/*!*********************************!*\
  !*** ./components/distance.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Distance; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nvar commutesPerYear = 260 * 2;\nvar litresPerKM = 10 / 100;\nvar gasLitreCost = 1.5;\nvar litreCostKM = litresPerKM * gasLitreCost;\nvar secondsPerDay = 60 * 60 * 24;\nfunction Distance(param) {\n    var leg = param.leg;\n    if (!leg.distance || !leg.duration) return null;\n    var days = Math.floor(commutesPerYear * leg.duration.value / secondsPerDay);\n    var cost = Math.floor(leg.distance.value / 1000 * litreCostKM * commutesPerYear);\n    return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"response-p\",\n            children: [\n                \"O suporte escolhido est\\xe1 \\xe0 \",\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"highlight\",\n                    children: leg.distance.text\n                }, void 0, false, {\n                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/distance.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 36\n                }, this),\n                \" de dist\\xe2ncia de voc\\xea. Isso ir\\xe1 levar\",\n                \" \",\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"highlight\",\n                    children: leg.duration.text\n                }, void 0, false, {\n                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/distance.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 9\n                }, this),\n                \".\"\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/distance.tsx\",\n            lineNumber: 23,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/distance.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, this));\n};\n_c = Distance;\nvar _c;\n$RefreshReg$(_c, \"Distance\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2Rpc3RhbmNlLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLEdBQUssQ0FBQ0EsZUFBZSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQy9CLEdBQUssQ0FBQ0MsV0FBVyxHQUFHLEVBQUUsR0FBRyxHQUFHO0FBQzVCLEdBQUssQ0FBQ0MsWUFBWSxHQUFHLEdBQUc7QUFDeEIsR0FBSyxDQUFDQyxXQUFXLEdBQUdGLFdBQVcsR0FBR0MsWUFBWTtBQUM5QyxHQUFLLENBQUNFLGFBQWEsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFNbkIsUUFBUSxDQUFDQyxRQUFRLENBQUMsS0FBc0IsRUFBRSxDQUFDO1FBQXZCQyxHQUFHLEdBQUwsS0FBc0IsQ0FBcEJBLEdBQUc7SUFDcEMsRUFBRSxHQUFHQSxHQUFHLENBQUNDLFFBQVEsS0FBS0QsR0FBRyxDQUFDRSxRQUFRLEVBQUUsTUFBTSxDQUFDLElBQUk7SUFFL0MsR0FBSyxDQUFDQyxJQUFJLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUNwQlgsZUFBZSxHQUFHTSxHQUFHLENBQUNFLFFBQVEsQ0FBQ0ksS0FBSyxHQUFJUixhQUFhO0lBRXhELEdBQUssQ0FBQ1MsSUFBSSxHQUFHSCxJQUFJLENBQUNDLEtBQUssQ0FDcEJMLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDSyxLQUFLLEdBQUcsSUFBSSxHQUFJVCxXQUFXLEdBQUdILGVBQWU7SUFHN0QsTUFBTSw2RUFDSGMsQ0FBRzs4RkFDREMsQ0FBQztZQUFDQyxTQUFTLEVBQUMsQ0FBWTs7Z0JBQUMsQ0FDRzs0RkFBR0MsQ0FBSTtvQkFBQ0QsU0FBUyxFQUFDLENBQVc7OEJBQUVWLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDVyxJQUFJOzs7Ozs7Z0JBQVEsQ0FBcUM7Z0JBQUMsQ0FBRzs0RkFDekhELENBQUk7b0JBQUNELFNBQVMsRUFBQyxDQUFXOzhCQUFFVixHQUFHLENBQUNFLFFBQVEsQ0FBQ1UsSUFBSTs7Ozs7O2dCQUFRLENBQ3hEOzs7Ozs7Ozs7Ozs7QUFXTixDQUFDO0tBMUJxQmIsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2Rpc3RhbmNlLnRzeD85MmY2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbW11dGVzUGVyWWVhciA9IDI2MCAqIDI7XG5jb25zdCBsaXRyZXNQZXJLTSA9IDEwIC8gMTAwO1xuY29uc3QgZ2FzTGl0cmVDb3N0ID0gMS41O1xuY29uc3QgbGl0cmVDb3N0S00gPSBsaXRyZXNQZXJLTSAqIGdhc0xpdHJlQ29zdDtcbmNvbnN0IHNlY29uZHNQZXJEYXkgPSA2MCAqIDYwICogMjQ7XG5cbnR5cGUgRGlzdGFuY2VQcm9wcyA9IHtcbiAgbGVnOiBnb29nbGUubWFwcy5EaXJlY3Rpb25zTGVnO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlzdGFuY2UoeyBsZWcgfTogRGlzdGFuY2VQcm9wcykge1xuICBpZiAoIWxlZy5kaXN0YW5jZSB8fCAhbGVnLmR1cmF0aW9uKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihcbiAgICAoY29tbXV0ZXNQZXJZZWFyICogbGVnLmR1cmF0aW9uLnZhbHVlKSAvIHNlY29uZHNQZXJEYXlcbiAgKTtcbiAgY29uc3QgY29zdCA9IE1hdGguZmxvb3IoXG4gICAgKGxlZy5kaXN0YW5jZS52YWx1ZSAvIDEwMDApICogbGl0cmVDb3N0S00gKiBjb21tdXRlc1BlclllYXJcbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8cCBjbGFzc05hbWU9XCJyZXNwb25zZS1wXCI+XG4gICAgICAgIE8gc3Vwb3J0ZSBlc2NvbGhpZG8gZXN0w6Egw6AgPHNwYW4gY2xhc3NOYW1lPVwiaGlnaGxpZ2h0XCI+e2xlZy5kaXN0YW5jZS50ZXh0fTwvc3Bhbj4gZGUgZGlzdMOibmNpYSBkZSB2b2PDqi4gSXNzbyBpcsOhIGxldmFye1wiIFwifVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJoaWdobGlnaHRcIj57bGVnLmR1cmF0aW9uLnRleHR9PC9zcGFuPi5cbiAgICAgIDwvcD5cbiAgICAgIHsvKiA8cD5cbiAgICAgICAgVGhhdCdzIDxzcGFuIGNsYXNzTmFtZT1cImhpZ2hsaWdodFwiPntkYXlzfSBkYXlzPC9zcGFuPiBpbiB5b3VyIGNhciBlYWNoXG4gICAgICAgIHllYXIgYXQgYSBjb3N0IG9me1wiIFwifVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJoaWdobGlnaHRcIj5cbiAgICAgICAgICAke25ldyBJbnRsLk51bWJlckZvcm1hdCgpLmZvcm1hdChjb3N0KX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICAuXG4gICAgICA8L3A+ICovfVxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbImNvbW11dGVzUGVyWWVhciIsImxpdHJlc1BlcktNIiwiZ2FzTGl0cmVDb3N0IiwibGl0cmVDb3N0S00iLCJzZWNvbmRzUGVyRGF5IiwiRGlzdGFuY2UiLCJsZWciLCJkaXN0YW5jZSIsImR1cmF0aW9uIiwiZGF5cyIsIk1hdGgiLCJmbG9vciIsInZhbHVlIiwiY29zdCIsImRpdiIsInAiLCJjbGFzc05hbWUiLCJzcGFuIiwidGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/distance.tsx\n");

/***/ }),

/***/ "./components/map.tsx":
/*!****************************!*\
  !*** ./components/map.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Map; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-google-maps/api */ \"./node_modules/@react-google-maps/api/dist/esm.js\");\n/* harmony import */ var _places__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./places */ \"./components/places.tsx\");\n/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./distance */ \"./components/distance.tsx\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nvar _s = $RefreshSig$();\nfunction Map() {\n    var _this = this;\n    _s();\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), office = ref2[0], setOffice = ref2[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), directions = ref1[0], setDirections = ref1[1];\n    var mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    var center = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return {\n            lat: -23.56,\n            lng: -46.65\n        };\n    }, []);\n    var options = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return {\n            mapId: \"9538c46c9114ceaf\",\n            disableDefaultUI: true,\n            clickableIcons: false\n        };\n    }, []);\n    var onLoad = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(map) {\n        return mapRef.current = map;\n    }, []);\n    var houses = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return generateHouses(center);\n    }, [\n        center\n    ]);\n    var fetchDirections = function(house) {\n        if (!office) return;\n        var service = new google.maps.DirectionsService();\n        service.route({\n            origin: house,\n            destination: office,\n            travelMode: google.maps.TravelMode.DRIVING\n        }, function(result, status) {\n            if (status === \"OK\" && result) {\n                setDirections(result);\n            }\n        });\n    };\n    return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"controls\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"controls-title\",\n                        children: \"OnHome Suporte\"\n                    }, void 0, false, {\n                        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_places__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        setOffice: function(position) {\n                            var ref;\n                            setOffice(position);\n                            (ref = mapRef.current) === null || ref === void 0 ? void 0 : ref.panTo(position);\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 9\n                    }, this),\n                    !office && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {}, void 0, false, {\n                        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 21\n                    }, this),\n                    directions && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_distance__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        leg: directions.routes[0].legs[0]\n                    }, void 0, false, {\n                        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                        lineNumber: 64,\n                        columnNumber: 24\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"map\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.GoogleMap, {\n                    zoom: 11,\n                    center: center,\n                    mapContainerClassName: \"map-container\",\n                    options: options,\n                    onLoad: onLoad,\n                    children: [\n                        directions && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.DirectionsRenderer, {\n                            directions: directions,\n                            options: {\n                                polylineOptions: {\n                                    zIndex: 50,\n                                    strokeColor: \"#1976D2\",\n                                    strokeWeight: 5\n                                }\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                            lineNumber: 75,\n                            columnNumber: 13\n                        }, this),\n                        office && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.Marker, {\n                                    position: office,\n                                    icon: \"https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                    lineNumber: 89,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.MarkerClusterer, {\n                                    children: function(clusterer) {\n                                        return houses.map(function(house) {\n                                            /*#__PURE__*/ return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.Marker, {\n                                                position: house,\n                                                clusterer: clusterer,\n                                                onClick: function() {\n                                                    fetchDirections(house);\n                                                }\n                                            }, house.lat, false, {\n                                                fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                                lineNumber: 97,\n                                                columnNumber: 21\n                                            }, _this);\n                                        });\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                    lineNumber: 94,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.Circle, {\n                                    center: office,\n                                    radius: 2000,\n                                    options: closeOptions\n                                }, void 0, false, {\n                                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                    lineNumber: 109,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.Circle, {\n                                    center: office,\n                                    radius: 4000,\n                                    options: middleOptions\n                                }, void 0, false, {\n                                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                    lineNumber: 110,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_4__.Circle, {\n                                    center: office,\n                                    radius: 7000,\n                                    options: farOptions\n                                }, void 0, false, {\n                                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                                    lineNumber: 111,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                    lineNumber: 67,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n                lineNumber: 66,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/map.tsx\",\n        lineNumber: 54,\n        columnNumber: 5\n    }, this));\n};\n_s(Map, \"iJ3rrUepcW14/ibFO/XUOsDb+YI=\");\n_c = Map;\nvar defaultOptions = {\n    strokeOpacity: 0.5,\n    strokeWeight: 2,\n    clickable: false,\n    draggable: false,\n    editable: false,\n    visible: true\n};\nvar closeOptions = _objectSpread({}, defaultOptions, {\n    zIndex: 3,\n    fillOpacity: 0.05,\n    strokeColor: \"#8BC34A\",\n    fillColor: \"#8BC34A\"\n});\nvar middleOptions = _objectSpread({}, defaultOptions, {\n    zIndex: 2,\n    fillOpacity: 0.05,\n    strokeColor: \"#FBC02D\",\n    fillColor: \"#FBC02D\"\n});\nvar farOptions = _objectSpread({}, defaultOptions, {\n    zIndex: 1,\n    fillOpacity: 0.05,\n    strokeColor: \"#FF5252\",\n    fillColor: \"#FF5252\"\n});\nvar generateHouses = function(position) {\n    var _houses = [];\n    for(var i = 0; i < 100; i++){\n        var direction = Math.random() < 0.5 ? -2 : 2;\n        _houses.push({\n            lat: position.lat + Math.random() / direction,\n            lng: position.lng + Math.random() / direction\n        });\n    }\n    return _houses;\n};\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxHQUFJLENBQUM7UUFDN0IsR0FBSyxDQUFDQyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUM5Q0osT0FBTyxDQUFDSyxJQUFJLENBQUMsQ0FBQztZQUNaNUQsR0FBRyxFQUFFNEIsUUFBUSxDQUFDNUIsR0FBRyxHQUFHMEQsSUFBSSxDQUFDQyxNQUFNLEtBQUtGLFNBQVM7WUFDN0N4RCxHQUFHLEVBQUUyQixRQUFRLENBQUMzQixHQUFHLEdBQUd5RCxJQUFJLENBQUNDLE1BQU0sS0FBS0YsU0FBUztRQUMvQyxDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sQ0FBQ0YsT0FBTztBQUNoQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvbWFwLnRzeD9lNWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBHb29nbGVNYXAsXG4gIE1hcmtlcixcbiAgRGlyZWN0aW9uc1JlbmRlcmVyLFxuICBDaXJjbGUsXG4gIE1hcmtlckNsdXN0ZXJlcixcbn0gZnJvbSBcIkByZWFjdC1nb29nbGUtbWFwcy9hcGlcIjtcbmltcG9ydCBQbGFjZXMgZnJvbSBcIi4vcGxhY2VzXCI7XG5pbXBvcnQgRGlzdGFuY2UgZnJvbSBcIi4vZGlzdGFuY2VcIjtcblxudHlwZSBMYXRMbmdMaXRlcmFsID0gZ29vZ2xlLm1hcHMuTGF0TG5nTGl0ZXJhbDtcbnR5cGUgRGlyZWN0aW9uc1Jlc3VsdCA9IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZXN1bHQ7XG50eXBlIE1hcE9wdGlvbnMgPSBnb29nbGUubWFwcy5NYXBPcHRpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXAoKSB7XG4gIGNvbnN0IFtvZmZpY2UsIHNldE9mZmljZV0gPSB1c2VTdGF0ZTxMYXRMbmdMaXRlcmFsPigpO1xuICBjb25zdCBbZGlyZWN0aW9ucywgc2V0RGlyZWN0aW9uc10gPSB1c2VTdGF0ZTxEaXJlY3Rpb25zUmVzdWx0PigpO1xuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8R29vZ2xlTWFwPigpO1xuICBjb25zdCBjZW50ZXIgPSB1c2VNZW1vPExhdExuZ0xpdGVyYWw+KFxuICAgICgpID0+ICh7IGxhdDogLTIzLjU2LCBsbmc6IC00Ni42NSB9KSxcbiAgICBbXVxuICApO1xuICBjb25zdCBvcHRpb25zID0gdXNlTWVtbzxNYXBPcHRpb25zPihcbiAgICAoKSA9PiAoe1xuICAgICAgbWFwSWQ6IFwiOTUzOGM0NmM5MTE0Y2VhZlwiLFxuICAgICAgZGlzYWJsZURlZmF1bHRVSTogdHJ1ZSxcbiAgICAgIGNsaWNrYWJsZUljb25zOiBmYWxzZSxcbiAgICB9KSxcbiAgICBbXVxuICApO1xuICBjb25zdCBvbkxvYWQgPSB1c2VDYWxsYmFjaygobWFwKSA9PiAobWFwUmVmLmN1cnJlbnQgPSBtYXApLCBbXSk7XG4gIGNvbnN0IGhvdXNlcyA9IHVzZU1lbW8oKCkgPT4gZ2VuZXJhdGVIb3VzZXMoY2VudGVyKSwgW2NlbnRlcl0pO1xuXG4gIGNvbnN0IGZldGNoRGlyZWN0aW9ucyA9IChob3VzZTogTGF0TG5nTGl0ZXJhbCkgPT4ge1xuICAgIGlmICghb2ZmaWNlKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTZXJ2aWNlKCk7XG4gICAgc2VydmljZS5yb3V0ZShcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luOiBob3VzZSxcbiAgICAgICAgZGVzdGluYXRpb246IG9mZmljZSxcbiAgICAgICAgdHJhdmVsTW9kZTogZ29vZ2xlLm1hcHMuVHJhdmVsTW9kZS5EUklWSU5HLFxuICAgICAgfSxcbiAgICAgIChyZXN1bHQsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcIk9LXCIgJiYgcmVzdWx0KSB7XG4gICAgICAgICAgc2V0RGlyZWN0aW9ucyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJjb250cm9scy10aXRsZVwiPk9uSG9tZSBTdXBvcnRlPC9oMT5cbiAgICAgICAgPFBsYWNlc1xuICAgICAgICAgIHNldE9mZmljZT17KHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXRPZmZpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgbWFwUmVmLmN1cnJlbnQ/LnBhblRvKHBvc2l0aW9uKTtcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICB7IW9mZmljZSAmJiA8cD48L3A+fVxuICAgICAgICB7ZGlyZWN0aW9ucyAmJiA8RGlzdGFuY2UgbGVnPXtkaXJlY3Rpb25zLnJvdXRlc1swXS5sZWdzWzBdfSAvPn1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXBcIj5cbiAgICAgICAgPEdvb2dsZU1hcFxuICAgICAgICAgIHpvb209ezExfVxuICAgICAgICAgIGNlbnRlcj17Y2VudGVyfVxuICAgICAgICAgIG1hcENvbnRhaW5lckNsYXNzTmFtZT1cIm1hcC1jb250YWluZXJcIlxuICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgICAgb25Mb2FkPXtvbkxvYWR9XG4gICAgICAgID5cbiAgICAgICAgICB7ZGlyZWN0aW9ucyAmJiAoXG4gICAgICAgICAgICA8RGlyZWN0aW9uc1JlbmRlcmVyXG4gICAgICAgICAgICAgIGRpcmVjdGlvbnM9e2RpcmVjdGlvbnN9XG4gICAgICAgICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICBwb2x5bGluZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgIHpJbmRleDogNTAsXG4gICAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogXCIjMTk3NkQyXCIsXG4gICAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHtvZmZpY2UgJiYgKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPE1hcmtlclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uPXtvZmZpY2V9XG4gICAgICAgICAgICAgICAgaWNvbj1cImh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2V4YW1wbGVzL2Z1bGwvaW1hZ2VzL2JlYWNoZmxhZy5wbmdcIlxuICAgICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICAgIDxNYXJrZXJDbHVzdGVyZXI+XG4gICAgICAgICAgICAgICAgeyhjbHVzdGVyZXIpID0+XG4gICAgICAgICAgICAgICAgICBob3VzZXMubWFwKChob3VzZSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8TWFya2VyXG4gICAgICAgICAgICAgICAgICAgICAga2V5PXtob3VzZS5sYXR9XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb249e2hvdXNlfVxuICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJlcj17Y2x1c3RlcmVyfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoRGlyZWN0aW9ucyhob3VzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8L01hcmtlckNsdXN0ZXJlcj5cblxuICAgICAgICAgICAgICA8Q2lyY2xlIGNlbnRlcj17b2ZmaWNlfSByYWRpdXM9ezIwMDB9IG9wdGlvbnM9e2Nsb3NlT3B0aW9uc30gLz5cbiAgICAgICAgICAgICAgPENpcmNsZSBjZW50ZXI9e29mZmljZX0gcmFkaXVzPXs0MDAwfSBvcHRpb25zPXttaWRkbGVPcHRpb25zfSAvPlxuICAgICAgICAgICAgICA8Q2lyY2xlIGNlbnRlcj17b2ZmaWNlfSByYWRpdXM9ezcwMDB9IG9wdGlvbnM9e2Zhck9wdGlvbnN9IC8+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICApfVxuICAgICAgICA8L0dvb2dsZU1hcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3Ryb2tlT3BhY2l0eTogMC41LFxuICBzdHJva2VXZWlnaHQ6IDIsXG4gIGNsaWNrYWJsZTogZmFsc2UsXG4gIGRyYWdnYWJsZTogZmFsc2UsXG4gIGVkaXRhYmxlOiBmYWxzZSxcbiAgdmlzaWJsZTogdHJ1ZSxcbn07XG5jb25zdCBjbG9zZU9wdGlvbnMgPSB7XG4gIC4uLmRlZmF1bHRPcHRpb25zLFxuICB6SW5kZXg6IDMsXG4gIGZpbGxPcGFjaXR5OiAwLjA1LFxuICBzdHJva2VDb2xvcjogXCIjOEJDMzRBXCIsXG4gIGZpbGxDb2xvcjogXCIjOEJDMzRBXCIsXG59O1xuY29uc3QgbWlkZGxlT3B0aW9ucyA9IHtcbiAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gIHpJbmRleDogMixcbiAgZmlsbE9wYWNpdHk6IDAuMDUsXG4gIHN0cm9rZUNvbG9yOiBcIiNGQkMwMkRcIixcbiAgZmlsbENvbG9yOiBcIiNGQkMwMkRcIixcbn07XG5jb25zdCBmYXJPcHRpb25zID0ge1xuICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgekluZGV4OiAxLFxuICBmaWxsT3BhY2l0eTogMC4wNSxcbiAgc3Ryb2tlQ29sb3I6IFwiI0ZGNTI1MlwiLFxuICBmaWxsQ29sb3I6IFwiI0ZGNTI1MlwiLFxufTtcblxuY29uc3QgZ2VuZXJhdGVIb3VzZXMgPSAocG9zaXRpb246IExhdExuZ0xpdGVyYWwpID0+IHtcbiAgY29uc3QgX2hvdXNlczogQXJyYXk8TGF0TG5nTGl0ZXJhbD4gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAtMiA6IDI7XG4gICAgX2hvdXNlcy5wdXNoKHtcbiAgICAgIGxhdDogcG9zaXRpb24ubGF0ICsgTWF0aC5yYW5kb20oKSAvIGRpcmVjdGlvbixcbiAgICAgIGxuZzogcG9zaXRpb24ubG5nICsgTWF0aC5yYW5kb20oKSAvIGRpcmVjdGlvbixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gX2hvdXNlcztcbn07XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJHb29nbGVNYXAiLCJNYXJrZXIiLCJEaXJlY3Rpb25zUmVuZGVyZXIiLCJDaXJjbGUiLCJNYXJrZXJDbHVzdGVyZXIiLCJQbGFjZXMiLCJEaXN0YW5jZSIsIk1hcCIsIm9mZmljZSIsInNldE9mZmljZSIsImRpcmVjdGlvbnMiLCJzZXREaXJlY3Rpb25zIiwibWFwUmVmIiwiY2VudGVyIiwibGF0IiwibG5nIiwib3B0aW9ucyIsIm1hcElkIiwiZGlzYWJsZURlZmF1bHRVSSIsImNsaWNrYWJsZUljb25zIiwib25Mb2FkIiwibWFwIiwiY3VycmVudCIsImhvdXNlcyIsImdlbmVyYXRlSG91c2VzIiwiZmV0Y2hEaXJlY3Rpb25zIiwiaG91c2UiLCJzZXJ2aWNlIiwiZ29vZ2xlIiwibWFwcyIsIkRpcmVjdGlvbnNTZXJ2aWNlIiwicm91dGUiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsInRyYXZlbE1vZGUiLCJUcmF2ZWxNb2RlIiwiRFJJVklORyIsInJlc3VsdCIsInN0YXR1cyIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwicG9zaXRpb24iLCJwYW5UbyIsInAiLCJsZWciLCJyb3V0ZXMiLCJsZWdzIiwiem9vbSIsIm1hcENvbnRhaW5lckNsYXNzTmFtZSIsInBvbHlsaW5lT3B0aW9ucyIsInpJbmRleCIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2VpZ2h0IiwiaWNvbiIsImNsdXN0ZXJlciIsIm9uQ2xpY2siLCJyYWRpdXMiLCJjbG9zZU9wdGlvbnMiLCJtaWRkbGVPcHRpb25zIiwiZmFyT3B0aW9ucyIsImRlZmF1bHRPcHRpb25zIiwic3Ryb2tlT3BhY2l0eSIsImNsaWNrYWJsZSIsImRyYWdnYWJsZSIsImVkaXRhYmxlIiwidmlzaWJsZSIsImZpbGxPcGFjaXR5IiwiZmlsbENvbG9yIiwiX2hvdXNlcyIsImkiLCJkaXJlY3Rpb24iLCJNYXRoIiwicmFuZG9tIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/map.tsx\n");

/***/ }),

/***/ "./components/places.tsx":
/*!*******************************!*\
  !*** ./components/places.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Places; }\n/* harmony export */ });\n/* harmony import */ var _Users_fcamara_Documents_sptech_projetos_sptech_onhome_maps_api_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var _Users_fcamara_Documents_sptech_projetos_sptech_onhome_maps_api_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_fcamara_Documents_sptech_projetos_sptech_onhome_maps_api_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var use_places_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-places-autocomplete */ \"./node_modules/use-places-autocomplete/dist/index.esm.js\");\n/* harmony import */ var _reach_combobox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reach/combobox */ \"./node_modules/@reach/combobox/dist/reach-combobox.esm.js\");\n/* harmony import */ var _reach_combobox_styles_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/combobox/styles.css */ \"./node_modules/@reach/combobox/styles.css\");\n/* harmony import */ var _reach_combobox_styles_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_reach_combobox_styles_css__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nvar _s = $RefreshSig$();\nfunction Places(param1) {\n    var setOffice = param1.setOffice;\n    var _this = this;\n    _s();\n    var ref1 = (0,use_places_autocomplete__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), ready = ref1.ready, value = ref1.value, setValue = ref1.setValue, _suggestions = ref1.suggestions, status = _suggestions.status, data = _suggestions.data, clearSuggestions = ref1.clearSuggestions;\n    var handleSelect = function() {\n        var _ref = _asyncToGenerator(_Users_fcamara_Documents_sptech_projetos_sptech_onhome_maps_api_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(val) {\n            var results, ref, lat, lng;\n            return _Users_fcamara_Documents_sptech_projetos_sptech_onhome_maps_api_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        setValue(val, false);\n                        clearSuggestions();\n                        _ctx.next = 4;\n                        return (0,use_places_autocomplete__WEBPACK_IMPORTED_MODULE_2__.getGeocode)({\n                            address: val\n                        });\n                    case 4:\n                        results = _ctx.sent;\n                        _ctx.next = 7;\n                        return (0,use_places_autocomplete__WEBPACK_IMPORTED_MODULE_2__.getLatLng)(results[0]);\n                    case 7:\n                        ref = _ctx.sent;\n                        lat = ref.lat;\n                        lng = ref.lng;\n                        setOffice({\n                            lat: lat,\n                            lng: lng\n                        });\n                    case 11:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee);\n        }));\n        return function handleSelect(val) {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_reach_combobox__WEBPACK_IMPORTED_MODULE_4__.Combobox, {\n        onSelect: handleSelect,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_reach_combobox__WEBPACK_IMPORTED_MODULE_4__.ComboboxInput, {\n                value: value,\n                onChange: function(e) {\n                    return setValue(e.target.value);\n                },\n                disabled: !ready,\n                className: \"combobox-input\",\n                placeholder: \"Onde voc\\xea est\\xe1?\"\n            }, void 0, false, {\n                fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/places.tsx\",\n                lineNumber: 38,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_reach_combobox__WEBPACK_IMPORTED_MODULE_4__.ComboboxPopover, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_reach_combobox__WEBPACK_IMPORTED_MODULE_4__.ComboboxList, {\n                    children: status === \"OK\" && data.map(function(param) {\n                        var place_id = param.place_id, description = param.description;\n                        /*#__PURE__*/ return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_reach_combobox__WEBPACK_IMPORTED_MODULE_4__.ComboboxOption, {\n                            value: description\n                        }, place_id, false, {\n                            fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/places.tsx\",\n                            lineNumber: 49,\n                            columnNumber: 15\n                        }, _this);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/places.tsx\",\n                    lineNumber: 46,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/places.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/components/places.tsx\",\n        lineNumber: 37,\n        columnNumber: 5\n    }, this));\n};\n_s(Places, \"thdSH5dLDpXDOr88sGg6kqFV+gs=\", false, function() {\n    return [\n        use_places_autocomplete__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    ];\n});\n_c = Places;\nvar _c;\n$RefreshReg$(_c, \"Places\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3BsYWNlcy50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBR2dDO0FBT1I7QUFDVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1wQixRQUFRLENBQUNRLE1BQU0sQ0FBQyxNQUEwQixFQUFFLENBQUM7UUFBM0JDLFNBQVMsR0FBWCxNQUEwQixDQUF4QkEsU0FBUzs7O0lBQ3hDLEdBQUssQ0FNRFQsSUFBdUIsR0FBdkJBLG1FQUFxQixJQUx2QlUsS0FBSyxHQUtIVixJQUF1QixDQUx6QlUsS0FBSyxFQUNMQyxLQUFLLEdBSUhYLElBQXVCLENBSnpCVyxLQUFLLEVBQ0xDLFFBQVEsR0FHTlosSUFBdUIsQ0FIekJZLFFBQVEsaUJBR05aLElBQXVCLENBRnpCYSxXQUFXLEVBQUlDLE1BQU0sZ0JBQU5BLE1BQU0sRUFBRUMsSUFBSSxnQkFBSkEsSUFBSSxFQUMzQkMsZ0JBQWdCLEdBQ2RoQixJQUF1QixDQUR6QmdCLGdCQUFnQjtJQUdsQixHQUFLLENBQUNDLFlBQVk7Z05BQUcsUUFBUSxTQUFEQyxHQUFXLEVBQUssQ0FBQztnQkFJckNDLE9BQU8sRUFDUSxHQUEyQixFQUF4Q0MsR0FBRyxFQUFFQyxHQUFHOzs7O3dCQUpoQlQsUUFBUSxDQUFDTSxHQUFHLEVBQUUsS0FBSzt3QkFDbkJGLGdCQUFnQjs7K0JBRU1mLG1FQUFVLENBQUMsQ0FBQzs0QkFBQ3FCLE9BQU8sRUFBRUosR0FBRzt3QkFBQyxDQUFDOzt3QkFBM0NDLE9BQU87OytCQUNjakIsa0VBQVMsQ0FBQ2lCLE9BQU8sQ0FBQyxDQUFDOzt3QkFBekIsR0FBMkI7d0JBQXhDQyxHQUFHLEdBQVUsR0FBMkIsQ0FBeENBLEdBQUc7d0JBQUVDLEdBQUcsR0FBSyxHQUEyQixDQUFuQ0EsR0FBRzt3QkFDaEJaLFNBQVMsQ0FBQyxDQUFDOzRCQUFDVyxHQUFHLEVBQUhBLEdBQUc7NEJBQUVDLEdBQUcsRUFBSEEsR0FBRzt3QkFBQyxDQUFDOzs7Ozs7UUFDeEIsQ0FBQzt3QkFQS0osWUFBWSxDQUFVQyxHQUFXOzs7O0lBU3ZDLE1BQU0sNkVBQ0hmLHFEQUFRO1FBQUNvQixRQUFRLEVBQUVOLFlBQVk7O3dGQUM3QmIsMERBQWE7Z0JBQ1pPLEtBQUssRUFBRUEsS0FBSztnQkFDWmEsUUFBUSxFQUFFLFFBQVEsQ0FBUEMsQ0FBQztvQkFBS2IsTUFBTSxDQUFOQSxRQUFRLENBQUNhLENBQUMsQ0FBQ0MsTUFBTSxDQUFDZixLQUFLOztnQkFDeENnQixRQUFRLEdBQUdqQixLQUFLO2dCQUNoQmtCLFNBQVMsRUFBQyxDQUFnQjtnQkFDMUJDLFdBQVcsRUFBQyxDQUFpQjs7Ozs7O3dGQUU5QnhCLDREQUFlO3NHQUNiQyx5REFBWTs4QkFDVlEsTUFBTSxLQUFLLENBQUksT0FDZEMsSUFBSSxDQUFDZSxHQUFHLENBQUMsUUFBUTs0QkFBTEMsUUFBUSxTQUFSQSxRQUFRLEVBQUVDLFdBQVcsU0FBWEEsV0FBVztzQ0FDL0IsTUFBTSwrREFBTHpCLDJEQUFjOzRCQUFnQkksS0FBSyxFQUFFcUIsV0FBVzsyQkFBNUJELFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNM0MsQ0FBQztHQXJDdUJ2QixNQUFNOztRQU94QlIsK0RBQXFCOzs7S0FQSFEsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL3BsYWNlcy50c3g/MDc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXNlUGxhY2VzQXV0b2NvbXBsZXRlLCB7XG4gIGdldEdlb2NvZGUsXG4gIGdldExhdExuZyxcbn0gZnJvbSBcInVzZS1wbGFjZXMtYXV0b2NvbXBsZXRlXCI7XG5pbXBvcnQge1xuICBDb21ib2JveCxcbiAgQ29tYm9ib3hJbnB1dCxcbiAgQ29tYm9ib3hQb3BvdmVyLFxuICBDb21ib2JveExpc3QsXG4gIENvbWJvYm94T3B0aW9uLFxufSBmcm9tIFwiQHJlYWNoL2NvbWJvYm94XCI7XG5pbXBvcnQgXCJAcmVhY2gvY29tYm9ib3gvc3R5bGVzLmNzc1wiO1xuXG50eXBlIFBsYWNlc1Byb3BzID0ge1xuICBzZXRPZmZpY2U6IChwb3NpdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nTGl0ZXJhbCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBsYWNlcyh7IHNldE9mZmljZSB9OiBQbGFjZXNQcm9wcykge1xuICBjb25zdCB7XG4gICAgcmVhZHksXG4gICAgdmFsdWUsXG4gICAgc2V0VmFsdWUsXG4gICAgc3VnZ2VzdGlvbnM6IHsgc3RhdHVzLCBkYXRhIH0sXG4gICAgY2xlYXJTdWdnZXN0aW9ucyxcbiAgfSA9IHVzZVBsYWNlc0F1dG9jb21wbGV0ZSgpO1xuXG4gIGNvbnN0IGhhbmRsZVNlbGVjdCA9IGFzeW5jICh2YWw6IHN0cmluZykgPT4ge1xuICAgIHNldFZhbHVlKHZhbCwgZmFsc2UpO1xuICAgIGNsZWFyU3VnZ2VzdGlvbnMoKTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBnZXRHZW9jb2RlKHsgYWRkcmVzczogdmFsIH0pO1xuICAgIGNvbnN0IHsgbGF0LCBsbmcgfSA9IGF3YWl0IGdldExhdExuZyhyZXN1bHRzWzBdKTtcbiAgICBzZXRPZmZpY2UoeyBsYXQsIGxuZyB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxDb21ib2JveCBvblNlbGVjdD17aGFuZGxlU2VsZWN0fT5cbiAgICAgIDxDb21ib2JveElucHV0XG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgIGRpc2FibGVkPXshcmVhZHl9XG4gICAgICAgIGNsYXNzTmFtZT1cImNvbWJvYm94LWlucHV0XCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJPbmRlIHZvY8OqIGVzdMOhP1wiXG4gICAgICAvPlxuICAgICAgPENvbWJvYm94UG9wb3Zlcj5cbiAgICAgICAgPENvbWJvYm94TGlzdD5cbiAgICAgICAgICB7c3RhdHVzID09PSBcIk9LXCIgJiZcbiAgICAgICAgICAgIGRhdGEubWFwKCh7IHBsYWNlX2lkLCBkZXNjcmlwdGlvbiB9KSA9PiAoXG4gICAgICAgICAgICAgIDxDb21ib2JveE9wdGlvbiBrZXk9e3BsYWNlX2lkfSB2YWx1ZT17ZGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC9Db21ib2JveExpc3Q+XG4gICAgICA8L0NvbWJvYm94UG9wb3Zlcj5cbiAgICA8L0NvbWJvYm94PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVBsYWNlc0F1dG9jb21wbGV0ZSIsImdldEdlb2NvZGUiLCJnZXRMYXRMbmciLCJDb21ib2JveCIsIkNvbWJvYm94SW5wdXQiLCJDb21ib2JveFBvcG92ZXIiLCJDb21ib2JveExpc3QiLCJDb21ib2JveE9wdGlvbiIsIlBsYWNlcyIsInNldE9mZmljZSIsInJlYWR5IiwidmFsdWUiLCJzZXRWYWx1ZSIsInN1Z2dlc3Rpb25zIiwic3RhdHVzIiwiZGF0YSIsImNsZWFyU3VnZ2VzdGlvbnMiLCJoYW5kbGVTZWxlY3QiLCJ2YWwiLCJyZXN1bHRzIiwibGF0IiwibG5nIiwiYWRkcmVzcyIsIm9uU2VsZWN0Iiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwiZGlzYWJsZWQiLCJjbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIm1hcCIsInBsYWNlX2lkIiwiZGVzY3JpcHRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/places.tsx\n");

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-google-maps/api */ \"./node_modules/@react-google-maps/api/dist/esm.js\");\n/* harmony import */ var _components_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/map */ \"./components/map.tsx\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\nvar _s = $RefreshSig$();\nfunction Home() {\n    _s();\n    var isLoaded = (0,_react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.useLoadScript)({\n        googleMapsApiKey: \"\",\n        libraries: [\n            \"places\"\n        ]\n    }).isLoaded;\n    if (!isLoaded) return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"Loading...\"\n    }, void 0, false, {\n        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/pages/index.tsx\",\n        lineNumber: 10,\n        columnNumber: 25\n    }, this));\n    return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"/Users/fcamara/Documents/sptech/projetos-sptech/onhome-maps-api/pages/index.tsx\",\n        lineNumber: 11,\n        columnNumber: 10\n    }, this));\n};\n_s(Home, \"0WnOjCnOubliry/bcWK4XUbomlA=\", false, function() {\n    return [\n        _react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.useLoadScript\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRDtBQUNuQjs7QUFFcEIsUUFBUSxDQUFDRSxJQUFJLEdBQUcsQ0FBQzs7SUFDOUIsR0FBSyxDQUFHQyxRQUFRLEdBQUtILHFFQUFhLENBQUMsQ0FBQztRQUNsQ0ksZ0JBQWdCLEVBQUUsQ0FBRTtRQUNwQkMsU0FBUyxFQUFFLENBQUM7WUFBQSxDQUFRO1FBQUEsQ0FBQztJQUN2QixDQUFDLEVBSE9GLFFBQVE7SUFLaEIsRUFBRSxHQUFHQSxRQUFRLEVBQUUsTUFBTSw2RUFBRUcsQ0FBRztrQkFBQyxDQUFVOzs7Ozs7SUFDckMsTUFBTSw2RUFBRUwsdURBQUc7Ozs7O0FBQ2IsQ0FBQztHQVJ1QkMsSUFBSTs7UUFDTEYsaUVBQWE7OztLQURaRSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LnRzeD8wN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxvYWRTY3JpcHQgfSBmcm9tIFwiQHJlYWN0LWdvb2dsZS1tYXBzL2FwaVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vY29tcG9uZW50cy9tYXBcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc3QgeyBpc0xvYWRlZCB9ID0gdXNlTG9hZFNjcmlwdCh7XG4gICAgZ29vZ2xlTWFwc0FwaUtleTogXCJcIixcbiAgICBsaWJyYXJpZXM6IFtcInBsYWNlc1wiXSxcbiAgfSk7XG5cbiAgaWYgKCFpc0xvYWRlZCkgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAgcmV0dXJuIDxNYXAgLz47XG59XG4iXSwibmFtZXMiOlsidXNlTG9hZFNjcmlwdCIsIk1hcCIsIkhvbWUiLCJpc0xvYWRlZCIsImdvb2dsZU1hcHNBcGlLZXkiLCJsaWJyYXJpZXMiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.tsx\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module) {

eval("var __dirname = \"/\";\n(function(){var e={162:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(162);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MTYyOmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDE2Mik7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVc7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/MjYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELFVBQVUsbUJBQU8sQ0FBQyx1REFBVztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsQ0FBTTtBQUM3STtBQUNBOztBQUVBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2I3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELEVBQUUsS0FBSyxFQUlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2JkZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz9lMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module) {

eval("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanM/ZTQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/has.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/NDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGdJQUF5RDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/YjMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/tabbable/index.js":
/*!****************************************!*\
  !*** ./node_modules/tabbable/index.js ***!
  \****************************************/
/***/ (function(module) {

eval("var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanM/OGI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF0nLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG5dO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxudmFyIG1hdGNoZXMgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5mdW5jdGlvbiB0YWJiYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuXG4gIHZhciBjYW5kaWRhdGVzID0gZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3Rvcik7XG5cbiAgaWYgKG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcikge1xuICAgIGlmIChtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgICAgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShjYW5kaWRhdGVzKTtcbiAgICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGksIGNhbmRpZGF0ZSwgY2FuZGlkYXRlVGFiaW5kZXg7XG4gIGZvciAoaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgIGlmICghaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKGNhbmRpZGF0ZSkpIGNvbnRpbnVlO1xuXG4gICAgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChjYW5kaWRhdGUpO1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgcmVndWxhclRhYmJhYmxlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLm5vZGUgfSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG50YWJiYWJsZS5pc1RhYmJhYmxlID0gaXNUYWJiYWJsZTtcbnRhYmJhYmxlLmlzRm9jdXNhYmxlID0gaXNGb2N1c2FibGU7XG5cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShub2RlKSB7XG4gIGlmIChcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShub2RlKVxuICAgIHx8IGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKVxuICAgIHx8IGdldFRhYmluZGV4KG5vZGUpIDwgMFxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkXG4gICAgfHwgaXNIaWRkZW5JbnB1dChub2RlKVxuICAgIHx8IGlzSGlkZGVuKG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gY2FuZGlkYXRlU2VsZWN0b3JzLmNvbmNhdCgnaWZyYW1lJykuam9pbignLCcpO1xuZnVuY3Rpb24gaXNGb2N1c2FibGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldFRhYmluZGV4KG5vZGUpIHtcbiAgdmFyIHRhYmluZGV4QXR0ciA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmICghaXNOYU4odGFiaW5kZXhBdHRyKSkgcmV0dXJuIHRhYmluZGV4QXR0cjtcbiAgLy8gQnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgaWYgKGlzQ29udGVudEVkaXRhYmxlKG5vZGUpKSByZXR1cm4gMDtcbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59XG5cbmZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJztcbn1cblxuZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59XG5cbmZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufVxuXG5mdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufVxuXG5mdW5jdGlvbiBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSByZXR1cm4gdHJ1ZTtcbiAgLy8gVGhpcyB3b24ndCBhY2NvdW50IGZvciB0aGUgZWRnZSBjYXNlIHdoZXJlIHlvdSBoYXZlIHJhZGlvIGdyb3VwcyB3aXRoIHRoZSBzYW1lXG4gIC8vIGluIHNlcGFyYXRlIGZvcm1zIG9uIHRoZSBzYW1lIHBhZ2UuXG4gIHZhciByYWRpb1NldCA9IG5vZGUub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBub2RlLm5hbWUgKyAnXCJdJyk7XG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0KTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59XG5cbmZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUpIHtcbiAgLy8gb2Zmc2V0UGFyZW50IGJlaW5nIG51bGwgd2lsbCBhbGxvdyBkZXRlY3RpbmcgY2FzZXMgd2hlcmUgYW4gZWxlbWVudCBpcyBpbnZpc2libGUgb3IgaW5zaWRlIGFuIGludmlzaWJsZSBlbGVtZW50LFxuICAvLyBhcyBsb25nIGFzIHRoZSBlbGVtZW50IGRvZXMgbm90IHVzZSBwb3NpdGlvbjogZml4ZWQuIEZvciB0aGVtLCB0aGVpciB2aXNpYmlsaXR5IGhhcyB0byBiZSBjaGVja2VkIGRpcmVjdGx5IGFzIHdlbGwuXG4gIHJldHVybiBub2RlLm9mZnNldFBhcmVudCA9PT0gbnVsbCB8fCBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRhYmJhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tabbable/index.js\n");

/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar isProduction = \"development\" === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (warning);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGlueS13YXJuaW5nL2Rpc3QvdGlueS13YXJuaW5nLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsbUJBQW1CLGFBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwrREFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rpbnktd2FybmluZy9kaXN0L3Rpbnktd2FybmluZy5lc20uanM/NGU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gXCJXYXJuaW5nOiBcIiArIG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKHRleHQpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2FybmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tiny-warning/dist/tiny-warning.esm.js\n");

/***/ }),

/***/ "./node_modules/use-places-autocomplete/dist/index.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/use-places-autocomplete/dist/index.esm.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ usePlacesAutocomplete; },\n/* harmony export */   \"getDetails\": function() { return /* binding */ getDetails; },\n/* harmony export */   \"getGeocode\": function() { return /* binding */ getGeocode; },\n/* harmony export */   \"getLatLng\": function() { return /* binding */ getLatLng; },\n/* harmony export */   \"getZipCode\": function() { return /* binding */ getZipCode; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar useLatest = (function (val) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(val);\n  ref.current = val;\n  return ref;\n});\n\nvar _debounce = (function (fn, delay) {\n  var timer; // eslint-disable-next-line func-names\n\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    timer = setTimeout(function () {\n      return fn.apply(_this, args);\n    }, delay);\n  };\n});\n\nvar loadApiErr = \"ðŸ’¡ use-places-autocomplete: Google Maps Places API library must be loaded. See: https://github.com/wellyshen/use-places-autocomplete#load-the-library\";\n\nvar usePlacesAutocomplete = function usePlacesAutocomplete(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      requestOptions = _ref.requestOptions,\n      _ref$debounce = _ref.debounce,\n      debounce = _ref$debounce === void 0 ? 200 : _ref$debounce,\n      _ref$cache = _ref.cache,\n      cache = _ref$cache === void 0 ? 24 * 60 * 60 : _ref$cache,\n      cacheKey = _ref.cacheKey,\n      googleMaps = _ref.googleMaps,\n      callbackName = _ref.callbackName,\n      _ref$defaultValue = _ref.defaultValue,\n      defaultValue = _ref$defaultValue === void 0 ? \"\" : _ref$defaultValue,\n      _ref$initOnMount = _ref.initOnMount,\n      initOnMount = _ref$initOnMount === void 0 ? true : _ref$initOnMount;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      ready = _useState[0],\n      setReady = _useState[1];\n\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue),\n      value = _useState2[0],\n      setVal = _useState2[1];\n\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    loading: false,\n    status: \"\",\n    data: []\n  }),\n      suggestions = _useState3[0],\n      setSuggestions = _useState3[1];\n\n  var asRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var requestOptionsRef = useLatest(requestOptions);\n  var googleMapsRef = useLatest(googleMaps);\n  var upaCacheKey = cacheKey ? \"upa-\" + cacheKey : \"upa\";\n  var init = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    var _google$maps;\n\n    if (asRef.current) return;\n    var _window = window,\n        google = _window.google;\n    var gMaps = googleMapsRef.current;\n    var placesLib = (gMaps == null ? void 0 : gMaps.places) || (google == null ? void 0 : (_google$maps = google.maps) == null ? void 0 : _google$maps.places);\n\n    if (!placesLib) {\n      console.error(loadApiErr);\n      return;\n    }\n\n    asRef.current = new placesLib.AutocompleteService();\n    setReady(true);\n  }, []);\n  var clearSuggestions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    setSuggestions({\n      loading: false,\n      status: \"\",\n      data: []\n    });\n  }, []);\n  var clearCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    try {\n      sessionStorage.removeItem(upaCacheKey);\n    } catch (error) {// Skip exception\n    }\n  }, []);\n  var fetchPredictions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(_debounce(function (val) {\n    if (!val) {\n      clearSuggestions();\n      return;\n    }\n\n    setSuggestions(function (prevState) {\n      return _extends({}, prevState, {\n        loading: true\n      });\n    });\n    var cachedData = {};\n\n    try {\n      cachedData = JSON.parse(sessionStorage.getItem(upaCacheKey) || \"{}\");\n    } catch (error) {// Skip exception\n    }\n\n    if (cache) {\n      cachedData = Object.keys(cachedData).reduce(function (acc, key) {\n        if (cachedData[key].maxAge - Date.now() >= 0) acc[key] = cachedData[key];\n        return acc;\n      }, {});\n\n      if (cachedData[val]) {\n        setSuggestions({\n          loading: false,\n          status: \"OK\",\n          data: cachedData[val].data\n        });\n        return;\n      }\n    } // @ts-expect-error\n\n\n    asRef.current.getPlacePredictions(_extends({}, requestOptionsRef.current, {\n      input: val\n    }), function (data, status) {\n      setSuggestions({\n        loading: false,\n        status: status,\n        data: data || []\n      });\n\n      if (cache && status === \"OK\") {\n        cachedData[val] = {\n          data: data,\n          maxAge: Date.now() + cache * 1000\n        };\n\n        try {\n          sessionStorage.setItem(upaCacheKey, JSON.stringify(cachedData));\n        } catch (error) {// Skip exception\n        }\n      }\n    });\n  }, debounce), [debounce, clearSuggestions]);\n  var setValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (val, shouldFetchData) {\n    if (shouldFetchData === void 0) {\n      shouldFetchData = true;\n    }\n\n    setVal(val);\n    if (asRef.current && shouldFetchData) fetchPredictions(val);\n  }, [fetchPredictions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!initOnMount) return function () {\n      return null;\n    };\n    var _window2 = window,\n        google = _window2.google;\n\n    if (!googleMapsRef.current && !(google != null && google.maps) && callbackName) {\n      window[callbackName] = init;\n    } else {\n      init();\n    }\n\n    return function () {\n      // @ts-expect-error\n      if (window[callbackName]) delete window[callbackName];\n    };\n  }, [callbackName, init]);\n  return {\n    ready: ready,\n    value: value,\n    suggestions: suggestions,\n    setValue: setValue,\n    clearSuggestions: clearSuggestions,\n    clearCache: clearCache,\n    init: init\n  };\n};\n\n/* eslint-disable compat/compat */\nvar geocodeErr = \"ðŸ’¡ use-places-autocomplete: Please provide an address when using getGeocode() with the componentRestrictions.\";\nvar getGeocode = function getGeocode(args) {\n  var geocoder = new window.google.maps.Geocoder();\n  return new Promise(function (resolve, reject) {\n    geocoder.geocode(args, function (results, status) {\n      if (status !== \"OK\") reject(status);\n\n      if (!args.address && args.componentRestrictions) {\n        console.error(geocodeErr);\n        resolve(results);\n      }\n\n      resolve(results);\n    });\n  });\n};\nvar getLatLng = function getLatLng(result) {\n  return new Promise(function (resolve, reject) {\n    try {\n      var _result$geometry$loca = result.geometry.location,\n          lat = _result$geometry$loca.lat,\n          lng = _result$geometry$loca.lng;\n      resolve({\n        lat: lat(),\n        lng: lng()\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\nvar getZipCode = function getZipCode(result, useShortName) {\n  return new Promise(function (resolve, reject) {\n    try {\n      var zipCode = null;\n      result.address_components.forEach(function (_ref) {\n        var long_name = _ref.long_name,\n            short_name = _ref.short_name,\n            types = _ref.types;\n        if (types.includes(\"postal_code\")) zipCode = useShortName ? short_name : long_name;\n      });\n      resolve(zipCode);\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\nvar getDetailsErr = \"ðŸ’¡ use-places-autocomplete: Please provide a place Id when using getDetails() either as a string or as part of an Autocomplete Prediction.\";\nvar getDetails = function getDetails(args) {\n  var PlacesService = new window.google.maps.places.PlacesService(document.createElement(\"div\"));\n\n  if (!args.placeId) {\n    console.error(getDetailsErr);\n    return Promise.reject(getDetailsErr);\n  }\n\n  return new Promise(function (resolve, reject) {\n    PlacesService.getDetails(args, function (results, status) {\n      if (status !== \"OK\") reject(status);\n      resolve(results);\n    });\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXNlLXBsYWNlcy1hdXRvY29tcGxldGUvZGlzdC9pbmRleC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRTs7QUFFakU7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkNBQU07QUFDbEI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUEsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7O0FBRUEsbUJBQW1CLCtDQUFRO0FBQzNCO0FBQ0E7O0FBRUEsbUJBQW1CLCtDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGNBQWMsNkNBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBVztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBLE1BQU0sZUFBZTtBQUNyQjtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFLE1BQU0sZUFBZTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxpQkFBaUIsa0RBQVc7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFMkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1wbGFjZXMtYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguZXNtLmpzPzU0OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIHVzZUxhdGVzdCA9IChmdW5jdGlvbiAodmFsKSB7XG4gIHZhciByZWYgPSB1c2VSZWYodmFsKTtcbiAgcmVmLmN1cnJlbnQgPSB2YWw7XG4gIHJldHVybiByZWY7XG59KTtcblxudmFyIF9kZWJvdW5jZSA9IChmdW5jdGlvbiAoZm4sIGRlbGF5KSB7XG4gIHZhciB0aW1lcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn0pO1xuXG52YXIgbG9hZEFwaUVyciA9IFwi8J+SoSB1c2UtcGxhY2VzLWF1dG9jb21wbGV0ZTogR29vZ2xlIE1hcHMgUGxhY2VzIEFQSSBsaWJyYXJ5IG11c3QgYmUgbG9hZGVkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWxseXNoZW4vdXNlLXBsYWNlcy1hdXRvY29tcGxldGUjbG9hZC10aGUtbGlicmFyeVwiO1xuXG52YXIgdXNlUGxhY2VzQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gdXNlUGxhY2VzQXV0b2NvbXBsZXRlKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICByZXF1ZXN0T3B0aW9ucyA9IF9yZWYucmVxdWVzdE9wdGlvbnMsXG4gICAgICBfcmVmJGRlYm91bmNlID0gX3JlZi5kZWJvdW5jZSxcbiAgICAgIGRlYm91bmNlID0gX3JlZiRkZWJvdW5jZSA9PT0gdm9pZCAwID8gMjAwIDogX3JlZiRkZWJvdW5jZSxcbiAgICAgIF9yZWYkY2FjaGUgPSBfcmVmLmNhY2hlLFxuICAgICAgY2FjaGUgPSBfcmVmJGNhY2hlID09PSB2b2lkIDAgPyAyNCAqIDYwICogNjAgOiBfcmVmJGNhY2hlLFxuICAgICAgY2FjaGVLZXkgPSBfcmVmLmNhY2hlS2V5LFxuICAgICAgZ29vZ2xlTWFwcyA9IF9yZWYuZ29vZ2xlTWFwcyxcbiAgICAgIGNhbGxiYWNrTmFtZSA9IF9yZWYuY2FsbGJhY2tOYW1lLFxuICAgICAgX3JlZiRkZWZhdWx0VmFsdWUgPSBfcmVmLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZWYkZGVmYXVsdFZhbHVlID09PSB2b2lkIDAgPyBcIlwiIDogX3JlZiRkZWZhdWx0VmFsdWUsXG4gICAgICBfcmVmJGluaXRPbk1vdW50ID0gX3JlZi5pbml0T25Nb3VudCxcbiAgICAgIGluaXRPbk1vdW50ID0gX3JlZiRpbml0T25Nb3VudCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkaW5pdE9uTW91bnQ7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIHJlYWR5ID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0UmVhZHkgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShkZWZhdWx0VmFsdWUpLFxuICAgICAgdmFsdWUgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0VmFsID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKHtcbiAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICBzdGF0dXM6IFwiXCIsXG4gICAgZGF0YTogW11cbiAgfSksXG4gICAgICBzdWdnZXN0aW9ucyA9IF91c2VTdGF0ZTNbMF0sXG4gICAgICBzZXRTdWdnZXN0aW9ucyA9IF91c2VTdGF0ZTNbMV07XG5cbiAgdmFyIGFzUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcmVxdWVzdE9wdGlvbnNSZWYgPSB1c2VMYXRlc3QocmVxdWVzdE9wdGlvbnMpO1xuICB2YXIgZ29vZ2xlTWFwc1JlZiA9IHVzZUxhdGVzdChnb29nbGVNYXBzKTtcbiAgdmFyIHVwYUNhY2hlS2V5ID0gY2FjaGVLZXkgPyBcInVwYS1cIiArIGNhY2hlS2V5IDogXCJ1cGFcIjtcbiAgdmFyIGluaXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nb29nbGUkbWFwcztcblxuICAgIGlmIChhc1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgdmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgICAgIGdvb2dsZSA9IF93aW5kb3cuZ29vZ2xlO1xuICAgIHZhciBnTWFwcyA9IGdvb2dsZU1hcHNSZWYuY3VycmVudDtcbiAgICB2YXIgcGxhY2VzTGliID0gKGdNYXBzID09IG51bGwgPyB2b2lkIDAgOiBnTWFwcy5wbGFjZXMpIHx8IChnb29nbGUgPT0gbnVsbCA/IHZvaWQgMCA6IChfZ29vZ2xlJG1hcHMgPSBnb29nbGUubWFwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nb29nbGUkbWFwcy5wbGFjZXMpO1xuXG4gICAgaWYgKCFwbGFjZXNMaWIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobG9hZEFwaUVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXNSZWYuY3VycmVudCA9IG5ldyBwbGFjZXNMaWIuQXV0b2NvbXBsZXRlU2VydmljZSgpO1xuICAgIHNldFJlYWR5KHRydWUpO1xuICB9LCBbXSk7XG4gIHZhciBjbGVhclN1Z2dlc3Rpb25zID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHNldFN1Z2dlc3Rpb25zKHtcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgc3RhdHVzOiBcIlwiLFxuICAgICAgZGF0YTogW11cbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgY2xlYXJDYWNoZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh1cGFDYWNoZUtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTa2lwIGV4Y2VwdGlvblxuICAgIH1cbiAgfSwgW10pO1xuICB2YXIgZmV0Y2hQcmVkaWN0aW9ucyA9IHVzZUNhbGxiYWNrKF9kZWJvdW5jZShmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIGNsZWFyU3VnZ2VzdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRTdWdnZXN0aW9ucyhmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZTdGF0ZSwge1xuICAgICAgICBsb2FkaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgY2FjaGVkRGF0YSA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlZERhdGEgPSBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0odXBhQ2FjaGVLZXkpIHx8IFwie31cIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTa2lwIGV4Y2VwdGlvblxuICAgIH1cblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVkRGF0YSA9IE9iamVjdC5rZXlzKGNhY2hlZERhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlZERhdGFba2V5XS5tYXhBZ2UgLSBEYXRlLm5vdygpID49IDApIGFjY1trZXldID0gY2FjaGVkRGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuXG4gICAgICBpZiAoY2FjaGVkRGF0YVt2YWxdKSB7XG4gICAgICAgIHNldFN1Z2dlc3Rpb25zKHtcbiAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBzdGF0dXM6IFwiT0tcIixcbiAgICAgICAgICBkYXRhOiBjYWNoZWREYXRhW3ZhbF0uZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvclxuXG5cbiAgICBhc1JlZi5jdXJyZW50LmdldFBsYWNlUHJlZGljdGlvbnMoX2V4dGVuZHMoe30sIHJlcXVlc3RPcHRpb25zUmVmLmN1cnJlbnQsIHtcbiAgICAgIGlucHV0OiB2YWxcbiAgICB9KSwgZnVuY3Rpb24gKGRhdGEsIHN0YXR1cykge1xuICAgICAgc2V0U3VnZ2VzdGlvbnMoe1xuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGRhdGE6IGRhdGEgfHwgW11cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2FjaGUgJiYgc3RhdHVzID09PSBcIk9LXCIpIHtcbiAgICAgICAgY2FjaGVkRGF0YVt2YWxdID0ge1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgbWF4QWdlOiBEYXRlLm5vdygpICsgY2FjaGUgKiAxMDAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHVwYUNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeShjYWNoZWREYXRhKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU2tpcCBleGNlcHRpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBkZWJvdW5jZSksIFtkZWJvdW5jZSwgY2xlYXJTdWdnZXN0aW9uc10pO1xuICB2YXIgc2V0VmFsdWUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsLCBzaG91bGRGZXRjaERhdGEpIHtcbiAgICBpZiAoc2hvdWxkRmV0Y2hEYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHNob3VsZEZldGNoRGF0YSA9IHRydWU7XG4gICAgfVxuXG4gICAgc2V0VmFsKHZhbCk7XG4gICAgaWYgKGFzUmVmLmN1cnJlbnQgJiYgc2hvdWxkRmV0Y2hEYXRhKSBmZXRjaFByZWRpY3Rpb25zKHZhbCk7XG4gIH0sIFtmZXRjaFByZWRpY3Rpb25zXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpbml0T25Nb3VudCkgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIF93aW5kb3cyID0gd2luZG93LFxuICAgICAgICBnb29nbGUgPSBfd2luZG93Mi5nb29nbGU7XG5cbiAgICBpZiAoIWdvb2dsZU1hcHNSZWYuY3VycmVudCAmJiAhKGdvb2dsZSAhPSBudWxsICYmIGdvb2dsZS5tYXBzKSAmJiBjYWxsYmFja05hbWUpIHtcbiAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gaW5pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBpZiAod2luZG93W2NhbGxiYWNrTmFtZV0pIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tOYW1lLCBpbml0XSk7XG4gIHJldHVybiB7XG4gICAgcmVhZHk6IHJlYWR5LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzdWdnZXN0aW9uczogc3VnZ2VzdGlvbnMsXG4gICAgc2V0VmFsdWU6IHNldFZhbHVlLFxuICAgIGNsZWFyU3VnZ2VzdGlvbnM6IGNsZWFyU3VnZ2VzdGlvbnMsXG4gICAgY2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcbiAgICBpbml0OiBpbml0XG4gIH07XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wYXQvY29tcGF0ICovXG52YXIgZ2VvY29kZUVyciA9IFwi8J+SoSB1c2UtcGxhY2VzLWF1dG9jb21wbGV0ZTogUGxlYXNlIHByb3ZpZGUgYW4gYWRkcmVzcyB3aGVuIHVzaW5nIGdldEdlb2NvZGUoKSB3aXRoIHRoZSBjb21wb25lbnRSZXN0cmljdGlvbnMuXCI7XG52YXIgZ2V0R2VvY29kZSA9IGZ1bmN0aW9uIGdldEdlb2NvZGUoYXJncykge1xuICB2YXIgZ2VvY29kZXIgPSBuZXcgd2luZG93Lmdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZ2VvY29kZXIuZ2VvY29kZShhcmdzLCBmdW5jdGlvbiAocmVzdWx0cywgc3RhdHVzKSB7XG4gICAgICBpZiAoc3RhdHVzICE9PSBcIk9LXCIpIHJlamVjdChzdGF0dXMpO1xuXG4gICAgICBpZiAoIWFyZ3MuYWRkcmVzcyAmJiBhcmdzLmNvbXBvbmVudFJlc3RyaWN0aW9ucykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGdlb2NvZGVFcnIpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9KTtcbn07XG52YXIgZ2V0TGF0TG5nID0gZnVuY3Rpb24gZ2V0TGF0TG5nKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3Jlc3VsdCRnZW9tZXRyeSRsb2NhID0gcmVzdWx0Lmdlb21ldHJ5LmxvY2F0aW9uLFxuICAgICAgICAgIGxhdCA9IF9yZXN1bHQkZ2VvbWV0cnkkbG9jYS5sYXQsXG4gICAgICAgICAgbG5nID0gX3Jlc3VsdCRnZW9tZXRyeSRsb2NhLmxuZztcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBsYXQ6IGxhdCgpLFxuICAgICAgICBsbmc6IGxuZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBnZXRaaXBDb2RlID0gZnVuY3Rpb24gZ2V0WmlwQ29kZShyZXN1bHQsIHVzZVNob3J0TmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgemlwQ29kZSA9IG51bGw7XG4gICAgICByZXN1bHQuYWRkcmVzc19jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGxvbmdfbmFtZSA9IF9yZWYubG9uZ19uYW1lLFxuICAgICAgICAgICAgc2hvcnRfbmFtZSA9IF9yZWYuc2hvcnRfbmFtZSxcbiAgICAgICAgICAgIHR5cGVzID0gX3JlZi50eXBlcztcbiAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKFwicG9zdGFsX2NvZGVcIikpIHppcENvZGUgPSB1c2VTaG9ydE5hbWUgPyBzaG9ydF9uYW1lIDogbG9uZ19uYW1lO1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlKHppcENvZGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIGdldERldGFpbHNFcnIgPSBcIvCfkqEgdXNlLXBsYWNlcy1hdXRvY29tcGxldGU6IFBsZWFzZSBwcm92aWRlIGEgcGxhY2UgSWQgd2hlbiB1c2luZyBnZXREZXRhaWxzKCkgZWl0aGVyIGFzIGEgc3RyaW5nIG9yIGFzIHBhcnQgb2YgYW4gQXV0b2NvbXBsZXRlIFByZWRpY3Rpb24uXCI7XG52YXIgZ2V0RGV0YWlscyA9IGZ1bmN0aW9uIGdldERldGFpbHMoYXJncykge1xuICB2YXIgUGxhY2VzU2VydmljZSA9IG5ldyB3aW5kb3cuZ29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlc1NlcnZpY2UoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG5cbiAgaWYgKCFhcmdzLnBsYWNlSWQpIHtcbiAgICBjb25zb2xlLmVycm9yKGdldERldGFpbHNFcnIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChnZXREZXRhaWxzRXJyKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgUGxhY2VzU2VydmljZS5nZXREZXRhaWxzKGFyZ3MsIGZ1bmN0aW9uIChyZXN1bHRzLCBzdGF0dXMpIHtcbiAgICAgIGlmIChzdGF0dXMgIT09IFwiT0tcIikgcmVqZWN0KHN0YXR1cyk7XG4gICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IHVzZVBsYWNlc0F1dG9jb21wbGV0ZSBhcyBkZWZhdWx0LCBnZXREZXRhaWxzLCBnZXRHZW9jb2RlLCBnZXRMYXRMbmcsIGdldFppcENvZGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/use-places-autocomplete/dist/index.esm.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Ffcamara%2FDocuments%2Fsptech%2Fprojetos-sptech%2Fonhome-maps-api%2Fpages%2Findex.tsx!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);